diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/foreign.c vips-8.16.1/libvips/foreign/foreign.c
--- vips-8.16.1.orig/libvips/foreign/foreign.c	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/foreign.c	2025-07-19 19:20:25.414242020 -0700
@@ -26,6 +26,8 @@
  * 	- drop incompatible ICC profiles before save
  * 24/7/21
  * 	- add fail_on
+ * 7/17/25 oteodoro
+ *      - Added includes for spngload.h and spngsave.h to fix implicit declaration warnings.
  */
 
 /*
@@ -512,6 +514,12 @@ static void
 vips_foreign_load_summary_class(VipsObjectClass *object_class, VipsBuf *buf)
 {
 	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_CLASS(object_class);
+	if (!class || !G_TYPE_CHECK_CLASS_TYPE(class, VIPS_TYPE_FOREIGN_LOAD)) {
+		g_log("vips", G_LOG_LEVEL_ERROR, "vips_foreign_load_summary_class: Invalid class pointer=%p", class);
+		return;
+	}
+	g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_load_summary_class: class=%s, header=%p, load=%p, is_a=%p",
+		VIPS_OBJECT_CLASS(class)->nickname, class->header, class->load, class->is_a);
 
 	VIPS_OBJECT_CLASS(vips_foreign_load_parent_class)
 		->summary_class(object_class, buf);
@@ -547,35 +555,42 @@ vips_foreign_find_load_sub(VipsForeignLo
 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS(load_class);
 	VipsForeignClass *class = VIPS_FOREIGN_CLASS(load_class);
 
-	/* Ignore the buffer and source loaders.
-	 */
+	g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load_sub: testing loader=%s for filename=%s",
+		object_class->nickname, filename);
+
+	/* Ignore the buffer and source loaders. */
 	if (g_str_has_suffix(object_class->nickname, "_buffer") ||
-		g_str_has_suffix(object_class->nickname, "_source"))
+		g_str_has_suffix(object_class->nickname, "_source")) {
+		g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load_sub: skipping %s (buffer or source loader)",
+			object_class->nickname);
 		return NULL;
-
-#ifdef DEBUG
-	printf("vips_foreign_find_load_sub: %s\n",
-		VIPS_OBJECT_CLASS(class)->nickname);
-#endif /*DEBUG*/
+	}
 
 	/* Try to sniff the filetype from the first few bytes, if we can,
 	 * otherwise fall back to checking the filename suffix.
 	 */
 	if (load_class->is_a) {
-		if (load_class->is_a(filename))
+		if (load_class->is_a(filename)) {
+			g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load_sub: loader=%s matches filename=%s",
+				object_class->nickname, filename);
 			return load_class;
-
-#ifdef DEBUG
-		printf("vips_foreign_find_load_sub: is_a failed\n");
-#endif /*DEBUG*/
-	}
-	else if (class->suffs) {
-		if (vips_filename_suffix_match(filename, class->suffs))
+		} else {
+			g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load_sub: loader=%s is_a failed for filename=%s",
+				object_class->nickname, filename);
+		}
+	} else if (class->suffs) {
+		if (vips_filename_suffix_match(filename, class->suffs)) {
+			g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load_sub: loader=%s matches suffix for filename=%s",
+				object_class->nickname, filename);
 			return load_class;
-	}
-	else
-		g_warning("loader %s has no is_a method and no suffix list",
+		} else {
+			g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load_sub: loader=%s suffix match failed for filename=%s",
+				object_class->nickname, filename);
+		}
+	} else {
+		g_log("vips", G_LOG_LEVEL_WARNING, "vips_foreign_find_load_sub: loader=%s has no is_a method and no suffix list",
 			object_class->nickname);
+	}
 
 	return NULL;
 }
@@ -600,32 +615,36 @@ vips_foreign_find_load(const char *name)
 
 	vips__filename_split8(name, filename, option_string);
 
+	g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load: filename=%s", filename);
+
 	/* Very common, so make a better error message for this case.
 	 */
 	if (!vips_existsf("%s", filename)) {
 		vips_error("VipsForeignLoad",
 			_("file \"%s\" does not exist"), name);
+		g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load: file does not exist");
 		return NULL;
 	}
 	if (vips_isdirf("%s", filename)) {
 		vips_error("VipsForeignLoad",
 			_("\"%s\" is a directory"), name);
+		g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load: file is a directory");
 		return NULL;
 	}
 
-	if (!(load_class = (VipsForeignLoadClass *) vips_foreign_map(
-			  "VipsForeignLoad",
-			  (VipsSListMap2Fn) vips_foreign_find_load_sub,
-			  (void *) filename, NULL))) {
-		vips_error("VipsForeignLoad",
-			_("\"%s\" is not a known file format"), name);
+	load_class = (VipsForeignLoadClass *) vips_foreign_map(
+		"VipsForeignLoad",
+		(VipsSListMap2Fn) vips_foreign_find_load_sub,
+		(void *) filename, NULL);
+
+	if (!load_class) {
+		vips_error("VipsForeignLoad", _("\"%s\" is not a known file format"), name);
+		g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load: filename=%s, no loader found", filename);
 		return NULL;
 	}
 
-#ifdef DEBUG
-	printf("vips_foreign_find_load: selected %s\n",
-		VIPS_OBJECT_CLASS(load_class)->nickname);
-#endif /*DEBUG*/
+	g_log("vips", G_LOG_LEVEL_DEBUG, "vips_foreign_find_load: filename=%s, selected=%s",
+		filename, VIPS_OBJECT_CLASS(load_class)->nickname);
 
 	return G_OBJECT_CLASS_NAME(load_class);
 }
@@ -1783,58 +1802,73 @@ vips__foreign_update_metadata(VipsImage
 static int
 vips_foreign_save_build(VipsObject *object)
 {
-	VipsForeignSave *save = VIPS_FOREIGN_SAVE(object);
+    VipsForeignSave *save = VIPS_FOREIGN_SAVE(object);
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "foreign_save: Starting build for object=%p, in=%p", object, save->in);
+
+    if (!save || !VIPS_IS_FOREIGN_SAVE(save)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "foreign_save: Invalid VipsForeignSave object: %p", save);
+        vips_error("foreign_save", "Invalid VipsForeignSave object");
+        return -1;
+    }
 
 	/* The deprecated "strip" field sets "keep" to none.
 	 */
-	if (vips_object_argument_isset(object, "strip") &&
-		!vips_object_argument_isset(object, "keep"))
-		save->keep = save->strip
-			? VIPS_FOREIGN_KEEP_NONE
-			: VIPS_FOREIGN_KEEP_ALL;
+    if (vips_object_argument_isset(object, "strip") &&
+        !vips_object_argument_isset(object, "keep"))
+        save->keep = save->strip ? VIPS_FOREIGN_KEEP_NONE : VIPS_FOREIGN_KEEP_ALL;
 
 	/* Keep ICC profile by default when a user profile has been set.
 	 */
-	if ((save->keep & VIPS_FOREIGN_KEEP_ICC) == 0 &&
-		vips_object_argument_isset(object, "profile"))
-		save->keep |= VIPS_FOREIGN_KEEP_ICC;
-
-	if (save->in) {
-		VipsForeignSaveClass *class = VIPS_FOREIGN_SAVE_GET_CLASS(save);
-		VipsImage *ready;
-		VipsImage *x;
-
-		if (vips__foreign_convert_saveable(save->in, &ready,
-				class->saveable, class->format_table, class->coding,
-				save->background))
-			return -1;
+    if ((save->keep & VIPS_FOREIGN_KEEP_ICC) == 0 &&
+        vips_object_argument_isset(object, "profile"))
+        save->keep |= VIPS_FOREIGN_KEEP_ICC;
+
+    if (save->in) {
+        VipsForeignSaveClass *class = VIPS_FOREIGN_SAVE_GET_CLASS(save);
+        VipsImage *ready;
+        VipsImage *x;
+
+        g_log("vips", G_LOG_LEVEL_DEBUG, "foreign_save: Converting image, saveable=%d, in=%p (Xsize=%d, Ysize=%d, Bands=%d, BandFmt=%d, Coding=%d)",
+              class->saveable, save->in, save->in->Xsize, save->in->Ysize, save->in->Bands, save->in->BandFmt, save->in->Coding);
+        if (vips__foreign_convert_saveable(save->in, &ready,
+                class->saveable, class->format_table, class->coding,
+                save->background)) {
+            g_log("vips", G_LOG_LEVEL_ERROR, "foreign_save: vips__foreign_convert_saveable failed: %s", vips_error_buffer());
+            vips_error("foreign_save", "Failed to convert image: %s", vips_error_buffer());
+            return -1;
+        }
 
 		/* Updating metadata, need to copy the image.
 		 */
-		if (vips_copy(ready, &x, NULL)) {
-			VIPS_UNREF(ready);
-			return -1;
-		}
-		VIPS_UNREF(ready);
-		ready = x;
-
-		if (vips__foreign_update_metadata(ready, save->keep)) {
-			VIPS_UNREF(ready);
-			return -1;
-		}
-
-		if (save->page_height)
-			vips_image_set_int(ready, VIPS_META_PAGE_HEIGHT,
-				save->page_height);
+        if (vips_copy(ready, &x, NULL)) {
+            g_log("vips", G_LOG_LEVEL_ERROR, "foreign_save: vips_copy failed: %s", vips_error_buffer());
+            VIPS_UNREF(ready);
+            return -1;
+        }
+        VIPS_UNREF(ready);
+        ready = x;
+
+        if (vips__foreign_update_metadata(ready, save->keep)) {
+            g_log("vips", G_LOG_LEVEL_ERROR, "foreign_save: vips__foreign_update_metadata failed: %s", vips_error_buffer());
+            VIPS_UNREF(ready);
+            return -1;
+        }
+
+        if (save->page_height)
+            vips_image_set_int(ready, VIPS_META_PAGE_HEIGHT, save->page_height);
+
+        VIPS_UNREF(save->ready);
+        save->ready = ready;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "foreign_save: Calling parent build, in=%p, ready=%p", save->in, save->ready);
+    if (VIPS_OBJECT_CLASS(vips_foreign_save_parent_class)->build(object)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "foreign_save: Parent build failed: %s", vips_error_buffer());
+        return -1;
+    }
 
-		VIPS_UNREF(save->ready);
-		save->ready = ready;
-	}
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_parent_class)->build(object))
-		return -1;
-
-	return 0;
+    return 0;
 }
 
 #define UC VIPS_FORMAT_UCHAR
@@ -2960,9 +2994,12 @@ vips_foreign_operation_init(void)
 	extern GType vips_foreign_save_png_buffer_get_type(void);
 	extern GType vips_foreign_save_png_target_get_type(void);
 
-	extern GType vips_foreign_save_spng_file_get_type(void);
+#ifdef HAVE_SPNG
+	extern GType vips_foreign_load_spng_get_type(void);
+	extern GType vips_foreign_load_spng_buffer_get_type(void);
+	extern GType vips_foreign_save_spng_get_type(void);
 	extern GType vips_foreign_save_spng_buffer_get_type(void);
-	extern GType vips_foreign_save_spng_target_get_type(void);
+#endif /*HAVE_SPNG*/
 
 	extern GType vips_foreign_load_csv_file_get_type(void);
 	extern GType vips_foreign_load_csv_source_get_type(void);
@@ -3186,12 +3223,10 @@ vips_foreign_operation_init(void)
 #endif /*HAVE_PNG*/
 
 #ifdef HAVE_SPNG
-	vips_foreign_load_png_file_get_type();
-	vips_foreign_load_png_buffer_get_type();
-	vips_foreign_load_png_source_get_type();
-	vips_foreign_save_spng_file_get_type();
-	vips_foreign_save_spng_buffer_get_type();
-	vips_foreign_save_spng_target_get_type();
+	g_type_ensure(vips_foreign_load_spng_get_type());
+	g_type_ensure(vips_foreign_load_spng_buffer_get_type());
+	g_type_ensure(vips_foreign_save_spng_get_type());
+	g_type_ensure(vips_foreign_save_spng_buffer_get_type());
 #endif /*HAVE_SPNG*/
 
 #ifdef HAVE_MATIO
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/meson.build vips-8.16.1/libvips/foreign/meson.build
--- vips-8.16.1.orig/libvips/foreign/meson.build	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/meson.build	2025-07-19 19:16:37.346854665 -0700
@@ -44,8 +44,6 @@ foreign_sources = files(
     'radsave.c',
     'rawload.c',
     'rawsave.c',
-    'spngload.c',
-    'spngsave.c',
     'svgload.c',
     'tiff2vips.c',
     'tiff.c',
@@ -61,6 +59,18 @@ foreign_sources = files(
     'webpsave.c',
 )
 
+if spng_dep.found()
+    foreign_sources += files(
+        'spngload.c',
+        'spngsave.c',
+    )
+    install_headers(
+        'spngload.h',
+        'spngsave.h',
+        subdir: 'vips/foreign'
+    )
+endif
+
 foreign_headers = files(
     'dbh.h',
     'jpeg.h',
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngload.c vips-8.16.1/libvips/foreign/spngload.c
--- vips-8.16.1.orig/libvips/foreign/spngload.c	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/spngload.c	2025-07-19 19:16:37.347537005 -0700
@@ -8,6 +8,37 @@
  *	-  add "unlimited" flag to png load
  * 3/2/23 MathemanFlo
  * 	- add bits per sample metadata
+ * 7/11/25 oteodoro
+ *      - Replaced with Grok 3 implementation to avoid symbol collision.
+ * 7/15/25 oteodoro
+ *      - Fixed unterminated #ifdef and GQuark undeclared error.
+ * 7/16/25 grok
+ *      - Enhanced debug logging and fixed filename property registration.
+ *      - Fixed spng_exc typo and ctx declaration.
+ *      - Switched to g_object_class_install_property for filename.
+ * 7/16/25 grok
+ *      - Replaced switch-based property handling with g_str_equal for dynamic property_id support.
+ *      - Added robust cleanup in error paths and streamlined filename validation.
+ *      - Added VIPS_ARGUMENT_CONSTRUCT to filename property and set finalize to NULL.
+ * 7/16/25 grok
+ *      - Registered vips_foreign_load_spng_file_build in class_init to fix unused-function warning.
+ * 7/17/25 grok
+ *      - Added forward declarations for vips_foreign_load_spng_get_flags_filename,
+ *        vips_foreign_load_spng_get_flags, and vips_foreign_load_spng_header to fix undeclared errors.
+ *      - Replaced vips_blob_unref with g_object_unref to fix linker error.
+ *      - Removed unused 'load' variable in vips_foreign_load_spng_file_build.
+ *      - Added is_a method for PNG file detection.
+ *      - Removed suffixes assignment for VIPS 8.16.1 compatibility.
+ *      - Fixed vips_spngload to directly set filename and call build/load, avoiding vips_call_split.
+ *      - Added direct spng->filename setting and extra debug logging to diagnose property issue.
+ *      - Fixed VIPS_FOREIGN_LOAD_SPNG macro issue by defining it in spngload.h.
+ *      - Corrected load->out type mismatch.
+ *      - Removed invalid VipsForeignLoad->filename references due to compilation errors.
+ *      - Restored direct spng->filename setting in vips_spngload and retained g_object_set for debugging.
+ *      - Moved filename setting before vips_object_build to avoid premature build call.
+ *      - Switched to g_object_new in vips_spngload to prevent automatic vips_object_build call.
+ *      - Added more debug logging around g_object_new and cast.
+ *      - Retained RGB/RGBA 8-bit buffer-based loading for sharp-libvips.
  */
 
 /*
@@ -44,880 +75,860 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
-#include <glib/gi18n-lib.h>
 
+#include <vips/vips.h>
+#include <vips/debug.h>
+#include <vips/foreign.h>
+#include <glib.h>
 #include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
+#include <errno.h>
 
-#include <vips/vips.h>
-#include <vips/buf.h>
-#include <vips/internal.h>
-
-#include "pforeign.h"
+/* Include libintl.h for internationalization if available */
+#ifdef ENABLE_NLS
+#include <libintl.h>
+#define _(String) gettext(String)
+#else
+#define _(String) (String)
+#endif
 
 #ifdef HAVE_SPNG
 
 #include <spng.h>
+#include "spngload.h"
 
-typedef struct _VipsForeignLoadPng {
-	VipsForeignLoad parent_object;
-
-	/* Set by subclasses.
-	 */
-	VipsSource *source;
-
-	/* Remove DoS limits.
-	 */
-	gboolean unlimited;
-
-	spng_ctx *ctx;
-	struct spng_ihdr ihdr;
-	enum spng_format fmt;
-	int bands;
-	VipsInterpretation interpretation;
-	VipsBandFormat format;
-	int y_pos;
-} VipsForeignLoadPng;
-
-typedef VipsForeignLoadClass VipsForeignLoadPngClass;
-
-G_DEFINE_ABSTRACT_TYPE(VipsForeignLoadPng, vips_foreign_load_png,
-	VIPS_TYPE_FOREIGN_LOAD);
+#define PROP_SOURCE 1
+#define PROP_FILENAME 2
 
-static void
-vips_foreign_load_png_dispose(GObject *gobject)
-{
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) gobject;
 
-	VIPS_FREEF(spng_ctx_free, png->ctx);
-	VIPS_UNREF(png->source);
-
-	G_OBJECT_CLASS(vips_foreign_load_png_parent_class)->dispose(gobject);
+typedef struct _VipsForeignLoadSpng {
+    VipsForeignLoad parent_object;
+    VipsSource *source;
+    char *filename;
+} VipsForeignLoadSpng;
+
+typedef struct _VipsForeignLoadSpngClass {
+    VipsForeignLoadClass parent_class;
+} VipsForeignLoadSpngClass;
+
+typedef struct _VipsForeignLoadSpngBuffer {
+    VipsForeignLoad parent_object;
+    void *buf;
+    size_t len;
+} VipsForeignLoadSpngBuffer;
+
+typedef struct _VipsForeignLoadSpngBufferClass {
+    VipsForeignLoadClass parent_class;
+} VipsForeignLoadSpngBufferClass;
+
+G_DEFINE_TYPE(VipsForeignLoadSpng, vips_foreign_load_spng, VIPS_TYPE_FOREIGN_LOAD);
+G_DEFINE_TYPE(VipsForeignLoadSpngBuffer, vips_foreign_load_spng_buffer, VIPS_TYPE_FOREIGN_LOAD);
+
+static gboolean spng_class_initialized = FALSE;
+
+static void
+vips_foreign_load_spng_dispose(GObject *gobject)
+{
+    VipsForeignLoadSpng *load = (VipsForeignLoadSpng *) gobject;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Disposing VipsForeignLoadSpng, source=%p (ref_count=%d)",
+          load->source, load->source ? G_OBJECT(load->source)->ref_count : 0);
+
+    VIPS_UNREF(load->source);
+    VIPS_FREE(load->filename);
+
+    G_OBJECT_CLASS(vips_foreign_load_spng_parent_class)->dispose(gobject);
+}
+
+static void
+vips_foreign_load_spng_set_property(GObject *gobject, guint property_id,
+    const GValue *value, GParamSpec *pspec)
+{
+    VipsForeignLoadSpng *load = (VipsForeignLoadSpng *) gobject;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: set_property called with property_id=%u, name=%s",
+          property_id, pspec ? g_param_spec_get_name(pspec) : "(null)");
+
+    if (!pspec) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: NULL pspec for property_id=%u", property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        return;
+    }
+
+    switch (property_id) {
+    case PROP_SOURCE:
+        {
+            GObject *obj = g_value_get_object(value);
+            g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Setting source property (ID=%u)", property_id);
+            VIPS_UNREF(load->source);
+            if (obj && VIPS_IS_SOURCE(obj)) {
+                load->source = VIPS_SOURCE(g_object_ref(obj));
+                g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Source set to %p (type=%s, ref_count=%d)",
+                      load->source, G_OBJECT_TYPE_NAME(load->source), G_OBJECT(load->source)->ref_count);
+            } else {
+                load->source = NULL;
+                g_log("vips", G_LOG_LEVEL_WARNING, "spngload: Source value is %s",
+                      obj ? "not a VipsSource" : "NULL");
+            }
+        }
+        break;
+    case PROP_FILENAME:
+        {
+            const char *filename = g_value_get_string(value);
+            g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Setting filename property: %s", filename ? filename : "(null)");
+            VIPS_FREE(load->filename);
+            load->filename = g_strdup(filename);
+            VIPS_UNREF(load->source);
+            if (filename && *filename) {
+                load->source = vips_source_new_from_file(filename);
+                if (!load->source) {
+                    g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create source from filename: %s", filename);
+                    vips_error("spngload", "Failed to create source from filename: %s", filename);
+                }
+            } else {
+                load->source = NULL;
+                g_log("vips", G_LOG_LEVEL_WARNING, "spngload: Filename is empty or NULL");
+            }
+        }
+        break;
+    default:
+        g_log("vips", G_LOG_LEVEL_WARNING, "spngload: Unknown property: %s, ID=%u",
+              g_param_spec_get_name(pspec), property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        break;
+    }
+}
+
+static void
+vips_foreign_load_spng_get_property(GObject *gobject, guint property_id,
+    GValue *value, GParamSpec *pspec)
+{
+    VipsForeignLoadSpng *load = (VipsForeignLoadSpng *) gobject;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: get_property called with property_id=%u, name=%s",
+          property_id, pspec ? g_param_spec_get_name(pspec) : "(null)");
+
+    if (!pspec) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: NULL pspec for property_id=%u", property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        return;
+    }
+
+    switch (property_id) {
+    case PROP_SOURCE:
+        g_value_set_object(value, load->source);
+        break;
+    case PROP_FILENAME:
+        g_value_set_string(value, load->filename);
+        break;
+    default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        break;
+    }
 }
 
 static int
-vips_foreign_load_png_stream(spng_ctx *ctx, void *user,
-	void *dest, size_t length)
+vips_foreign_load_spng_build(VipsObject *object)
 {
-	VipsSource *source = VIPS_SOURCE(user);
-
-	while (length > 0) {
-		gint64 bytes_read;
+    VipsForeignLoadSpng *spngload = (VipsForeignLoadSpng *) object;
 
-		bytes_read = vips_source_read(source, dest, length);
-		if (bytes_read < 0)
-			return SPNG_IO_ERROR;
-		if (bytes_read == 0)
-			return SPNG_IO_EOF;
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Building VipsForeignLoadSpng for source=%p",
+          spngload->source);
 
-		dest = (char *) dest + bytes_read;
-		length -= bytes_read;
-	}
+    if (!spngload->source) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: No source provided");
+        vips_error("spngload", "No source provided");
+        return -1;
+    }
 
-	return 0;
-}
-
-static VipsForeignFlags
-vips_foreign_load_png_get_flags_source(VipsSource *source)
-{
-	spng_ctx *ctx;
-	struct spng_ihdr ihdr;
-	VipsForeignFlags flags;
-
-	ctx = spng_ctx_new(SPNG_CTX_IGNORE_ADLER32);
-	spng_set_crc_action(ctx, SPNG_CRC_USE, SPNG_CRC_USE);
-	if (vips_source_rewind(source))
-		return 0;
-	spng_set_png_stream(ctx,
-		vips_foreign_load_png_stream, source);
-	if (spng_get_ihdr(ctx, &ihdr)) {
-		spng_ctx_free(ctx);
-		return 0;
-	}
-	spng_ctx_free(ctx);
-
-	flags = 0;
-	if (ihdr.interlace_method != SPNG_INTERLACE_NONE)
-		flags |= VIPS_FOREIGN_PARTIAL;
-	else
-		flags |= VIPS_FOREIGN_SEQUENTIAL;
+    if (VIPS_OBJECT_CLASS(vips_foreign_load_spng_parent_class)->build(object)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Parent build failed: %s", vips_error_buffer());
+        return -1;
+    }
 
-	return flags;
+    return 0;
 }
 
 static VipsForeignFlags
-vips_foreign_load_png_get_flags(VipsForeignLoad *load)
+vips_foreign_load_spng_get_flags_filename(const char *filename)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-
-	return vips_foreign_load_png_get_flags_source(png->source);
+    return VIPS_FOREIGN_PARTIAL;
 }
 
 static VipsForeignFlags
-vips_foreign_load_png_get_flags_filename(const char *filename)
-{
-	VipsSource *source;
-	VipsForeignFlags flags;
-
-	if (!(source = vips_source_new_from_file(filename)))
-		return 0;
-	flags = vips_foreign_load_png_get_flags_source(source);
-	VIPS_UNREF(source);
-
-	return flags;
-}
-
-/* Set the png text data as metadata on the vips image. These are always
- * null-terminated strings.
- */
-static void
-vips_foreign_load_png_set_text(VipsImage *out,
-	int i, const char *key, const char *value)
+vips_foreign_load_spng_get_flags(VipsForeignLoad *load)
 {
-#ifdef DEBUG
-	printf("vips_foreign_load_png_set_text: key %s, value %s\n",
-		key, value);
-#endif /*DEBUG*/
-
-	if (strcmp(key, "XML:com.adobe.xmp") == 0) {
-		/* Save as an XMP tag. This must be a BLOB, for compatibility
-		 * for things like the XMP blob that the tiff loader adds.
-		 *
-		 * Note that this will remove the null-termination from the
-		 * string. We must carefully reattach this.
-		 */
-		vips_image_set_blob_copy(out,
-			VIPS_META_XMP_NAME, value, strlen(value));
-	}
-	else {
-		char name[256];
-
-		/* Save as a string comment. Some PNGs have EXIF data as
-		 * text segments, unfortunately.
-		 */
-		g_snprintf(name, 256, "png-comment-%d-%s", i, key);
-
-		vips_image_set_string(out, name, value);
-	}
+    return VIPS_FOREIGN_PARTIAL;
 }
 
-static int
-vips_foreign_load_png_set_header(VipsForeignLoadPng *png, VipsImage *image)
-{
-	double xres, yres;
-	struct spng_iccp iccp;
-	struct spng_exif exif;
-	struct spng_phys phys;
-	struct spng_bkgd bkgd;
-	guint32 n_text;
-
-	/* Get resolution. Default to 72 pixels per inch.
-	 */
-	xres = 72.0 / 25.4;
-	yres = 72.0 / 25.4;
-	if (!spng_get_phys(png->ctx, &phys)) {
-		/* unit 1 means pixels per metre, otherwise unspecified.
-		 */
-		xres = phys.unit_specifier == 1
-			? phys.ppu_x / 1000.0
-			: phys.ppu_x;
-		yres = phys.unit_specifier == 1
-			? phys.ppu_y / 1000.0
-			: phys.ppu_y;
-	}
-
-	vips_image_init_fields(image,
-		png->ihdr.width, png->ihdr.height, png->bands,
-		png->format, VIPS_CODING_NONE, png->interpretation,
-		xres, yres);
-
-	VIPS_SETSTR(image->filename,
-		vips_connection_filename(VIPS_CONNECTION(png->source)));
-
-	if (vips_image_pipelinev(image, VIPS_DEMAND_STYLE_THINSTRIP, NULL))
-		return -1;
-
-	if (!spng_get_iccp(png->ctx, &iccp))
-		vips_image_set_blob_copy(image,
-			VIPS_META_ICC_NAME, iccp.profile, iccp.profile_len);
-
-	if (!spng_get_text(png->ctx, NULL, &n_text)) {
-		struct spng_text *text;
-
-		/* Very large numbers of text chunks are used in DoS
-		 * attacks.
-		 */
-		if (!png->unlimited && n_text > MAX_PNG_TEXT_CHUNKS) {
-			g_warning(_("%d text chunks, only %d text chunks will be loaded"),
-				n_text, MAX_PNG_TEXT_CHUNKS);
-			n_text = MAX_PNG_TEXT_CHUNKS;
-		}
-
-		text = VIPS_ARRAY(VIPS_OBJECT(png),
-			n_text, struct spng_text);
-		if (!spng_get_text(png->ctx, text, &n_text)) {
-			guint32 i;
-
-			for (i = 0; i < n_text; i++)
-				/* .text is always a null-terminated C string.
-				 */
-				vips_foreign_load_png_set_text(image,
-					i, text[i].keyword, text[i].text);
-		}
-	}
-
-	if (!spng_get_exif(png->ctx, &exif))
-		vips_image_set_blob_copy(image, VIPS_META_EXIF_NAME,
-			exif.data, exif.length);
-
-	vips_image_set_int(image, VIPS_META_BITS_PER_SAMPLE,
-		png->ihdr.bit_depth);
-
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) {
-		/* Deprecated "palette-bit-depth" use "bits-per-sample" instead.
-		 */
-		vips_image_set_int(image,
-			"palette-bit-depth", png->ihdr.bit_depth);
-
-		vips_image_set_int(image, VIPS_META_PALETTE, 1);
-	}
-
-	/* Let our caller know. These are very expensive to decode.
-	 */
-	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE)
-		vips_image_set_int(image, "interlaced", 1);
-
-	if (!spng_get_bkgd(png->ctx, &bkgd)) {
-		const int scale =
-			image->BandFmt == VIPS_FORMAT_UCHAR ? 1 : 256;
-
-		double array[3];
-		int n;
-
-		switch (png->ihdr.color_type) {
-		case SPNG_COLOR_TYPE_GRAYSCALE:
-		case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
-			array[0] = bkgd.gray / scale;
-			n = 1;
-			break;
-
-		case SPNG_COLOR_TYPE_TRUECOLOR:
-		case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
-			array[0] = bkgd.red / scale;
-			array[1] = bkgd.green / scale;
-			array[2] = bkgd.blue / scale;
-			n = 3;
-			break;
-
-		case SPNG_COLOR_TYPE_INDEXED:
-		default:
-			/* Not sure what to do here. I suppose we should read
-			 * the palette.
-			 */
-			n = 0;
-			break;
-		}
-
-		if (n > 0)
-			vips_image_set_array_double(image, "background",
-				array, n);
-	}
-
-	return 0;
-}
-
-static int
-vips_foreign_load_png_header(VipsForeignLoad *load)
+static gboolean
+vips_foreign_load_spng_is_a(const char *filename)
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-
-	int flags;
-	int error;
-	struct spng_trns trns;
-
-	/* In non-fail mode, ignore CRC errors.
-	 */
-	flags = 0;
-	if (load->fail_on < VIPS_FAIL_ON_ERROR)
-		flags |= SPNG_CTX_IGNORE_ADLER32;
-	png->ctx = spng_ctx_new(flags);
-	if (load->fail_on < VIPS_FAIL_ON_ERROR)
-		/* Ignore and don't calculate checksums.
-		 */
-		spng_set_crc_action(png->ctx, SPNG_CRC_USE, SPNG_CRC_USE);
-
-	/* Set limits to avoid decompression bombs. Set chunk limits to 60mb
-	 * -- we've seen 50mb XMP blocks in the wild.
-	 *
-	 * No need to test the decoded image size -- the user can do that if
-	 * they wish.
-	 */
-	if (!png->unlimited) {
-		spng_set_image_limits(png->ctx,
-			VIPS_MAX_COORD, VIPS_MAX_COORD);
-		spng_set_chunk_limits(png->ctx,
-			60 * 1024 * 1024, 60 * 1024 * 1024);
-	}
-
-	if (vips_source_rewind(png->source))
-		return -1;
-	spng_set_png_stream(png->ctx,
-		vips_foreign_load_png_stream, png->source);
-	if ((error = spng_get_ihdr(png->ctx, &png->ihdr))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-#ifdef DEBUG
-	printf("width: %d\nheight: %d\nbit depth: %d\ncolor type: %d\n",
-		png->ihdr.width, png->ihdr.height,
-		png->ihdr.bit_depth, png->ihdr.color_type);
-	printf("compression method: %d\nfilter method: %d\n"
-		   "interlace method: %d\n",
-		png->ihdr.compression_method, png->ihdr.filter_method,
-		png->ihdr.interlace_method);
-#endif /*DEBUG*/
-
-	/* Just convert to host-endian if nothing else applies.
-	 */
-	png->fmt = SPNG_FMT_PNG;
-
-	switch (png->ihdr.color_type) {
-	case SPNG_COLOR_TYPE_INDEXED:
-		png->bands = 3;
-		break;
-
-	case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
-	case SPNG_COLOR_TYPE_GRAYSCALE:
-		png->bands = 1;
-		break;
-
-	case SPNG_COLOR_TYPE_TRUECOLOR:
-	case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
-		png->bands = 3;
-		break;
-
-	default:
-		vips_error(class->nickname, "%s", _("unknown color type"));
-		return -1;
-	}
-
-	/* Set libvips format and interpretation.
-	 */
-	if (png->ihdr.bit_depth > 8) {
-		if (png->bands < 3)
-			png->interpretation = VIPS_INTERPRETATION_GREY16;
-		else
-			png->interpretation = VIPS_INTERPRETATION_RGB16;
-
-		png->format = VIPS_FORMAT_USHORT;
-	}
-	else {
-		if (png->bands < 3)
-			png->interpretation = VIPS_INTERPRETATION_B_W;
-		else
-			png->interpretation = VIPS_INTERPRETATION_sRGB;
-
-		png->format = VIPS_FORMAT_UCHAR;
-	}
-
-	/* Expand palette images.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
-		png->fmt = SPNG_FMT_RGB8;
-
-	/* Expand <8 bit images to full bytes.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE &&
-		png->ihdr.bit_depth < 8)
-		png->fmt = SPNG_FMT_G8;
-
-	/* Try reading the optional transparency chunk. This will cause all
-	 * chunks up to the first IDAT to be read in, so it can fail if any
-	 * chunk has an error.
-	 */
-	error = spng_get_trns(png->ctx, &trns);
-	if (error &&
-		error != SPNG_ECHUNKAVAIL) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	/* Expand transparency.
-	 *
-	 * The _ALPHA types should not have the optional trns chunk (they
-	 * always have a transparent band), see
-	 * https://www.w3.org/TR/2003/REC-PNG-20031110/#11tRNS
-	 *
-	 * It's quick and safe to call spng_get_trns() again, and we now know
-	 * it will only fail for no transparency chunk.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA ||
-		png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA)
-		png->bands += 1;
-	else if (!spng_get_trns(png->ctx, &trns)) {
-		png->bands += 1;
-
-		if (png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) {
-			if (png->ihdr.bit_depth == 16)
-				png->fmt = SPNG_FMT_RGBA16;
-			else
-				png->fmt = SPNG_FMT_RGBA8;
-		}
-		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
-			png->fmt = SPNG_FMT_RGBA8;
-		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE) {
-			if (png->ihdr.bit_depth == 16)
-				png->fmt = SPNG_FMT_GA16;
-			else
-				png->fmt = SPNG_FMT_GA8;
-		}
-	}
-
-	vips_source_minimise(png->source);
-
-	if (vips_foreign_load_png_set_header(png, load->out))
-		return -1;
-
-	return 0;
-}
+    unsigned char buf[8];
+    FILE *file = fopen(filename, "rb");
+    if (!file) {
+        g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Failed to open file %s: %s",
+              filename, strerror(errno));
+        return FALSE;
+    }
+
+    size_t read = fread(buf, 1, 8, file);
+    fclose(file);
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: is_a check for %s, read=%zu", filename, read);
+
+    if (read < 8) {
+        return FALSE;
+    }
 
-static void
-vips_foreign_load_png_minimise(VipsObject *object, VipsForeignLoadPng *png)
-{
-	vips_source_minimise(png->source);
+    const unsigned char png_signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
+    return memcmp(buf, png_signature, 8) == 0;
 }
 
 static int
-vips_foreign_load_png_generate(VipsRegion *out_region,
-	void *seq, void *a, void *b, gboolean *stop)
+vips_foreign_load_spng_header(VipsForeignLoad *load)
 {
-	VipsRect *r = &out_region->valid;
-	VipsForeignLoad *load = VIPS_FOREIGN_LOAD(a);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(png);
-
-	int y;
-	int error;
-
-#ifdef DEBUG
-	printf("vips_foreign_load_png_generate: line %d, %d rows\n",
-		r->top, r->height);
-	printf("vips_foreign_load_png_generate: y_top = %d\n", png->y_pos);
-#endif /*DEBUG*/
-
-	/* We're inside a tilecache where tiles are the full image width, so
-	 * this should always be true.
-	 */
-	g_assert(r->left == 0);
-	g_assert(r->width == out_region->im->Xsize);
-	g_assert(VIPS_RECT_BOTTOM(r) <= out_region->im->Ysize);
-
-	/* Tiles should always be a strip in height, unless it's the final
-	 * strip.
-	 */
-	g_assert(r->height ==
-		VIPS_MIN(VIPS__FATSTRIP_HEIGHT, out_region->im->Ysize - r->top));
-
-	/* And check that y_pos is correct. It should be, since we are inside
-	 * a vips_sequential().
-	 */
-	if (r->top != png->y_pos) {
-		vips_error(class->nickname,
-			_("out of order read at line %d"), png->y_pos);
-		return -1;
-	}
-
-	for (y = 0; y < r->height; y++) {
-		/* libspng returns EOI when successfully reading the
-		 * final line of input.
-		 */
-		error = spng_decode_row(png->ctx,
-			VIPS_REGION_ADDR(out_region, 0, r->top + y),
-			VIPS_REGION_SIZEOF_LINE(out_region));
-		if (error != 0 &&
-			error != SPNG_EOI) {
-			/* We've failed to read some pixels. Knock this
-			 * operation out of cache.
-			 */
-			vips_operation_invalidate(VIPS_OPERATION(png));
-
-#ifdef DEBUG
-			printf("vips_foreign_load_png_generate:\n");
-			printf("  spng_decode_row() failed, line %d\n",
-				r->top + y);
-			printf("  thread %p\n", g_thread_self());
-			printf("  error %s\n", spng_strerror(error));
-#endif /*DEBUG*/
-
-			g_warning("%s: %s",
-				class->nickname, spng_strerror(error));
-
-			/* And bail if trunc is on.
-			 */
-			if (load->fail_on >= VIPS_FAIL_ON_TRUNCATED) {
-				vips_error(class->nickname,
-					"%s", _("libspng read error"));
-				return -1;
-			}
-		}
+    VipsForeignLoadSpng *spngload = (VipsForeignLoadSpng *) load;
+    VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS(load);
 
-		png->y_pos += 1;
-	}
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Processing header for source=%p",
+          spngload->source);
 
-	return 0;
+    if (!spngload->source || !VIPS_IS_SOURCE(spngload->source)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Invalid or NULL source: %p", spngload->source);
+        vips_error(object_class->nickname, "Invalid or NULL source");
+        return -1;
+    }
+
+    if (vips_source_decode(spngload->source)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to decode source");
+        vips_error(object_class->nickname, "Failed to decode source");
+        return -1;
+    }
+
+    size_t data_length = vips_source_length(spngload->source);
+    if (data_length == 0) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to get source length");
+        vips_error(object_class->nickname, "Failed to get source length");
+        return -1;
+    }
+
+    void *data_buffer = g_malloc(data_length);
+    if (!data_buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to allocate data buffer");
+        vips_error(object_class->nickname, "Failed to allocate data buffer");
+        return -1;
+    }
+
+    gint64 read_length = vips_source_read(spngload->source, data_buffer, data_length);
+    if (read_length < 0 || (size_t)read_length != data_length) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to read source data: read %ld bytes, expected %zu",
+              read_length, data_length);
+        vips_error(object_class->nickname, "Failed to read source data");
+        g_free(data_buffer);
+        return -1;
+    }
+
+    spng_ctx *ctx = spng_ctx_new(0);
+    if (!ctx) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create spng_ctx");
+        vips_error(object_class->nickname, "Failed to create spng context");
+        g_free(data_buffer);
+        return -1;
+    }
+
+    int err = spng_set_png_buffer(ctx, data_buffer, data_length);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set PNG buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+
+    struct spng_ihdr ihdr;
+    err = spng_get_ihdr(ctx, &ihdr);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to get IHDR: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Header processed: width=%u, height=%u, bands=%u",
+          ihdr.width, ihdr.height, ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR ? 3 : 4);
+
+    load->out = vips_image_new();
+    if (!load->out) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create new VipsImage");
+        vips_error(object_class->nickname, "Failed to create new VipsImage");
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+
+    vips_image_init_fields(load->out,
+        ihdr.width, ihdr.height,
+        ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR ? 3 : 4,
+        VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0);
+
+    if (vips_image_pipelinev(load->out, VIPS_DEMAND_STYLE_THINSTRIP, NULL)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set up image pipeline");
+        vips_error(object_class->nickname, "Failed to set up image pipeline");
+        g_object_unref(load->out);
+        load->out = NULL;
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+
+    spng_ctx_free(ctx);
+    g_free(data_buffer);
+    return 0;
 }
 
 static int
-vips_foreign_load_png_load(VipsForeignLoad *load)
+vips_foreign_load_spng_file(VipsForeignLoad *load)
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-	VipsImage **t = (VipsImage **)
-		vips_object_local_array(VIPS_OBJECT(load), 3);
-
-	enum spng_decode_flags flags;
-	int error;
-
-	if (vips_source_decode(png->source))
-		return -1;
-
-	/* Decode transparency, if available.
-	 */
-	flags = SPNG_DECODE_TRNS;
-
-	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE) {
-		/* Arg awful interlaced image. We have to load to a huge mem
-		 * buffer, then copy to out.
-		 */
-		t[0] = vips_image_new_memory();
-		if (vips_foreign_load_png_set_header(png, t[0]) ||
-			vips_image_write_prepare(t[0]))
-			return -1;
-
-		if ((error = spng_decode_image(png->ctx,
-				 VIPS_IMAGE_ADDR(t[0], 0, 0),
-				 VIPS_IMAGE_SIZEOF_IMAGE(t[0]),
-				 png->fmt, flags))) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-
-		/* We've now finished reading the file.
-		 */
-		vips_source_minimise(png->source);
-
-		if (vips_image_write(t[0], load->real))
-			return -1;
-	}
-	else {
-		t[0] = vips_image_new();
-
-		if (vips_foreign_load_png_set_header(png, t[0]))
-			return -1;
-
-		/* We can decode these progressively.
-		 */
-		flags |= SPNG_DECODE_PROGRESSIVE;
-
-		if ((error = spng_decode_image(png->ctx, NULL, 0,
-				 png->fmt, flags))) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-
-		/* Close input immediately at end of read.
-		 */
-		g_signal_connect(t[0], "minimise",
-			G_CALLBACK(vips_foreign_load_png_minimise), png);
-
-		if (vips_image_generate(t[0],
-				NULL, vips_foreign_load_png_generate, NULL,
-				png, NULL) ||
-			vips_sequential(t[0], &t[1],
-				"tile_height", VIPS__FATSTRIP_HEIGHT,
-				NULL) ||
-			vips_image_write(t[1], load->real))
-			return -1;
-	}
-
-	return 0;
+    VipsForeignLoadSpng *spngload = (VipsForeignLoadSpng *) load;
+    VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS(load);
+    spng_ctx *ctx = NULL;
+    unsigned char *out_buffer = NULL;
+    void *data_buffer = NULL;
+    size_t data_length = 0;
+    size_t out_size;
+    gint64 read_length;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Loading from source=%p (type=%s, ref_count=%d)",
+          spngload->source, spngload->source ? G_OBJECT_TYPE_NAME(spngload->source) : "NULL",
+          spngload->source ? G_OBJECT(spngload->source)->ref_count : 0);
+
+    if (!spngload->source || !VIPS_IS_SOURCE(spngload->source)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Invalid or NULL source: %p", spngload->source);
+        vips_error(object_class->nickname, "Invalid or NULL source");
+        return -1;
+    }
+
+    if (vips_source_decode(spngload->source)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to decode source");
+        vips_error(object_class->nickname, "Failed to decode source");
+        return -1;
+    }
+
+    data_length = vips_source_length(spngload->source);
+    if (data_length == 0) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to get source length");
+        vips_error(object_class->nickname, "Failed to get source length");
+        return -1;
+    }
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Source length=%zu bytes", data_length);
+
+    data_buffer = g_malloc(data_length);
+    if (!data_buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to allocate data buffer");
+        vips_error(object_class->nickname, "Failed to allocate data buffer");
+        return -1;
+    }
+
+    read_length = vips_source_read(spngload->source, data_buffer, data_length);
+    if (read_length < 0 || (size_t)read_length != data_length) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to read source data: read %ld bytes, expected %zu",
+              read_length, data_length);
+        vips_error(object_class->nickname, "Failed to read source data");
+        g_free(data_buffer);
+        return -1;
+    }
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Read %ld bytes from source", read_length);
+
+    ctx = spng_ctx_new(0);
+    if (!ctx) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create spng_ctx");
+        vips_error(object_class->nickname, "Failed to create spng context");
+        g_free(data_buffer);
+        return -1;
+    }
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Created spng_ctx=%p", ctx);
+
+    int err = spng_set_png_buffer(ctx, data_buffer, data_length);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set PNG buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+
+    struct spng_ihdr ihdr;
+    err = spng_get_ihdr(ctx, &ihdr);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to get IHDR: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: IHDR: width=%u, height=%u, bit_depth=%u, color_type=%u",
+          ihdr.width, ihdr.height, ihdr.bit_depth, ihdr.color_type);
+
+    if (ihdr.width != load->out->Xsize || ihdr.height != load->out->Ysize) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Header mismatch: IHDR width=%u, height=%u; VipsImage width=%d, height=%d",
+              ihdr.width, ihdr.height, load->out->Xsize, load->out->Ysize);
+        vips_error(object_class->nickname, "Image header mismatch");
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+
+    out_size = ihdr.width * ihdr.height * load->out->Bands * (ihdr.bit_depth / 8);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Allocating output buffer, size=%zu", out_size);
+
+    out_buffer = g_malloc(out_size);
+    if (!out_buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to allocate output buffer");
+        vips_error(object_class->nickname, "Failed to allocate output buffer");
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+
+    err = spng_decode_image(ctx, out_buffer, out_size, SPNG_FMT_RGBA8, 0);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to decode image: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "Failed to decode image: %s", spng_strerror(err));
+        g_free(out_buffer);
+        spng_ctx_free(ctx);
+        g_free(data_buffer);
+        return -1;
+    }
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Image decoded successfully");
+
+    for (int y = 0; y < ihdr.height; y++) {
+        guchar *q = VIPS_IMAGE_ADDR(load->out, 0, y);
+        memcpy(q, out_buffer + y * ihdr.width * load->out->Bands, ihdr.width * load->out->Bands);
+    }
+
+    g_free(out_buffer);
+    spng_ctx_free(ctx);
+    g_free(data_buffer);
+    return 0;
+}
+
+static void
+vips_foreign_load_spng_class_init(VipsForeignLoadSpngClass *class)
+{
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignLoadClass *foreign_class = VIPS_FOREIGN_LOAD_CLASS(class);
+
+    if (spng_class_initialized) {
+        g_log("vips", G_LOG_LEVEL_WARNING, "spngload: VipsForeignLoadSpngClass already initialized");
+        return;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Initializing VipsForeignLoadSpngClass, class=%p, type=%lu, type_name=%s",
+          class, (gulong)G_OBJECT_CLASS_TYPE(class), g_type_name(G_OBJECT_CLASS_TYPE(class)));
+
+    if (!g_type_is_a(G_OBJECT_CLASS_TYPE(class), VIPS_TYPE_FOREIGN_LOAD)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: VipsForeignLoadSpngClass is not a subclass of VIPS_TYPE_FOREIGN_LOAD");
+        vips_error("spngload", "Class type invalid");
+        return;
+    }
+
+    gobject_class->dispose = vips_foreign_load_spng_dispose;
+    gobject_class->set_property = vips_foreign_load_spng_set_property;
+    gobject_class->get_property = vips_foreign_load_spng_get_property;
+
+    object_class->nickname = "spngload";
+    object_class->description = "load PNG with libspng (file-based)";
+    object_class->build = vips_foreign_load_spng_build;
+
+    foreign_class->header = vips_foreign_load_spng_header;
+    foreign_class->load = vips_foreign_load_spng_file;
+    foreign_class->get_flags_filename = vips_foreign_load_spng_get_flags_filename;
+    foreign_class->get_flags = vips_foreign_load_spng_get_flags;
+    foreign_class->is_a = vips_foreign_load_spng_is_a;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Setting foreign_class->header=%p, load=%p, is_a=%p",
+          (void *)foreign_class->header, (void *)foreign_class->load, (void *)foreign_class->is_a);
+
+    g_object_class_install_property(gobject_class, PROP_SOURCE,
+        g_param_spec_object("source", "Input source", "Source to load from",
+            VIPS_TYPE_SOURCE, G_PARAM_READWRITE | VIPS_ARGUMENT_CONSTRUCT));
+    g_object_class_install_property(gobject_class, PROP_FILENAME,
+        g_param_spec_string("filename", "Input filename", "Filename to load from",
+            NULL, G_PARAM_READWRITE | VIPS_ARGUMENT_CONSTRUCT));
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Source property registered with ID=%u", PROP_SOURCE);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Filename property registered with ID=%u", PROP_FILENAME);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: After setting: foreign_class->header=%p, load=%p, is_a=%p",
+          (void *)foreign_class->header, (void *)foreign_class->load, (void *)foreign_class->is_a);
+
+    if (!foreign_class->header || !foreign_class->load || !foreign_class->is_a) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set header=%p, load=%p, or is_a=%p in VipsForeignLoadSpngClass",
+              (void *)foreign_class->header, (void *)foreign_class->load, (void *)foreign_class->is_a);
+        vips_error("spngload", "Class initialization failed");
+        return;
+    }
+
+    // Verify function pointers
+    if (foreign_class->header != vips_foreign_load_spng_header ||
+        foreign_class->load != vips_foreign_load_spng_file ||
+        foreign_class->is_a != vips_foreign_load_spng_is_a) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Function pointer mismatch: header=%p (expected %p), load=%p (expected %p), is_a=%p (expected %p)",
+              (void *)foreign_class->header, (void *)vips_foreign_load_spng_header,
+              (void *)foreign_class->load, (void *)vips_foreign_load_spng_file,
+              (void *)foreign_class->is_a, (void *)vips_foreign_load_spng_is_a);
+        vips_error("spngload", "Function pointer mismatch");
+        return;
+    }
+
+    spng_class_initialized = TRUE;
+}
+
+static void
+vips_foreign_load_spng_init(VipsForeignLoadSpng *load)
+{
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Initializing VipsForeignLoadSpng");
+    load->source = NULL;
+    load->filename = NULL;
 }
 
 static void
-vips_foreign_load_png_class_init(VipsForeignLoadPngClass *class)
+vips_foreign_load_spng_buffer_dispose(GObject *gobject)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->dispose = vips_foreign_load_png_dispose;
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_base";
-	object_class->description = _("load png base class");
-
-	/* We are fast at is_a(), so high priority.
-	 */
-	foreign_class->priority = 200;
-
-	load_class->get_flags_filename =
-		vips_foreign_load_png_get_flags_filename;
-	load_class->get_flags = vips_foreign_load_png_get_flags;
-	load_class->header = vips_foreign_load_png_header;
-	load_class->load = vips_foreign_load_png_load;
-
-#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-	VIPS_ARG_BOOL(class, "unlimited", 23,
-		_("Unlimited"),
-		_("Remove all denial of service limits"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPng, unlimited),
-		FALSE);
-#endif
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Disposing VipsForeignLoadSpngBuffer");
+    G_OBJECT_CLASS(vips_foreign_load_spng_buffer_parent_class)->dispose(gobject);
 }
 
-static void
-vips_foreign_load_png_init(VipsForeignLoadPng *png)
-{
-}
-
-typedef struct _VipsForeignLoadPngSource {
-	VipsForeignLoadPng parent_object;
-
-	/* Load from a source.
-	 */
-	VipsSource *source;
-
-} VipsForeignLoadPngSource;
-
-typedef VipsForeignLoadPngClass VipsForeignLoadPngSourceClass;
-
-G_DEFINE_TYPE(VipsForeignLoadPngSource, vips_foreign_load_png_source,
-	vips_foreign_load_png_get_type());
-
 static int
-vips_foreign_load_png_source_build(VipsObject *object)
+vips_foreign_load_spng_buffer_header(VipsForeignLoad *load)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngSource *source = (VipsForeignLoadPngSource *) object;
+    VipsForeignLoadSpngBuffer *buffer = (VipsForeignLoadSpngBuffer *) load;
+    VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS(load);
+    spng_ctx *ctx = NULL;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Processing header for buffer, size=%zu", buffer->len);
+
+    if (!buffer->buf || buffer->len == 0) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: No buffer provided");
+        vips_error(object_class->nickname, "No buffer provided");
+        return -1;
+    }
+
+    ctx = spng_ctx_new(0);
+    if (!ctx) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create spng_ctx");
+        vips_error(object_class->nickname, "Failed to create spng context");
+        return -1;
+    }
+
+    int err = spng_set_png_buffer(ctx, buffer->buf, buffer->len);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set PNG buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    struct spng_ihdr ihdr;
+    err = spng_get_ihdr(ctx, &ihdr);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to get IHDR: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    load->out = vips_image_new();
+    if (!load->out) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create new VipsImage");
+        vips_error(object_class->nickname, "Failed to create new VipsImage");
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    vips_image_init_fields(load->out,
+        ihdr.width, ihdr.height,
+        ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR ? 3 : 4,
+        VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0);
+
+    if (vips_image_pipelinev(load->out, VIPS_DEMAND_STYLE_THINSTRIP, NULL)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set up image pipeline");
+        vips_error(object_class->nickname, "Failed to set up image pipeline");
+        g_object_unref(load->out);
+        load->out = NULL;
+        spng_ctx_free(ctx);
+        return -1;
+    }
 
-	if (source->source) {
-		png->source = source->source;
-		g_object_ref(png->source);
-	}
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_source_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
+    spng_ctx_free(ctx);
+    return 0;
 }
 
-static gboolean
-vips_foreign_load_png_source_is_a_source(VipsSource *source)
-{
-	static unsigned char signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
-
-	const unsigned char *p;
-
-	if ((p = vips_source_sniff(source, 8)) &&
-		memcmp(p, signature, 8) == 0)
-		return TRUE;
-
-	return FALSE;
-}
-
-static void
-vips_foreign_load_png_source_class_init(VipsForeignLoadPngSourceClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS(class);
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_source";
-	object_class->description = _("load png from source");
-	object_class->build = vips_foreign_load_png_source_build;
-
-	operation_class->flags |= VIPS_OPERATION_NOCACHE;
-
-	load_class->is_a_source = vips_foreign_load_png_source_is_a_source;
-
-	VIPS_ARG_OBJECT(class, "source", 1,
-		_("Source"),
-		_("Source to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngSource, source),
-		VIPS_TYPE_SOURCE);
-}
-
-static void
-vips_foreign_load_png_source_init(VipsForeignLoadPngSource *source)
-{
-}
-
-typedef struct _VipsForeignLoadPngFile {
-	VipsForeignLoadPng parent_object;
-
-	/* Filename for load.
-	 */
-	char *filename;
-
-} VipsForeignLoadPngFile;
-
-typedef VipsForeignLoadPngClass VipsForeignLoadPngFileClass;
-
-G_DEFINE_TYPE(VipsForeignLoadPngFile, vips_foreign_load_png_file,
-	vips_foreign_load_png_get_type());
-
 static int
-vips_foreign_load_png_file_build(VipsObject *object)
-{
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngFile *file = (VipsForeignLoadPngFile *) object;
-
-	if (file->filename &&
-		!(png->source = vips_source_new_from_file(file->filename)))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_file_parent_class)->build(object))
-		return -1;
-
-	return 0;
-}
-
-static gboolean
-vips_foreign_load_png_file_is_a(const char *filename)
-{
-	VipsSource *source;
-	gboolean result;
-
-	if (!(source = vips_source_new_from_file(filename)))
-		return FALSE;
-	result = vips_foreign_load_png_source_is_a_source(source);
-	VIPS_UNREF(source);
-
-	return result;
-}
-
-const char *vips_foreign_load_png_file_suffs[] = { ".png", NULL };
-
-static void
-vips_foreign_load_png_file_class_init(VipsForeignLoadPngFileClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload";
-	object_class->description = _("load png from file");
-	object_class->build = vips_foreign_load_png_file_build;
-
-	foreign_class->suffs = vips_foreign_load_png_file_suffs;
-
-	load_class->is_a = vips_foreign_load_png_file_is_a;
-
-	VIPS_ARG_STRING(class, "filename", 1,
-		_("Filename"),
-		_("Filename to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngFile, filename),
-		NULL);
-}
-
-static void
-vips_foreign_load_png_file_init(VipsForeignLoadPngFile *file)
+vips_foreign_load_spng_buffer_load(VipsForeignLoad *load)
 {
+    VipsForeignLoadSpngBuffer *buffer = (VipsForeignLoadSpngBuffer *) load;
+    VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS(load);
+    spng_ctx *ctx = NULL;
+    unsigned char *out_buffer = NULL;
+    size_t out_size;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Loading buffer, size=%zu", buffer->len);
+
+    if (!buffer->buf || buffer->len == 0) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: No buffer provided");
+        vips_error(object_class->nickname, "No buffer provided");
+        return -1;
+    }
+
+    ctx = spng_ctx_new(0);
+    if (!ctx) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create spng_ctx");
+        vips_error(object_class->nickname, "Failed to create spng context");
+        return -1;
+    }
+
+    int err = spng_set_png_buffer(ctx, buffer->buf, buffer->len);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set PNG buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    struct spng_ihdr ihdr;
+    err = spng_get_ihdr(ctx, &ihdr);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to get IHDR: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    if (ihdr.width != load->out->Xsize || ihdr.height != load->out->Ysize) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Header mismatch: IHDR width=%u, height=%u; VipsImage width=%d, height=%d",
+              ihdr.width, ihdr.height, load->out->Xsize, load->out->Ysize);
+        vips_error(object_class->nickname, "Image header mismatch");
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    out_size = ihdr.width * ihdr.height * load->out->Bands * (ihdr.bit_depth / 8);
+    out_buffer = g_malloc(out_size);
+    if (!out_buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to allocate output buffer");
+        vips_error(object_class->nickname, "Failed to allocate output buffer");
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    err = spng_decode_image(ctx, out_buffer, out_size, SPNG_FMT_RGBA8, 0);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to decode image: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "Failed to decode image: %s", spng_strerror(err));
+        g_free(out_buffer);
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    for (int y = 0; y < ihdr.height; y++) {
+        guchar *q = VIPS_IMAGE_ADDR(load->out, 0, y);
+        memcpy(q, out_buffer + y * ihdr.width * load->out->Bands, ihdr.width * load->out->Bands);
+    }
+
+    g_free(out_buffer);
+    spng_ctx_free(ctx);
+    return 0;
 }
 
-typedef struct _VipsForeignLoadPngBuffer {
-	VipsForeignLoadPng parent_object;
-
-	/* Load from a buffer.
-	 */
-	VipsBlob *blob;
-
-} VipsForeignLoadPngBuffer;
-
-typedef VipsForeignLoadPngClass VipsForeignLoadPngBufferClass;
-
-G_DEFINE_TYPE(VipsForeignLoadPngBuffer, vips_foreign_load_png_buffer,
-	vips_foreign_load_png_get_type());
-
 static int
-vips_foreign_load_png_buffer_build(VipsObject *object)
+vips_foreign_load_spng_buffer_build(VipsObject *object)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngBuffer *buffer = (VipsForeignLoadPngBuffer *) object;
-
-	if (buffer->blob &&
-		!(png->source = vips_source_new_from_memory(
-			  VIPS_AREA(buffer->blob)->data,
-			  VIPS_AREA(buffer->blob)->length)))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_buffer_parent_class)
-			->build(object))
-		return -1;
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Building VipsForeignLoadSpngBuffer");
 
-	return 0;
-}
-
-static gboolean
-vips_foreign_load_png_buffer_is_a_buffer(const void *buf, size_t len)
-{
-	VipsSource *source;
-	gboolean result;
-
-	if (!(source = vips_source_new_from_memory(buf, len)))
-		return FALSE;
-	result = vips_foreign_load_png_source_is_a_source(source);
-	VIPS_UNREF(source);
-
-	return result;
-}
-
-static void
-vips_foreign_load_png_buffer_class_init(VipsForeignLoadPngBufferClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_buffer";
-	object_class->description = _("load png from buffer");
-	object_class->build = vips_foreign_load_png_buffer_build;
-
-	load_class->is_a_buffer = vips_foreign_load_png_buffer_is_a_buffer;
-
-	VIPS_ARG_BOXED(class, "buffer", 1,
-		_("Buffer"),
-		_("Buffer to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngBuffer, blob),
-		VIPS_TYPE_BLOB);
-}
-
-static void
-vips_foreign_load_png_buffer_init(VipsForeignLoadPngBuffer *buffer)
-{
+    if (VIPS_OBJECT_CLASS(vips_foreign_load_spng_buffer_parent_class)->build(object)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Parent build failed: %s", vips_error_buffer());
+        return -1;
+    }
+
+    return 0;
+}
+
+static void
+vips_foreign_load_spng_buffer_class_init(VipsForeignLoadSpngBufferClass *class)
+{
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignLoadClass *foreign_class = VIPS_FOREIGN_LOAD_CLASS(class);
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Initializing VipsForeignLoadSpngBufferClass, class=%p, type=%lu, type_name=%s",
+          class, (gulong)G_OBJECT_CLASS_TYPE(class), g_type_name(G_OBJECT_CLASS_TYPE(class)));
+
+    if (!g_type_is_a(G_OBJECT_CLASS_TYPE(class), VIPS_TYPE_FOREIGN_LOAD)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: VipsForeignLoadSpngBufferClass is not a subclass of VIPS_TYPE_FOREIGN_LOAD");
+        vips_error("spngload_buffer", "Class type invalid");
+        return;
+    }
+
+    gobject_class->dispose = vips_foreign_load_spng_buffer_dispose;
+
+    object_class->nickname = "spngload_buffer";
+    object_class->description = "load PNG with libspng (buffer-based)";
+    object_class->build = vips_foreign_load_spng_buffer_build;
+
+    foreign_class->header = vips_foreign_load_spng_buffer_header;
+    foreign_class->load = vips_foreign_load_spng_buffer_load;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Setting foreign_class->header=%p, load=%p",
+          (void *)foreign_class->header, (void *)foreign_class->load);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: After setting: foreign_class->header=%p, load=%p",
+          (void *)foreign_class->header, (void *)foreign_class->load);
+
+    if (!foreign_class->header || !foreign_class->load) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to set header=%p or load=%p in VipsForeignLoadSpngBufferClass",
+              (void *)foreign_class->header, (void *)foreign_class->load);
+        vips_error("spngload_buffer", "Class initialization failed");
+        return;
+    }
+
+    // Verify function pointers
+    if (foreign_class->header != vips_foreign_load_spng_buffer_header ||
+        foreign_class->load != vips_foreign_load_spng_buffer_load) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Function pointer mismatch: header=%p (expected %p), load=%p (expected %p)",
+              (void *)foreign_class->header, (void *)vips_foreign_load_spng_buffer_header,
+              (void *)foreign_class->load, (void *)vips_foreign_load_spng_buffer_load);
+        vips_error("spngload_buffer", "Function pointer mismatch");
+        return;
+    }
+}
+
+static void
+vips_foreign_load_spng_buffer_init(VipsForeignLoadSpngBuffer *buffer)
+{
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Initializing VipsForeignLoadSpngBuffer");
+    buffer->buf = NULL;
+    buffer->len = 0;
+}
+
+VIPS_API
+int
+vips_spngload(const char *filename, VipsImage **out, ...)
+{
+    VipsForeignLoad *load;
+    int result;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Starting vips_spngload for %s, VIPS_TYPE_FOREIGN_LOAD_SPNG=%lu, type_name=%s",
+          filename, (gulong)VIPS_TYPE_FOREIGN_LOAD_SPNG, g_type_name(VIPS_TYPE_FOREIGN_LOAD_SPNG));
+
+    // Ensure GType system is initialized
+//    g_type_init();
+
+    if (!g_type_is_a(VIPS_TYPE_FOREIGN_LOAD_SPNG, VIPS_TYPE_FOREIGN_LOAD)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: VIPS_TYPE_FOREIGN_LOAD_SPNG (%lu) is not valid, type_name=%s",
+              (gulong)VIPS_TYPE_FOREIGN_LOAD_SPNG, g_type_name(VIPS_TYPE_FOREIGN_LOAD_SPNG));
+        vips_error("spngload", "Invalid VIPS_TYPE_FOREIGN_LOAD_SPNG");
+        return -1;
+    }
+
+    if (!vips_foreign_load_spng_is_a(filename)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: File %s is not a valid PNG", filename);
+        vips_error("spngload", "Not a valid PNG file: %s", filename);
+        return -1;
+    }
+
+    load = VIPS_FOREIGN_LOAD(g_object_new(VIPS_TYPE_FOREIGN_LOAD_SPNG, "filename", filename, NULL));
+    if (!load) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create VipsForeignLoadSpng object, load=NULL");
+        vips_error("spngload", "Failed to create VipsForeignLoadSpng object");
+        return -1;
+    }
+
+    GType load_type = G_OBJECT_TYPE(load);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Created VipsForeignLoadSpng object at %p (type=%lu, type_name=%s, is_spng=%d)",
+          load, (gulong)load_type, load_type ? g_type_name(load_type) : "invalid", g_type_check_instance_is_a((GTypeInstance *)load, VIPS_TYPE_FOREIGN_LOAD_SPNG));
+
+    if (!load_type || !g_type_check_instance_is_a((GTypeInstance *)load, VIPS_TYPE_FOREIGN_LOAD_SPNG)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Object is not VipsForeignLoadSpng, type=%lu, type_name=%s",
+              (gulong)load_type, load_type ? g_type_name(load_type) : "invalid");
+        vips_error("spngload", "Object is not VipsForeignLoadSpng");
+        VIPS_UNREF(load);
+        return -1;
+    }
+
+    result = vips_object_build(VIPS_OBJECT(load));
+    if (result) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to build VipsForeignLoadSpng: %s", vips_error_buffer());
+        VIPS_UNREF(load);
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: VipsForeignLoadSpng built successfully, out=%p", load->out);
+
+    *out = load->out;
+    g_object_ref(*out);
+    VIPS_UNREF(load);
+    return 0;
+}
+
+VIPS_API
+int
+vips_spngload_buffer(void *buf, size_t len, VipsImage **out, ...)
+{
+    VipsForeignLoad *load;
+    VipsForeignLoadSpngBuffer *buffer;
+    int result;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Starting vips_spngload_buffer, VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER=%lu, type_name=%s",
+          (gulong)VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER, g_type_name(VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER));
+
+    // Ensure GType system is initialized
+//    g_type_init();
+
+    if (!g_type_is_a(VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER, VIPS_TYPE_FOREIGN_LOAD)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER (%lu) is not valid, type_name=%s",
+              (gulong)VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER, g_type_name(VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER));
+        vips_error("spngload_buffer", "Invalid VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER");
+        return -1;
+    }
+
+    load = VIPS_FOREIGN_LOAD(g_object_new(VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER, NULL));
+    if (!load) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to create VipsForeignLoadSpngBuffer object, load=NULL");
+        vips_error("spngload_buffer", "Failed to create VipsForeignLoadSpngBuffer object");
+        return -1;
+    }
+
+    buffer = (VipsForeignLoadSpngBuffer *) load;
+    buffer->buf = buf;
+    buffer->len = len;
+
+    GType load_type = G_OBJECT_TYPE(load);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: Created VipsForeignLoadSpngBuffer object at %p (type=%lu, type_name=%s, is_spng_buffer=%d)",
+          load, (gulong)load_type, load_type ? g_type_name(load_type) : "invalid", g_type_check_instance_is_a((GTypeInstance *)load, VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER));
+
+    if (!load_type || !g_type_check_instance_is_a((GTypeInstance *)load, VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Object is not VipsForeignLoadSpngBuffer, type=%lu, type_name=%s",
+              (gulong)load_type, load_type ? g_type_name(load_type) : "invalid");
+        vips_error("spngload_buffer", "Object is not VipsForeignLoadSpngBuffer");
+        VIPS_UNREF(load);
+        return -1;
+    }
+
+    result = vips_object_build(VIPS_OBJECT(load));
+    if (result) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngload: Failed to build VipsForeignLoadSpngBuffer: %s", vips_error_buffer());
+        VIPS_UNREF(load);
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngload: VipsForeignLoadSpngBuffer built successfully, out=%p", load->out);
+
+    *out = load->out;
+    g_object_ref(*out);
+    VIPS_UNREF(load);
+    return 0;
 }
 
 #endif /*HAVE_SPNG*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngload.h vips-8.16.1/libvips/foreign/spngload.h
--- vips-8.16.1.orig/libvips/foreign/spngload.h	1969-12-31 16:00:00.000000000 -0800
+++ vips-8.16.1/libvips/foreign/spngload.h	2025-07-19 19:16:37.347814118 -0700
@@ -0,0 +1,33 @@
+#ifndef VIPS_SPNGLOAD_H
+#define VIPS_SPNGLOAD_H
+
+#include <vips/vips.h>
+
+#define VIPS_TYPE_FOREIGN_LOAD_SPNG (vips_foreign_load_spng_get_type())
+#define VIPS_FOREIGN_LOAD_SPNG(obj) \
+    (G_TYPE_CHECK_INSTANCE_CAST((obj), VIPS_TYPE_FOREIGN_LOAD_SPNG, VipsForeignLoadSpng))
+#define VIPS_FOREIGN_LOAD_SPNG_CLASS(klass) \
+    (G_TYPE_CHECK_CLASS_CAST((klass), VIPS_TYPE_FOREIGN_LOAD_SPNG, VipsForeignLoadSpngClass))
+#define VIPS_IS_FOREIGN_LOAD_SPNG(obj) \
+    (G_TYPE_CHECK_INSTANCE_TYPE((obj), VIPS_TYPE_FOREIGN_LOAD_SPNG))
+
+#define VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER (vips_foreign_load_spng_buffer_get_type())
+#define VIPS_FOREIGN_LOAD_SPNG_BUFFER(obj) \
+    (G_TYPE_CHECK_INSTANCE_CAST((obj), VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER, VipsForeignLoadSpngBuffer))
+#define VIPS_FOREIGN_LOAD_SPNG_BUFFER_CLASS(klass) \
+    (G_TYPE_CHECK_CLASS_CAST((klass), VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER, VipsForeignLoadSpngBufferClass))
+#define VIPS_IS_FOREIGN_LOAD_SPNG_BUFFER(obj) \
+    (G_TYPE_CHECK_INSTANCE_TYPE((obj), VIPS_TYPE_FOREIGN_LOAD_SPNG_BUFFER))
+
+GType vips_foreign_load_spng_get_type(void);
+GType vips_foreign_load_spng_buffer_get_type(void);
+
+int vips_spngload(const char *filename, VipsImage **out, ...);
+int vips_spngload_buffer(void *buf, size_t len, VipsImage **out, ...);
+
+
+
+
+
+
+#endif /*VIPS_SPNGLOAD_H*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngsave.c vips-8.16.1/libvips/foreign/spngsave.c
--- vips-8.16.1.orig/libvips/foreign/spngsave.c	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/spngsave.c	2025-07-19 19:21:50.837071489 -0700
@@ -14,6 +14,21 @@
  * 	- default filter to none
  * 17/11/22
  * 	- add exif save
+ * 7/11/25 oteodoro
+ *      - Replaced with Grok 3 implementation to avoid symbol collision.
+ * 7/16/25 grok
+ *      - Added set_property and get_property for dynamic filename property handling.
+ *      - Added robust cleanup and VIPS_ARGUMENT_CONSTRUCT for filename property.
+ *      - Set finalize to NULL to prevent parent class issues.
+ *      - Enhanced debug logging for troubleshooting.
+ * 7/16/25 grok
+ *      - Initial implementation for file-based PNG saving.
+ *      - Uses dynamic property handling for filename.
+ *      - Includes robust cleanup and debug logging.
+ * 7/17/25 grok
+ *      - Removed spng_encoded_image_size usage, using conservative buffer size estimation.
+ *      - Fixed linker errors by ensuring proper build method implementation.
+ *      - Ensured RGB/RGBA 8-bit support for sharp-libvips.
  */
 
 /*
@@ -51,881 +66,788 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
-#include <glib/gi18n-lib.h>
 
+#include <vips/vips.h>
+#include <vips/debug.h>
+#include <vips/foreign.h>
+#include <glib.h>
 #include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
+#include <errno.h>
 
-#include <vips/vips.h>
-#include <vips/internal.h>
-
-#include "pforeign.h"
-#include "quantise.h"
 
 #ifdef HAVE_SPNG
 
 #include <spng.h>
+#include "spngsave.h"
 
-typedef struct _VipsForeignSaveSpng {
-	VipsForeignSave parent_object;
-
-	int compression;
-	gboolean interlace;
-	VipsForeignPngFilter filter;
-	gboolean palette;
-	int Q;
-	double dither;
-	int bitdepth;
-	int effort;
-
-	/* Set by subclasses.
-	 */
-	VipsTarget *target;
-
-	/* Write state.
-	 */
-	spng_ctx *ctx;
-	GSList *text_chunks;
-	VipsImage *memory;
-	size_t sizeof_line;
-	VipsPel *line;
-
-	/* Deprecated.
-	 */
-	int colours;
-
-} VipsForeignSaveSpng;
-
-typedef VipsForeignSaveClass VipsForeignSaveSpngClass;
-
-G_DEFINE_ABSTRACT_TYPE(VipsForeignSaveSpng, vips_foreign_save_spng,
-	VIPS_TYPE_FOREIGN_SAVE);
-
-static void
-vips_foreign_save_spng_dispose(GObject *gobject)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) gobject;
-
-	GSList *p;
-
-	VIPS_UNREF(spng->target);
-	VIPS_UNREF(spng->memory);
-	VIPS_FREEF(spng_ctx_free, spng->ctx);
-
-	for (p = spng->text_chunks; p; p = p->next) {
-		struct spng_text *text = (struct spng_text *) p->data;
 
-		VIPS_FREE(text->text);
-		VIPS_FREE(text);
-	}
-	VIPS_FREEF(g_slist_free, spng->text_chunks);
-
-	VIPS_FREE(spng->line);
-
-	G_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->dispose(gobject);
-}
-
-static int
-vips_foreign_save_spng_text(VipsForeignSaveSpng *spng,
-	const char *keyword, const char *value)
-{
-	struct spng_text *text = VIPS_NEW(NULL, struct spng_text);
-
-	g_strlcpy(text->keyword, keyword, sizeof(text->keyword));
-	/* FIXME ... is this right?
-	 */
-	text->type = SPNG_TEXT;
-	text->length = strlen(value);
-	text->text = g_strdup(value);
-
-	spng->text_chunks = g_slist_prepend(spng->text_chunks, text);
-
-	return 0;
-}
+/* Property IDs */
+enum {
+    PROP_FILENAME = 1,
+    PROP_IN,
+    PROP_BUFFER,
+    PROP_LAST
+};
 
-static void *
-vips_foreign_save_spng_comment(VipsImage *image,
-	const char *field, GValue *value, void *user_data)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user_data;
 
-	if (vips_isprefix("png-comment-", field)) {
-		const char *value;
-		int i;
-		char key[256];
+G_DEFINE_TYPE(VipsForeignSaveSpng, vips_foreign_save_spng, VIPS_TYPE_FOREIGN_SAVE);
 
-		if (vips_image_get_string(image, field, &value))
-			return image;
+/* Buffer-based saving */
+typedef struct _VipsForeignSaveSpngBuffer {
+    VipsForeignSave parent_object;
+    VipsImage *in;
+    void **buf;
+    size_t *len;
+} VipsForeignSaveSpngBuffer;
 
-		if (strlen(field) > 256 ||
-			sscanf(field, "png-comment-%d-%80s", &i, key) != 2) {
-			vips_error("vips2png",
-				"%s", _("bad png comment key"));
-			return image;
-		}
+typedef struct _VipsForeignSaveSpngBufferClass {
+    VipsForeignSaveClass parent_class;
+} VipsForeignSaveSpngBufferClass;
 
-		vips_foreign_save_spng_text(spng, key, value);
-	}
+G_DEFINE_TYPE(VipsForeignSaveSpngBuffer, vips_foreign_save_spng_buffer, VIPS_TYPE_FOREIGN_SAVE);
 
-	return NULL;
-}
+static gboolean spngsave_class_initialized = FALSE;
+static gboolean spngsave_buffer_class_initialized = FALSE;
 
-static int
-vips_foreign_save_spng_profile(VipsForeignSaveSpng *spng, VipsImage *in)
+static void
+vips_foreign_save_spng_dispose(GObject *gobject)
 {
-	VipsForeignSave *save = (VipsForeignSave *) spng;
-
-	struct spng_iccp iccp;
-
-	/* A profile supplied as an argument overrides an embedded
-	 * profile.
-	 */
-	if (save->profile) {
-		VipsBlob *blob;
-
-		if (vips_profile_load(save->profile, &blob, NULL))
-			return -1;
-
-		if (blob) {
-			size_t length;
-			const void *data = vips_blob_get(blob, &length);
-			char *basename = g_path_get_basename(save->profile);
-
-#ifdef DEBUG
-			printf("write_vips: attaching %zd bytes of ICC profile\n", length);
-#endif /*DEBUG*/
-
-			g_strlcpy(iccp.profile_name, basename,
-				sizeof(iccp.profile_name));
-			iccp.profile_len = length;
-			iccp.profile = (void *) data;
-			spng_set_iccp(spng->ctx, &iccp);
-
-			vips_area_unref((VipsArea *) blob);
-			g_free(basename);
-		}
-	}
-	else if (vips_image_get_typeof(in, VIPS_META_ICC_NAME)) {
-		const void *data;
-		size_t length;
-
-		if (vips_image_get_blob(in, VIPS_META_ICC_NAME, &data, &length))
-			return -1;
-
-#ifdef DEBUG
-		printf("write_vips: attaching %zd bytes of ICC profile\n",
-			length);
-#endif /*DEBUG*/
-
-		g_strlcpy(iccp.profile_name, "icc", sizeof(iccp.profile_name));
-		iccp.profile_len = length;
-		iccp.profile = (void *) data;
+    VipsForeignSaveSpng *save = (VipsForeignSaveSpng *) gobject;
 
-		spng_set_iccp(spng->ctx, &iccp);
-	}
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Disposing VipsForeignSaveSpng, filename=%s, in=%p (ref_count=%d)",
+          save->filename ? save->filename : "(null)",
+          save->in, save->in ? G_OBJECT(save->in)->ref_count : 0);
 
-	return 0;
-}
-
-static int
-vips_foreign_save_spng_metadata(VipsForeignSaveSpng *spng, VipsImage *in)
-{
-	uint32_t n_text;
-	struct spng_text *text_chunk_array;
-	struct spng_exif exif;
-	int i;
-	GSList *p;
-
-	if (vips_image_get_typeof(in, VIPS_META_XMP_NAME)) {
-		const void *data;
-		size_t length;
-		char *str;
-
-		if (vips_image_get_blob(in, VIPS_META_XMP_NAME, &data, &length))
-			return -1;
-
-		/* The blob form of the XMP metadata is missing the
-		 * terminating \0 bytes, we have to paste it back,
-		 * unfortunately. See pngload.
-		 */
-		str = g_malloc(length + 1);
-		g_strlcpy(str, data, length + 1);
-		vips_foreign_save_spng_text(spng, "XML:com.adobe.xmp", str);
-		g_free(str);
-	}
-
-	if (vips_image_get_typeof(in, VIPS_META_EXIF_NAME)) {
-		if (vips_image_get_blob(in, VIPS_META_EXIF_NAME,
-				(const void **) &exif.data, &exif.length))
-			return -1;
-
-		/* libspng does not want the JFIF "Exif\0\0" prefix.
-		 */
-		if (exif.length >= 6 &&
-			vips_isprefix("Exif", exif.data)) {
-			exif.data += 6;
-			exif.length -= 6;
-		}
-		spng_set_exif(spng->ctx, &exif);
-	}
-
-	if (vips_image_map(in, vips_foreign_save_spng_comment, spng))
-		return -1;
-
-	n_text = g_slist_length(spng->text_chunks);
-	text_chunk_array = VIPS_ARRAY(NULL, n_text, struct spng_text);
-	for (i = 0, p = spng->text_chunks; p; p = p->next, i++) {
-		struct spng_text *text = (struct spng_text *) p->data;
-
-		text_chunk_array[i] = *text;
-	}
-#ifdef DEBUG
-	printf("attaching %u text items\n", n_text);
-#endif /*DEBUG*/
-	spng_set_text(spng->ctx, text_chunk_array, n_text);
-	VIPS_FREE(text_chunk_array);
+    VIPS_UNREF(save->in);
+    VIPS_FREE(save->filename);
 
-	return 0;
+    G_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->dispose(gobject);
 }
 
-/* Pack a line of 1/2/4 bit index values.
- */
 static void
-vips_foreign_save_spng_pack(VipsForeignSaveSpng *spng,
-	VipsPel *q, VipsPel *p, size_t n)
+vips_foreign_save_spng_buffer_dispose(GObject *gobject)
 {
-	int pixel_mask = 8 / spng->bitdepth - 1;
-	int shift = spng->palette ? 0 : 8 - spng->bitdepth;
+    VipsForeignSaveSpngBuffer *save = (VipsForeignSaveSpngBuffer *) gobject;
 
-	VipsPel bits;
-	size_t x;
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Disposing VipsForeignSaveSpngBuffer, in=%p (ref_count=%d)",
+          save->in, save->in ? G_OBJECT(save->in)->ref_count : 0);
 
-	bits = 0;
-	for (x = 0; x < n; x++) {
-		bits <<= spng->bitdepth;
-		bits |= p[x] >> shift;
-
-		if ((x & pixel_mask) == pixel_mask)
-			*q++ = bits;
-	}
-
-	/* Any left-over bits? Need to be left-aligned.
-	 */
-	if ((x & pixel_mask) != 0) {
-		/* The number of bits we've collected and must
-		 * left-align and flush.
-		 */
-		int collected_bits = (x & pixel_mask) << (spng->bitdepth - 1);
+    VIPS_UNREF(save->in);
 
-		*q++ = bits << (8 - collected_bits);
-	}
+    G_OBJECT_CLASS(vips_foreign_save_spng_buffer_parent_class)->dispose(gobject);
 }
 
-static int
-vips_foreign_save_spng_write_fn(spng_ctx *ctx, void *user,
-	void *data, size_t n)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
-
-	if (vips_target_write(spng->target, data, n))
-		return SPNG_IO_ERROR;
-
-	return 0;
-}
-
-static int
-vips_foreign_save_spng_write_block(VipsRegion *region, VipsRect *area,
-	void *user)
+static void
+vips_foreign_save_spng_set_property(GObject *gobject, guint property_id,
+    const GValue *value, GParamSpec *pspec)
 {
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(spng);
-
-	int y;
-	int error;
+    VipsForeignSaveSpng *save = (VipsForeignSaveSpng *) gobject;
 
-	/* The area to write is always a set of complete scanlines.
-	 */
-	g_assert(area->left == 0);
-	g_assert(area->width == region->im->Xsize);
-	g_assert(area->top + area->height <= region->im->Ysize);
-
-	for (y = 0; y < area->height; y++) {
-		VipsPel *line;
-		size_t sizeof_line;
-
-		line = VIPS_REGION_ADDR(region, 0, area->top + y);
-		sizeof_line = VIPS_REGION_SIZEOF_LINE(region);
-
-		if (spng->bitdepth < 8) {
-			vips_foreign_save_spng_pack(spng,
-				spng->line, line, sizeof_line);
-			line = spng->line;
-			sizeof_line = spng->sizeof_line;
-		}
-
-		if ((error = spng_encode_row(spng->ctx, line, sizeof_line)))
-			break;
-	}
-
-	/* You can get SPNG_EOI for the final scanline.
-	 */
-	if (error &&
-		error != SPNG_EOI) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: set_property called with property_id=%u, name=%s",
+          property_id, pspec ? g_param_spec_get_name(pspec) : "(null)");
 
-	return 0;
+    if (!pspec) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: NULL pspec for property_id=%u", property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        return;
+    }
+
+    switch (property_id) {
+    case PROP_FILENAME:
+        {
+            const char *filename = g_value_get_string(value);
+            g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Setting filename property: %s", filename ? filename : "(null)");
+            VIPS_FREE(save->filename);
+            save->filename = g_strdup(filename);
+        }
+        break;
+    case PROP_IN:
+        {
+            GObject *obj = g_value_get_object(value);
+            g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Setting in property");
+            VIPS_UNREF(save->in);
+            if (obj && VIPS_IS_IMAGE(obj)) {
+                save->in = VIPS_IMAGE(g_object_ref(obj));
+                g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Input image set to %p (type=%s, ref_count=%d)",
+                      save->in, G_OBJECT_TYPE_NAME(save->in), G_OBJECT(save->in)->ref_count);
+            } else {
+                save->in = NULL;
+                g_log("vips", G_LOG_LEVEL_WARNING, "spngsave: Input value is %s",
+                      obj ? "not a VipsImage" : "NULL");
+            }
+        }
+        break;
+    default:
+        g_log("vips", G_LOG_LEVEL_WARNING, "spngsave: Unknown property: %s, ID=%u",
+              g_param_spec_get_name(pspec), property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        break;
+    }
 }
 
-static int
-vips_foreign_save_spng_write(VipsForeignSaveSpng *spng, VipsImage *in)
-{
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(spng);
-
-	int error;
-	struct spng_ihdr ihdr;
-	struct spng_phys phys;
-	int fmt;
-	enum spng_encode_flags encode_flags;
-
-	spng->ctx = spng_ctx_new(SPNG_CTX_ENCODER);
-
-	if ((error = spng_set_png_stream(spng->ctx,
-			 vips_foreign_save_spng_write_fn, spng))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	ihdr.width = in->Xsize;
-	ihdr.height = in->Ysize;
-	ihdr.bit_depth = spng->bitdepth;
-
-	switch (in->Bands) {
-	case 1:
-		ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE;
-		break;
-
-	case 2:
-		ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE_ALPHA;
-		break;
-
-	case 3:
-		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR;
-		break;
-
-	case 4:
-		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR_ALPHA;
-		break;
-
-	default:
-		vips_error(class->nickname, "%s", _("bad bands"));
-		return -1;
-	}
-
-#ifdef HAVE_QUANTIZATION
-	/* Enable image quantisation to paletted 8bpp PNG if palette is set.
-	 */
-	if (spng->palette)
-		ihdr.color_type = SPNG_COLOR_TYPE_INDEXED;
-#else
-	if (spng->palette)
-		g_warning("%s",
-			_("ignoring palette (no quantisation support)"));
-#endif /*HAVE_QUANTIZATION*/
-
-	ihdr.compression_method = 0;
-	ihdr.filter_method = 0;
-	ihdr.interlace_method = spng->interlace ? 1 : 0;
-	if ((error = spng_set_ihdr(spng->ctx, &ihdr))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	spng_set_option(spng->ctx,
-		SPNG_IMG_COMPRESSION_LEVEL, spng->compression);
-	spng_set_option(spng->ctx,
-		SPNG_TEXT_COMPRESSION_LEVEL, spng->compression);
-	spng_set_option(spng->ctx,
-		SPNG_FILTER_CHOICE, spng->filter);
-
-	/* Set resolution. spng uses pixels per meter.
-	 */
-	phys.unit_specifier = 1;
-	phys.ppu_x = VIPS_RINT(in->Xres * 1000.0);
-	phys.ppu_y = VIPS_RINT(in->Xres * 1000.0);
-	spng_set_phys(spng->ctx, &phys);
-
-	/* Metadata.
-	 */
-	if (vips_foreign_save_spng_profile(spng, in) ||
-		vips_foreign_save_spng_metadata(spng, in))
-		return -1;
-
-#ifdef HAVE_QUANTIZATION
-	if (spng->palette) {
-		struct spng_plte plte = { 0 };
-		struct spng_trns trns = { 0 };
-
-		VipsImage *im_index;
-		VipsImage *im_palette;
-		int palette_count;
-		int i;
-
-		if (vips__quantise_image(in, &im_index, &im_palette,
-				1 << spng->bitdepth,
-				spng->Q,
-				spng->dither,
-				spng->effort,
-				FALSE))
-			return -1;
-
-		/* PNG is 8-bit index only.
-		 */
-		palette_count = im_palette->Xsize;
-		g_assert(palette_count <= 256);
-
-		for (i = 0; i < palette_count; i++) {
-			VipsPel *p = (VipsPel *)
-				VIPS_IMAGE_ADDR(im_palette, i, 0);
-			struct spng_plte_entry *entry =
-				&plte.entries[plte.n_entries];
-
-			entry->red = p[0];
-			entry->green = p[1];
-			entry->blue = p[2];
-			plte.n_entries += 1;
-
-			trns.type3_alpha[i] = p[3];
-			if (p[3] != 255) {
-				trns.n_type3_entries = i + 1;
-			}
-		}
-
-#ifdef DEBUG
-		printf("attaching %d entry palette\n", plte.n_entries);
-		if (trns.n_type3_entries)
-			printf("attaching %d transparency values\n",
-				trns.n_type3_entries);
-#endif /*DEBUG*/
-
-		VIPS_UNREF(im_palette);
-
-		spng_set_plte(spng->ctx, &plte);
-		if (trns.n_type3_entries)
-			spng_set_trns(spng->ctx, &trns);
-
-		in = spng->memory = im_index;
-	}
-#endif /*HAVE_QUANTIZATION*/
-
-	/* Low-bitdepth write needs an extra buffer for packing pixels.
-	 */
-	if (spng->bitdepth < 8) {
-		spng->sizeof_line =
-			1 + VIPS_IMAGE_SIZEOF_LINE(in) / (8 / spng->bitdepth);
-
-		if (!(spng->line =
-					vips_malloc(NULL, VIPS_IMAGE_SIZEOF_LINE(in))))
-			return -1;
-	}
-
-	/* SPNG_FMT_PNG is a special value that matches the format in ihdr
-	 */
-	fmt = SPNG_FMT_PNG;
-	encode_flags = SPNG_ENCODE_PROGRESSIVE | SPNG_ENCODE_FINALIZE;
-	if ((error = spng_encode_image(spng->ctx,
-			 NULL, -1, fmt, encode_flags))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	if (spng->interlace) {
-		/* Force the input into memory, if it's not there already.
-		 */
-		if (!spng->memory) {
-			if (!(spng->memory = vips_image_copy_memory(in)))
-				return -1;
-			in = spng->memory;
-		}
-
-		do {
-			struct spng_row_info row_info;
-			VipsPel *line;
-			size_t sizeof_line;
-
-			if ((error =
-						spng_get_row_info(spng->ctx, &row_info)))
-				break;
-
-			line = VIPS_IMAGE_ADDR(in, 0, row_info.row_num);
-			sizeof_line = VIPS_IMAGE_SIZEOF_LINE(in);
-
-			if (spng->bitdepth < 8) {
-				vips_foreign_save_spng_pack(spng,
-					spng->line, line, sizeof_line);
-				line = spng->line;
-				sizeof_line = spng->sizeof_line;
-			}
-
-			error = spng_encode_row(spng->ctx, line, sizeof_line);
-		} while (!error);
-
-		if (error != SPNG_EOI) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-	}
-	else {
-		if (vips_sink_disc(in,
-				vips_foreign_save_spng_write_block, spng))
-			return -1;
-	}
-
-	if (vips_target_end(spng->target))
-		return -1;
-
-	return 0;
-}
-
-static int
-vips_foreign_save_spng_build(VipsObject *object)
+static void
+vips_foreign_save_spng_buffer_set_property(GObject *gobject, guint property_id,
+    const GValue *value, GParamSpec *pspec)
 {
-	VipsForeignSave *save = (VipsForeignSave *) object;
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
+    VipsForeignSaveSpngBuffer *save = (VipsForeignSaveSpngBuffer *) gobject;
 
-	VipsImage *in;
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: set_property called for buffer with property_id=%u, name=%s",
+          property_id, pspec ? g_param_spec_get_name(pspec) : "(null)");
 
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->build(object))
-		return -1;
-
-	in = save->ready;
-	g_object_ref(in);
-
-	/* If no output bitdepth has been specified, use input Type to pick.
-	 */
-	if (!vips_object_argument_isset(object, "bitdepth"))
-		spng->bitdepth =
-			in->Type == VIPS_INTERPRETATION_RGB16 ||
-				in->Type == VIPS_INTERPRETATION_GREY16
-			? 16
-			: 8;
-
-	/* Deprecated "colours" arg just sets bitdepth large enough to hold
-	 * that many colours.
-	 */
-	if (vips_object_argument_isset(object, "colours"))
-		spng->bitdepth = ceil(log2(spng->colours));
-
-	/* Cast in down to 8 bit if we can.
-	 */
-	if (spng->bitdepth <= 8) {
-		VipsImage *x;
-
-		if (vips_cast(in, &x, VIPS_FORMAT_UCHAR, NULL)) {
-			g_object_unref(in);
-			return -1;
-		}
-		g_object_unref(in);
-		in = x;
-	}
-
-	/* If this is a RGB or RGBA image and a low bit depth has been
-	 * requested, enable palettisation.
-	 */
-	if (in->Bands > 2 &&
-		spng->bitdepth < 8)
-		spng->palette = TRUE;
-
-	/* Disable palettization for >8 bit save.
-	 */
-	if (spng->bitdepth > 8)
-		spng->palette = FALSE;
-
-	if (vips_foreign_save_spng_write(spng, in)) {
-		g_object_unref(in);
-		return -1;
-	}
-
-	g_object_unref(in);
-
-	return 0;
+    if (!pspec) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: NULL pspec for property_id=%u", property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        return;
+    }
+
+    switch (property_id) {
+    case PROP_IN:
+        {
+            GObject *obj = g_value_get_object(value);
+            g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Setting in property for buffer");
+            VIPS_UNREF(save->in);
+            if (obj && VIPS_IS_IMAGE(obj)) {
+                save->in = VIPS_IMAGE(g_object_ref(obj));
+                g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Input image set to %p (type=%s, ref_count=%d)",
+                      save->in, G_OBJECT_TYPE_NAME(save->in), G_OBJECT(save->in)->ref_count);
+            } else {
+                save->in = NULL;
+                g_log("vips", G_LOG_LEVEL_WARNING, "spngsave: Input value is %s",
+                      obj ? "not a VipsImage" : "NULL");
+            }
+        }
+        break;
+    case PROP_BUFFER:
+        {
+            g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Setting buffer property");
+            save->buf = g_value_get_pointer(value);
+            save->len = g_value_get_pointer(value);
+        }
+        break;
+    default:
+        g_log("vips", G_LOG_LEVEL_WARNING, "spngsave: Unknown property: %s, ID=%u",
+              g_param_spec_get_name(pspec), property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        break;
+    }
 }
 
-#define UC VIPS_FORMAT_UCHAR
-#define US VIPS_FORMAT_USHORT
-
-/* Except for 8-bit inputs, we send everything else to 16. We decide on png8
- * vs. png16 based on Type in_build(), see above.
- */
-static VipsBandFormat bandfmt_spng[10] = {
-	/* Band format:  UC  C   US  S   UI  I   F   X   D   DX */
-	/* Promotion: */ UC, UC, US, US, US, US, US, US, US, US
-};
-
 static void
-vips_foreign_save_spng_class_init(VipsForeignSaveSpngClass *class)
+vips_foreign_save_spng_get_property(GObject *gobject, guint property_id,
+    GValue *value, GParamSpec *pspec)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
-
-	gobject_class->dispose = vips_foreign_save_spng_dispose;
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "spngsave_base";
-	object_class->description = _("save spng");
-	object_class->build = vips_foreign_save_spng_build;
-
-	foreign_class->suffs = vips__png_suffs;
-
-	save_class->saveable = VIPS_SAVEABLE_RGBA;
-	save_class->format_table = bandfmt_spng;
-
-	VIPS_ARG_INT(class, "compression", 6,
-		_("Compression"),
-		_("Compression factor"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, compression),
-		0, 9, 6);
-
-	VIPS_ARG_BOOL(class, "interlace", 7,
-		_("Interlace"),
-		_("Interlace image"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, interlace),
-		FALSE);
-
-	VIPS_ARG_FLAGS(class, "filter", 12,
-		_("Filter"),
-		_("libspng row filter flag(s)"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, filter),
-		VIPS_TYPE_FOREIGN_PNG_FILTER,
-		VIPS_FOREIGN_PNG_FILTER_NONE);
-
-	VIPS_ARG_BOOL(class, "palette", 13,
-		_("Palette"),
-		_("Quantise to 8bpp palette"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, palette),
-		FALSE);
-
-	VIPS_ARG_INT(class, "Q", 15,
-		_("Quality"),
-		_("Quantisation quality"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, Q),
-		0, 100, 100);
-
-	VIPS_ARG_DOUBLE(class, "dither", 16,
-		_("Dithering"),
-		_("Amount of dithering"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, dither),
-		0.0, 1.0, 1.0);
-
-	VIPS_ARG_INT(class, "bitdepth", 17,
-		_("Bit depth"),
-		_("Write as a 1, 2, 4, 8 or 16 bit image"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, bitdepth),
-		1, 16, 8);
-
-	VIPS_ARG_INT(class, "effort", 18,
-		_("Effort"),
-		_("Quantisation CPU effort"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, effort),
-		1, 10, 7);
-
-	VIPS_ARG_INT(class, "colours", 14,
-		_("Colours"),
-		_("Max number of palette colours"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, colours),
-		2, 256, 256);
-}
+    VipsForeignSaveSpng *save = (VipsForeignSaveSpng *) gobject;
 
-static void
-vips_foreign_save_spng_init(VipsForeignSaveSpng *spng)
-{
-	spng->compression = 6;
-	spng->filter = VIPS_FOREIGN_PNG_FILTER_NONE;
-	spng->Q = 100;
-	spng->dither = 1.0;
-	spng->effort = 7;
-}
-
-typedef struct _VipsForeignSaveSpngTarget {
-	VipsForeignSaveSpng parent_object;
-
-	VipsTarget *target;
-} VipsForeignSaveSpngTarget;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngTargetClass;
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: get_property called with property_id=%u, name=%s",
+          property_id, pspec ? g_param_spec_get_name(pspec) : "(null)");
 
-G_DEFINE_TYPE(VipsForeignSaveSpngTarget, vips_foreign_save_spng_target,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_target_build(VipsObject *object)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngTarget *target =
-		(VipsForeignSaveSpngTarget *) object;
-
-	spng->target = target->target;
-	g_object_ref(spng->target);
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_target_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
+    if (!pspec) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: NULL pspec for property_id=%u", property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        return;
+    }
+
+    switch (property_id) {
+    case PROP_FILENAME:
+        g_value_set_string(value, save->filename);
+        break;
+    case PROP_IN:
+        g_value_set_object(value, save->in);
+        break;
+    default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        break;
+    }
 }
 
 static void
-vips_foreign_save_spng_target_class_init(VipsForeignSaveSpngTargetClass *class)
+vips_foreign_save_spng_buffer_get_property(GObject *gobject, guint property_id,
+    GValue *value, GParamSpec *pspec)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
+    VipsForeignSaveSpngBuffer *save = (VipsForeignSaveSpngBuffer *) gobject;
 
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: get_property called for buffer with property_id=%u, name=%s",
+          property_id, pspec ? g_param_spec_get_name(pspec) : "(null)");
 
-	object_class->nickname = "pngsave_target";
-	object_class->description = _("save image to target as PNG");
-	object_class->build = vips_foreign_save_spng_target_build;
-
-	VIPS_ARG_OBJECT(class, "target", 1,
-		_("Target"),
-		_("Target to save to"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngTarget, target),
-		VIPS_TYPE_TARGET);
+    if (!pspec) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: NULL pspec for property_id=%u", property_id);
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        return;
+    }
+
+    switch (property_id) {
+    case PROP_IN:
+        g_value_set_object(value, save->in);
+        break;
+    case PROP_BUFFER:
+        g_value_set_pointer(value, save->buf);
+        break;
+    default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, property_id, pspec);
+        break;
+    }
 }
 
-static void
-vips_foreign_save_spng_target_init(VipsForeignSaveSpngTarget *target)
+static int
+vips_foreign_save_spng_build(VipsObject *object)
 {
+    VipsForeignSaveSpng *save = (VipsForeignSaveSpng *) object;
+    VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS(object);
+    spng_ctx *ctx = NULL;
+    FILE *file = NULL;
+    int err;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Building VipsForeignSaveSpng for filename=%s, in=%p",
+          save->filename ? save->filename : "(null)", save->in);
+
+    if (!save || !VIPS_IS_FOREIGN_SAVE(save)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Invalid VipsForeignSaveSpng object: %p", save);
+        vips_error(object_class->nickname, "Invalid VipsForeignSaveSpng object");
+        return -1;
+    }
+
+    if (!save->in || !VIPS_IS_IMAGE(save->in) || save->in->Xsize <= 0 || save->in->Ysize <= 0) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Invalid input image: in=%p, Xsize=%d, Ysize=%d",
+              save->in, save->in ? save->in->Xsize : -1, save->in ? save->in->Ysize : -1);
+        vips_error(object_class->nickname, "Input image not set or invalid");
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Before parent build, in=%p (type=%s, ref_count=%d, Xsize=%d, Ysize=%d, Bands=%d, BandFmt=%d, Coding=%d)",
+          save->in, save->in ? G_OBJECT_TYPE_NAME(save->in) : "NULL",
+          save->in ? G_OBJECT(save->in)->ref_count : 0,
+          save->in ? save->in->Xsize : -1, save->in ? save->in->Ysize : -1,
+          save->in ? save->in->Bands : -1, save->in ? save->in->BandFmt : -1,
+          save->in ? save->in->Coding : -1);
+
+    if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->build(object)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Parent build failed, in=%p, error=%s",
+              save->in, vips_error_buffer());
+        vips_error(object_class->nickname, "Parent build failed: %s", vips_error_buffer());
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: After parent build, in=%p", save->in);
+
+    if (!save->in || !VIPS_IS_IMAGE(save->in)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Input image not set after parent build");
+        vips_error(object_class->nickname, "Input image not set");
+        return -1;
+    }
+
+    /* Validate and convert image format */
+    VipsImage *converted = NULL;
+    if (save->in->BandFmt != VIPS_FORMAT_UCHAR || (save->in->Bands != 3 && save->in->Bands != 4)) {
+        g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Converting image to sRGB, 8-bit, Bands=%d", save->in->Bands);
+        if (vips_colourspace(save->in, &converted, VIPS_INTERPRETATION_sRGB, NULL)) {
+            g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Colourspace conversion failed: %s", vips_error_buffer());
+            vips_error(object_class->nickname, "Colourspace conversion failed");
+            return -1;
+        }
+        if (vips_cast(converted, &save->in, VIPS_FORMAT_UCHAR, NULL)) {
+            g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Cast to UCHAR failed: %s", vips_error_buffer());
+            vips_error(object_class->nickname, "Cast to UCHAR failed");
+            VIPS_UNREF(converted);
+            return -1;
+        }
+        VIPS_UNREF(converted);
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Image format validated: BandFmt=%d, Bands=%d, Coding=%d, Type=%d",
+          save->in->BandFmt, save->in->Bands, save->in->Coding, save->in->Type);
+
+    /* Rest of the function remains unchanged */
+    file = fopen(save->filename, "wb");
+    if (!file) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to open file %s: %s",
+              save->filename, strerror(errno));
+        vips_error(object_class->nickname, "Failed to open file: %s", save->filename);
+        return -1;
+    }
+
+    ctx = spng_ctx_new(SPNG_CTX_ENCODER);
+    if (!ctx) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to create spng_ctx");
+        vips_error(object_class->nickname, "Failed to create spng context");
+        fclose(file);
+        return -1;
+    }
+
+    err = spng_set_option(ctx, SPNG_ENCODE_TO_BUFFER, 1);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to set encode to buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        fclose(file);
+        return -1;
+    }
+
+    struct spng_ihdr ihdr = {0};
+    ihdr.width = save->in->Xsize;
+    ihdr.height = save->in->Ysize;
+    ihdr.bit_depth = 8;
+    ihdr.color_type = save->in->Bands == 4 ? SPNG_COLOR_TYPE_TRUECOLOR_ALPHA : SPNG_COLOR_TYPE_TRUECOLOR;
+
+    err = spng_set_ihdr(ctx, &ihdr);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to set IHDR: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        fclose(file);
+        return -1;
+    }
+
+    size_t buffer_size = save->in->Xsize * save->in->Ysize * save->in->Bands;
+    unsigned char *buffer = g_malloc(buffer_size);
+    if (!buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to allocate buffer");
+        vips_error(object_class->nickname, "Failed to allocate buffer");
+        spng_ctx_free(ctx);
+        fclose(file);
+        return -1;
+    }
+
+    for (int y = 0; y < save->in->Ysize; y++) {
+        guchar *row = VIPS_IMAGE_ADDR(save->in, 0, y);
+        memcpy(buffer + y * save->in->Xsize * save->in->Bands,
+               row, save->in->Xsize * save->in->Bands);
+    }
+
+    err = spng_encode_image(ctx, buffer, buffer_size,
+                            save->in->Bands == 4 ? SPNG_FMT_PNG : SPNG_FMT_PNG, SPNG_ENCODE_FINALIZE);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to encode image: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "Failed to encode image: %s", spng_strerror(err));
+        g_free(buffer);
+        spng_ctx_free(ctx);
+        fclose(file);
+        return -1;
+    }
+
+    size_t out_size;
+    void *out_buffer = spng_get_png_buffer(ctx, &out_size, &err);
+    if (err != SPNG_OK || !out_buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to get PNG buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "Failed to get PNG buffer: %s", spng_strerror(err));
+        g_free(buffer);
+        spng_ctx_free(ctx);
+        fclose(file);
+        return -1;
+    }
+
+    if (fwrite(out_buffer, 1, out_size, file) != out_size) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to write PNG buffer to file");
+        vips_error(object_class->nickname, "Failed to write PNG buffer to file");
+        g_free(out_buffer);
+        g_free(buffer);
+        spng_ctx_free(ctx);
+        fclose(file);
+        return -1;
+    }
+
+    g_free(out_buffer);
+    g_free(buffer);
+    spng_ctx_free(ctx);
+    fclose(file);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Successfully saved PNG to %s", save->filename);
+    return 0;
 }
 
-typedef struct _VipsForeignSaveSpngFile {
-	VipsForeignSaveSpng parent_object;
-
-	char *filename;
-} VipsForeignSaveSpngFile;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngFileClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngFile, vips_foreign_save_spng_file,
-	vips_foreign_save_spng_get_type());
-
 static int
-vips_foreign_save_spng_file_build(VipsObject *object)
+vips_foreign_save_spng_buffer_build(VipsObject *object)
 {
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngFile *file = (VipsForeignSaveSpngFile *) object;
-
-	if (!(spng->target = vips_target_new_to_file(file->filename)))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_file_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
+    VipsForeignSaveSpngBuffer *save = (VipsForeignSaveSpngBuffer *) object; // Use correct struct
+    VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS(object);
+    spng_ctx *ctx = NULL;
+    int err;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Building VipsForeignSaveSpngBuffer, in=%p",
+          save->in);
+
+    if (!save || !VIPS_IS_FOREIGN_SAVE(save)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Invalid VipsForeignSaveSpngBuffer object: %p", save);
+        vips_error(object_class->nickname, "Invalid VipsForeignSaveSpngBuffer object");
+        return -1;
+    }
+
+    if (!save->in || !VIPS_IS_IMAGE(save->in) || save->in->Xsize <= 0 || save->in->Ysize <= 0) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Invalid input image: in=%p, Xsize=%d, Ysize=%d",
+              save->in, save->in ? save->in->Xsize : -1, save->in ? save->in->Ysize : -1);
+        vips_error(object_class->nickname, "Input image not set or invalid");
+        return -1;
+    }
+
+    if (!save->buf || !save->len) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Buffer or length pointer not set");
+        vips_error(object_class->nickname, "Buffer or length pointer not set");
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Before parent build, in=%p (type=%s, ref_count=%d, Xsize=%d, Ysize=%d, Bands=%d, BandFmt=%d, Coding=%d)",
+          save->in, save->in ? G_OBJECT_TYPE_NAME(save->in) : "NULL",
+          save->in ? G_OBJECT(save->in)->ref_count : 0,
+          save->in ? save->in->Xsize : -1, save->in ? save->in->Ysize : -1,
+          save->in ? save->in->Bands : -1, save->in ? save->in->BandFmt : -1,
+          save->in ? save->in->Coding : -1);
+
+    if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_buffer_parent_class)->build(object)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Parent build failed, in=%p, error=%s",
+              save->in, vips_error_buffer());
+        vips_error(object_class->nickname, "Parent build failed: %s", vips_error_buffer());
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: After parent build, in=%p", save->in);
+
+    if (!save->in || !VIPS_IS_IMAGE(save->in)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Input image not set after parent build");
+        vips_error(object_class->nickname, "Input image not set");
+        return -1;
+    }
+
+    /* Validate and convert image format */
+    VipsImage *converted = NULL;
+    if (save->in->BandFmt != VIPS_FORMAT_UCHAR || (save->in->Bands != 3 && save->in->Bands != 4)) {
+        g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Converting image to sRGB, 8-bit, Bands=%d", save->in->Bands);
+        if (vips_colourspace(save->in, &converted, VIPS_INTERPRETATION_sRGB, NULL)) {
+            g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Colourspace conversion failed: %s", vips_error_buffer());
+            vips_error(object_class->nickname, "Colourspace conversion failed");
+            return -1;
+        }
+        if (vips_cast(converted, &save->in, VIPS_FORMAT_UCHAR, NULL)) {
+            g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Cast to UCHAR failed: %s", vips_error_buffer());
+            vips_error(object_class->nickname, "Cast to UCHAR failed");
+            VIPS_UNREF(converted);
+            return -1;
+        }
+        VIPS_UNREF(converted);
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Image format validated: BandFmt=%d, Bands=%d, Coding=%d, Type=%d",
+          save->in->BandFmt, save->in->Bands, save->in->Coding, save->in->Type);
+
+    ctx = spng_ctx_new(SPNG_CTX_ENCODER);
+    if (!ctx) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to create spng_ctx");
+        vips_error(object_class->nickname, "Failed to create spng context");
+        return -1;
+    }
+
+    err = spng_set_option(ctx, SPNG_ENCODE_TO_BUFFER, 1);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to set encode to buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    struct spng_ihdr ihdr = {0};
+    ihdr.width = save->in->Xsize;
+    ihdr.height = save->in->Ysize;
+    ihdr.bit_depth = 8;
+    ihdr.color_type = save->in->Bands == 4 ? SPNG_COLOR_TYPE_TRUECOLOR_ALPHA : SPNG_COLOR_TYPE_TRUECOLOR;
+
+    err = spng_set_ihdr(ctx, &ihdr);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to set IHDR: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "%s", spng_strerror(err));
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    size_t buffer_size = save->in->Xsize * save->in->Ysize * save->in->Bands;
+    unsigned char *buffer = g_malloc(buffer_size);
+    if (!buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to allocate buffer");
+        vips_error(object_class->nickname, "Failed to allocate buffer");
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    for (int y = 0; y < save->in->Ysize; y++) {
+        guchar *row = VIPS_IMAGE_ADDR(save->in, 0, y);
+        memcpy(buffer + y * save->in->Xsize * save->in->Bands,
+               row, save->in->Xsize * save->in->Bands);
+    }
+
+    err = spng_encode_image(ctx, buffer, buffer_size,
+                            save->in->Bands == 4 ? SPNG_FMT_PNG : SPNG_FMT_PNG, SPNG_ENCODE_FINALIZE);
+    if (err != SPNG_OK) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to encode image: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "Failed to encode image: %s", spng_strerror(err));
+        g_free(buffer);
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    size_t out_size;
+    void *out_buffer = spng_get_png_buffer(ctx, &out_size, &err);
+    if (err != SPNG_OK || !out_buffer) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to get PNG buffer: %s", spng_strerror(err));
+        vips_error(object_class->nickname, "Failed to get PNG buffer: %s", spng_strerror(err));
+        g_free(buffer);
+        spng_ctx_free(ctx);
+        return -1;
+    }
+
+    *save->buf = out_buffer; // Correct struct
+    *save->len = out_size;   // Correct struct
+
+    g_free(buffer);
+    spng_ctx_free(ctx);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Successfully saved PNG to buffer, size=%zu", out_size);
+    return 0;
 }
 
 static void
-vips_foreign_save_spng_file_class_init(VipsForeignSaveSpngFileClass *class)
+vips_foreign_save_spng_class_init(VipsForeignSaveSpngClass *class)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignSaveClass *foreign_class = VIPS_FOREIGN_SAVE_CLASS(class);
+
+    if (spngsave_class_initialized) {
+        g_log("vips", G_LOG_LEVEL_WARNING, "spngsave: VipsForeignSaveSpngClass already initialized");
+        return;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Initializing VipsForeignSaveSpngClass, class=%p, type=%lu, type_name=%s",
+          class, (gulong)G_OBJECT_CLASS_TYPE(class), g_type_name(G_OBJECT_CLASS_TYPE(class)));
+
+    if (!g_type_is_a(G_OBJECT_CLASS_TYPE(class), VIPS_TYPE_FOREIGN_SAVE)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: VipsForeignSaveSpngClass is not a subclass of VIPS_TYPE_FOREIGN_SAVE");
+        vips_error("spngsave", "Class type invalid");
+        return;
+    }
+
+    gobject_class->dispose = vips_foreign_save_spng_dispose;
+    gobject_class->set_property = vips_foreign_save_spng_set_property;
+    gobject_class->get_property = vips_foreign_save_spng_get_property;
+
+    object_class->nickname = "spngsave";
+    object_class->description = "save PNG with libspng";
+    object_class->build = vips_foreign_save_spng_build;
+
+    foreign_class->saveable = VIPS_SAVEABLE_RGBA;
+    static VipsBandFormat format_table[] = {
+        VIPS_FORMAT_UCHAR,
+        VIPS_FORMAT_NOTSET,
+        VIPS_FORMAT_NOTSET,
+        VIPS_FORMAT_NOTSET,
+        VIPS_FORMAT_NOTSET,
+        VIPS_FORMAT_NOTSET,
+        VIPS_FORMAT_NOTSET,
+        VIPS_FORMAT_NOTSET
+    };
+    foreign_class->format_table = format_table;
+
+    g_object_class_install_property(gobject_class, PROP_FILENAME,
+        g_param_spec_string("filename", "Output filename", "Filename to save to",
+            NULL, G_PARAM_READWRITE | VIPS_ARGUMENT_REQUIRED | VIPS_ARGUMENT_CONSTRUCT));
+    g_object_class_install_property(gobject_class, PROP_IN,
+        g_param_spec_object("in", "Input image", "Image to save",
+            VIPS_TYPE_IMAGE, G_PARAM_READWRITE | VIPS_ARGUMENT_REQUIRED | VIPS_ARGUMENT_CONSTRUCT));
 
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Filename property registered with ID=%u", PROP_FILENAME);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Input property registered with ID=%u", PROP_IN);
 
-	object_class->nickname = "pngsave";
-	object_class->description = _("save image to file as PNG");
-	object_class->build = vips_foreign_save_spng_file_build;
-
-	VIPS_ARG_STRING(class, "filename", 1,
-		_("Filename"),
-		_("Filename to save to"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngFile, filename),
-		NULL);
+    spngsave_class_initialized = TRUE;
 }
 
 static void
-vips_foreign_save_spng_file_init(VipsForeignSaveSpngFile *file)
-{
-}
-
-typedef struct _VipsForeignSaveSpngBuffer {
-	VipsForeignSaveSpng parent_object;
-
-	VipsArea *buf;
-} VipsForeignSaveSpngBuffer;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngBufferClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngBuffer, vips_foreign_save_spng_buffer,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_buffer_build(VipsObject *object)
+vips_foreign_save_spng_buffer_class_init(VipsForeignSaveSpngBufferClass *class)
 {
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngBuffer *buffer =
-		(VipsForeignSaveSpngBuffer *) object;
-
-	VipsBlob *blob;
-
-	if (!(spng->target = vips_target_new_to_memory()))
-		return -1;
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
 
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_buffer_parent_class)
-			->build(object))
-		return -1;
+    if (spngsave_buffer_class_initialized) {
+        g_log("vips", G_LOG_LEVEL_WARNING, "spngsave: VipsForeignSaveSpngBufferClass already initialized");
+        return;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Initializing VipsForeignSaveSpngBufferClass, class=%p, type=%lu, type_name=%s",
+          class, (gulong)G_OBJECT_CLASS_TYPE(class), g_type_name(G_OBJECT_CLASS_TYPE(class)));
+
+    if (!g_type_is_a(G_OBJECT_CLASS_TYPE(class), VIPS_TYPE_FOREIGN_SAVE)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: VipsForeignSaveSpngBufferClass is not a subclass of VIPS_TYPE_FOREIGN_SAVE");
+        vips_error("spngsave", "Class type invalid");
+        return;
+    }
+
+    gobject_class->dispose = vips_foreign_save_spng_buffer_dispose;
+    gobject_class->set_property = vips_foreign_save_spng_buffer_set_property;
+    gobject_class->get_property = vips_foreign_save_spng_buffer_get_property;
+
+    object_class->nickname = "spngsave_buffer";
+    object_class->description = "save PNG to buffer with libspng";
+    object_class->build = vips_foreign_save_spng_buffer_build;
+
+    g_object_class_install_property(gobject_class, PROP_IN,
+        g_param_spec_object("in", "Input image", "Image to save",
+            VIPS_TYPE_IMAGE, G_PARAM_READWRITE | VIPS_ARGUMENT_REQUIRED | VIPS_ARGUMENT_CONSTRUCT));
+    g_object_class_install_property(gobject_class, PROP_BUFFER,
+        g_param_spec_pointer("buffer", "Output buffer", "Buffer to save to",
+            G_PARAM_READWRITE | VIPS_ARGUMENT_REQUIRED | VIPS_ARGUMENT_CONSTRUCT));
 
-	g_object_get(spng->target, "blob", &blob, NULL);
-	g_object_set(buffer, "buffer", blob, NULL);
-	vips_area_unref(VIPS_AREA(blob));
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Input property registered with ID=%u", PROP_IN);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Buffer property registered with ID=%u", PROP_BUFFER);
 
-	return 0;
+    spngsave_buffer_class_initialized = TRUE;
 }
 
 static void
-vips_foreign_save_spng_buffer_class_init(VipsForeignSaveSpngBufferClass *class)
+vips_foreign_save_spng_init(VipsForeignSaveSpng *save)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngsave_buffer";
-	object_class->description = _("save image to buffer as PNG");
-	object_class->build = vips_foreign_save_spng_buffer_build;
-
-	VIPS_ARG_BOXED(class, "buffer", 1,
-		_("Buffer"),
-		_("Buffer to save to"),
-		VIPS_ARGUMENT_REQUIRED_OUTPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngBuffer, buf),
-		VIPS_TYPE_BLOB);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Initializing VipsForeignSaveSpng");
+    save->filename = NULL;
+    save->in = NULL;
 }
 
 static void
-vips_foreign_save_spng_buffer_init(VipsForeignSaveSpngBuffer *buffer)
+vips_foreign_save_spng_buffer_init(VipsForeignSaveSpngBuffer *save)
 {
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Initializing VipsForeignSaveSpngBuffer");
+    save->in = NULL;
+    save->buf = NULL;
+    save->len = NULL;
+}
+
+VIPS_API
+int
+vips_spngsave(VipsImage *in, const char *filename, ...)
+{
+    VipsForeignSave *save;
+    int result;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Starting vips_spngsave for %s, in=%p", filename, in);
+
+    if (!in || !VIPS_IS_IMAGE(in)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Invalid or NULL input image: %p", in);
+        vips_error("spngsave", "Invalid or NULL input image");
+        return -1;
+    }
+
+    if (!filename) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Filename is NULL");
+        vips_error("spngsave", "Filename is NULL");
+        return -1;
+    }
+
+    /* Ensure type is registered */
+    if (!g_type_name(VIPS_TYPE_FOREIGN_SAVE_SPNG)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: VIPS_TYPE_FOREIGN_SAVE_SPNG not registered");
+        vips_error("spngsave", "VIPS_TYPE_FOREIGN_SAVE_SPNG not registered");
+        return -1;
+    }
+
+    save = VIPS_FOREIGN_SAVE(g_object_new(VIPS_TYPE_FOREIGN_SAVE_SPNG,
+                                         "in", in,
+                                         "filename", filename,
+                                         NULL));
+    if (!save || !G_IS_OBJECT(save)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to create VipsForeignSaveSpng object, save=%p", save);
+        vips_error("spngsave", "Failed to create VipsForeignSaveSpng object");
+        return -1;
+    }
+
+    GType save_type = G_OBJECT_TYPE(save);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Created VipsForeignSaveSpng object at %p (type=%lu, type_name=%s, is_spng=%d, save->in=%p)",
+          save, (gulong)save_type, save_type ? g_type_name(save_type) : "invalid",
+          g_type_check_instance_is_a((GTypeInstance *)save, VIPS_TYPE_FOREIGN_SAVE_SPNG),
+          ((VipsForeignSaveSpng *)save)->in);
+
+    if (!save_type || !g_type_check_instance_is_a((GTypeInstance *)save, VIPS_TYPE_FOREIGN_SAVE_SPNG)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Object is not VipsForeignSaveSpng, type=%lu, type_name=%s",
+              (gulong)save_type, save_type ? g_type_name(save_type) : "invalid");
+        vips_error("spngsave", "Object is not VipsForeignSaveSpng");
+        VIPS_UNREF(save);
+        return -1;
+    }
+
+    if (!((VipsForeignSaveSpng *)save)->in || !VIPS_IS_IMAGE(((VipsForeignSaveSpng *)save)->in)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: save->in is invalid after creation: %p", ((VipsForeignSaveSpng *)save)->in);
+        vips_error("spngsave", "Invalid input image after object creation");
+        VIPS_UNREF(save);
+        return -1;
+    }
+
+    result = vips_object_build(VIPS_OBJECT(save));
+    if (result) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to build VipsForeignSaveSpng: %s", vips_error_buffer());
+        VIPS_UNREF(save);
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: VipsForeignSaveSpng built successfully");
+    VIPS_UNREF(save);
+    return 0;
+}
+
+VIPS_API
+int
+vips_spngsave_buffer(VipsImage *in, void **buf, size_t *len, ...)
+{
+    VipsForeignSave *save;
+    int result;
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Starting vips_spngsave_buffer, in=%p", in);
+
+    if (!in || !VIPS_IS_IMAGE(in)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Invalid or NULL input image: %p", in);
+        vips_error("spngsave_buffer", "Invalid or NULL input image");
+        return -1;
+    }
+
+    if (!buf || !len) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Buffer or length pointer not set");
+        vips_error("spngsave_buffer", "Buffer or length pointer not set");
+        return -1;
+    }
+
+    /* Ensure type is registered */
+    if (!g_type_name(VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER not registered");
+        vips_error("spngsave_buffer", "VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER not registered");
+        return -1;
+    }
+
+    save = VIPS_FOREIGN_SAVE(g_object_new(VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER,
+                                         "in", in,
+                                         "buffer", buf,
+                                         NULL));
+    if (!save) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to create VipsForeignSaveSpngBuffer object, save=NULL");
+        vips_error("spngsave_buffer", "Failed to create VipsForeignSaveSpngBuffer object");
+        return -1;
+    }
+
+    GType save_type = G_OBJECT_TYPE(save);
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: Created VipsForeignSaveSpngBuffer object at %p (type=%lu, type_name=%s, is_spng_buffer=%d)",
+          save, (gulong)save_type, save_type ? g_type_name(save_type) : "invalid",
+          g_type_check_instance_is_a((GTypeInstance *)save, VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER));
+
+    if (!save_type || !g_type_check_instance_is_a((GTypeInstance *)save, VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER)) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Object is not VipsForeignSaveSpngBuffer, type=%lu, type_name=%s",
+              (gulong)save_type, save_type ? g_type_name(save_type) : "invalid");
+        vips_error("spngsave_buffer", "Object is not VipsForeignSaveSpngBuffer");
+        VIPS_UNREF(save);
+        return -1;
+    }
+
+    ((VipsForeignSaveSpngBuffer *)save)->buf = buf;
+    ((VipsForeignSaveSpngBuffer *)save)->len = len;
+
+    result = vips_object_build(VIPS_OBJECT(save));
+    if (result) {
+        g_log("vips", G_LOG_LEVEL_ERROR, "spngsave: Failed to build VipsForeignSaveSpngBuffer: %s", vips_error_buffer());
+        VIPS_UNREF(save);
+        return -1;
+    }
+
+    g_log("vips", G_LOG_LEVEL_DEBUG, "spngsave: VipsForeignSaveSpngBuffer built successfully, buffer_size=%zu", *len);
+    VIPS_UNREF(save);
+    return 0;
 }
 
 #endif /*HAVE_SPNG*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngsave.h vips-8.16.1/libvips/foreign/spngsave.h
--- vips-8.16.1.orig/libvips/foreign/spngsave.h	1969-12-31 16:00:00.000000000 -0800
+++ vips-8.16.1/libvips/foreign/spngsave.h	2025-07-19 19:21:49.077115608 -0700
@@ -0,0 +1,42 @@
+#ifndef VIPS_SPNGSAVE_H
+#define VIPS_SPNGSAVE_H
+
+#include <vips/vips.h>
+
+
+#define VIPS_TYPE_FOREIGN_SAVE_SPNG (vips_foreign_save_spng_get_type())
+#define VIPS_FOREIGN_SAVE_SPNG(obj) \
+    (G_TYPE_CHECK_INSTANCE_CAST((obj), VIPS_TYPE_FOREIGN_SAVE_SPNG, VipsForeignSaveSpng))
+#define VIPS_FOREIGN_SAVE_SPNG_CLASS(klass) \
+    (G_TYPE_CHECK_CLASS_CAST((klass), VIPS_TYPE_FOREIGN_SAVE_SPNG, VipsForeignSaveSpngClass))
+#define VIPS_IS_FOREIGN_SAVE_SPNG(obj) \
+    (G_TYPE_CHECK_INSTANCE_TYPE((obj), VIPS_TYPE_FOREIGN_SAVE_SPNG))
+
+#define VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER (vips_foreign_save_spng_buffer_get_type())
+#define VIPS_FOREIGN_SAVE_SPNG_BUFFER(obj) \
+    (G_TYPE_CHECK_INSTANCE_CAST((obj), VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER, VipsForeignSaveSpngBuffer))
+#define VIPS_FOREIGN_SAVE_SPNG_BUFFER_CLASS(klass) \
+    (G_TYPE_CHECK_CLASS_CAST((klass), VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER, VipsForeignSaveSpngBufferClass))
+#define VIPS_IS_FOREIGN_SAVE_SPNG_BUFFER(obj) \
+    (G_TYPE_CHECK_INSTANCE_TYPE((obj), VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER))
+
+/* File-based saving */
+typedef struct _VipsForeignSaveSpng {
+    VipsForeignSave parent_object;
+    char *filename;
+    VipsImage *in;
+} VipsForeignSaveSpng;
+
+typedef struct _VipsForeignSaveSpngClass {
+    VipsForeignSaveClass parent_class;
+} VipsForeignSaveSpngClass;
+
+GType vips_foreign_save_spng_get_type(void);
+GType vips_foreign_save_spng_buffer_get_type(void);
+
+VIPS_API
+int vips_spngsave(VipsImage *in, const char *filename, ...);
+VIPS_API
+int vips_spngsave_buffer(VipsImage *in, void **buf, size_t *len, ...);
+
+#endif /*VIPS_SPNGSAVE_H*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/include/vips/vips.h vips-8.16.1/libvips/include/vips/vips.h
--- vips-8.16.1.orig/libvips/include/vips/vips.h	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/include/vips/vips.h	2025-07-19 19:16:37.348814348 -0700
@@ -194,6 +194,10 @@ const char *vips_guess_prefix(const char
 VIPS_API
 const char *vips_guess_libdir(const char *argv0, const char *env_name);
 
+VIPS_API int
+vips_call_by_name(const char *operation_name,
+	const char *option_string, va_list required, va_list optional);
+
 #ifdef __cplusplus
 }
 #endif /*__cplusplus*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/iofuncs/operation.c vips-8.16.1/libvips/iofuncs/operation.c
--- vips-8.16.1.orig/libvips/iofuncs/operation.c	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/iofuncs/operation.c	2025-07-19 19:16:37.349080946 -0700
@@ -989,7 +989,7 @@ vips_call_required_optional(VipsOperatio
 	return result;
 }
 
-static int
+VIPS_API int
 vips_call_by_name(const char *operation_name,
 	const char *option_string, va_list required, va_list optional)
 {
