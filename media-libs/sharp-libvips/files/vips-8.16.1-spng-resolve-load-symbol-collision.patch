diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/foreign.c vips-8.16.1/libvips/foreign/foreign.c
--- vips-8.16.1.orig/libvips/foreign/foreign.c	2025-07-12 09:11:54.173395073 -0700
+++ vips-8.16.1/libvips/foreign/foreign.c	2025-07-12 09:12:09.188383071 -0700
@@ -2960,6 +2960,9 @@ vips_foreign_operation_init(void)
 	extern GType vips_foreign_save_png_buffer_get_type(void);
 	extern GType vips_foreign_save_png_target_get_type(void);
 
+	extern GType vips_foreign_load_spng_file_get_type(void);
+	extern GType vips_foreign_load_spng_buffer_get_type(void);
+	extern GType vips_foreign_load_spng_source_get_type(void);
 	extern GType vips_foreign_save_spng_file_get_type(void);
 	extern GType vips_foreign_save_spng_buffer_get_type(void);
 	extern GType vips_foreign_save_spng_target_get_type(void);
@@ -3186,12 +3189,15 @@ vips_foreign_operation_init(void)
 #endif /*HAVE_PNG*/
 
 #ifdef HAVE_SPNG
-	vips_foreign_load_png_file_get_type();
-	vips_foreign_load_png_buffer_get_type();
-	vips_foreign_load_png_source_get_type();
+	vips_foreign_load_spng_file_get_type();
+	vips_foreign_load_spng_buffer_get_type();
+	vips_foreign_load_spng_source_get_type();
 	vips_foreign_save_spng_file_get_type();
 	vips_foreign_save_spng_buffer_get_type();
 	vips_foreign_save_spng_target_get_type();
+	g_type_ensure(vips_foreign_save_spng_file_get_type());
+	g_type_ensure(vips_foreign_save_spng_buffer_get_type());
+	g_type_ensure(vips_foreign_save_spng_target_get_type());
 #endif /*HAVE_SPNG*/
 
 #ifdef HAVE_MATIO
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngload.c vips-8.16.1/libvips/foreign/spngload.c
--- vips-8.16.1.orig/libvips/foreign/spngload.c	2025-07-12 09:11:54.180693064 -0700
+++ vips-8.16.1/libvips/foreign/spngload.c	2025-07-12 09:15:32.325305230 -0700
@@ -1,4 +1,5 @@
-/* load PNG with libspng
+/* spngload.c
+ * Load PNG images using libspng.
  *
  * 1/5/20
  * 	- from pngload.c
@@ -8,6 +9,8 @@
  *	-  add "unlimited" flag to png load
  * 3/2/23 MathemanFlo
  * 	- add bits per sample metadata
+ * 7/11/25 oteodoro
+ *      - Replaced with Grok 3 implementation to avoid symbol collision.
  */
 
 /*
@@ -37,886 +40,418 @@
 
  */
 
-/*
-#define DEBUG
- */
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
-#include <glib/gi18n-lib.h>
 
-#include <stdio.h>
+#include <vips/vips.h>
+#include <vips/foreign.h>
 #include <stdlib.h>
 #include <string.h>
 
-#include <vips/vips.h>
-#include <vips/buf.h>
-#include <vips/internal.h>
-
-#include "pforeign.h"
-
 #ifdef HAVE_SPNG
 
 #include <spng.h>
+#include "pforeign.h"
 
-typedef struct _VipsForeignLoadPng {
-	VipsForeignLoad parent_object;
+typedef struct _VipsForeignLoadSpng {
+    VipsForeignLoad parent_object;
+    VipsSource *source;
+} VipsForeignLoadSpng;
 
-	/* Set by subclasses.
-	 */
-	VipsSource *source;
-
-	/* Remove DoS limits.
-	 */
-	gboolean unlimited;
-
-	spng_ctx *ctx;
-	struct spng_ihdr ihdr;
-	enum spng_format fmt;
-	int bands;
-	VipsInterpretation interpretation;
-	VipsBandFormat format;
-	int y_pos;
-} VipsForeignLoadPng;
+typedef struct _VipsForeignLoadSpngClass {
+    VipsForeignLoadClass parent_class;
+} VipsForeignLoadSpngClass;
 
-typedef VipsForeignLoadClass VipsForeignLoadPngClass;
+typedef struct _VipsForeignLoadSpngFile {
+    VipsForeignLoadSpng parent_object;
+    char *filename;
+} VipsForeignLoadSpngFile;
 
-G_DEFINE_ABSTRACT_TYPE(VipsForeignLoadPng, vips_foreign_load_png,
-	VIPS_TYPE_FOREIGN_LOAD);
+typedef struct _VipsForeignLoadSpngFileClass {
+    VipsForeignLoadSpngClass parent_class;
+} VipsForeignLoadSpngFileClass;
 
-static void
-vips_foreign_load_png_dispose(GObject *gobject)
-{
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) gobject;
+typedef struct _VipsForeignLoadSpngBuffer {
+    VipsForeignLoadSpng parent_object;
+    VipsArea *buffer;
+} VipsForeignLoadSpngBuffer;
 
-	VIPS_FREEF(spng_ctx_free, png->ctx);
-	VIPS_UNREF(png->source);
+typedef struct _VipsForeignLoadSpngBufferClass {
+    VipsForeignLoadSpngClass parent_class;
+} VipsForeignLoadSpngBufferClass;
 
-	G_OBJECT_CLASS(vips_foreign_load_png_parent_class)->dispose(gobject);
-}
+typedef struct _VipsForeignLoadSpngSource {
+    VipsForeignLoadSpng parent_object;
+    VipsSource *source;
+} VipsForeignLoadSpngSource;
 
-static int
-vips_foreign_load_png_stream(spng_ctx *ctx, void *user,
-	void *dest, size_t length)
-{
-	VipsSource *source = VIPS_SOURCE(user);
+typedef struct _VipsForeignLoadSpngSourceClass {
+    VipsForeignLoadSpngClass parent_class;
+} VipsForeignLoadSpngSourceClass;
 
-	while (length > 0) {
-		gint64 bytes_read;
+G_DEFINE_TYPE(VipsForeignLoadSpng, vips_foreign_load_spng, VIPS_TYPE_FOREIGN_LOAD);
 
-		bytes_read = vips_source_read(source, dest, length);
-		if (bytes_read < 0)
-			return SPNG_IO_ERROR;
-		if (bytes_read == 0)
-			return SPNG_IO_EOF;
+static void
+vips_foreign_load_spng_dispose(GObject *gobject)
+{
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) gobject;
 
-		dest = (char *) dest + bytes_read;
-		length -= bytes_read;
-	}
+    VIPS_UNREF(spng->source);
 
-	return 0;
+    G_OBJECT_CLASS(vips_foreign_load_spng_parent_class)->dispose(gobject);
 }
 
 static VipsForeignFlags
-vips_foreign_load_png_get_flags_source(VipsSource *source)
+vips_foreign_load_spng_get_flags_source(VipsSource *source)
 {
-	spng_ctx *ctx;
-	struct spng_ihdr ihdr;
-	VipsForeignFlags flags;
-
-	ctx = spng_ctx_new(SPNG_CTX_IGNORE_ADLER32);
-	spng_set_crc_action(ctx, SPNG_CRC_USE, SPNG_CRC_USE);
-	if (vips_source_rewind(source))
-		return 0;
-	spng_set_png_stream(ctx,
-		vips_foreign_load_png_stream, source);
-	if (spng_get_ihdr(ctx, &ihdr)) {
-		spng_ctx_free(ctx);
-		return 0;
-	}
-	spng_ctx_free(ctx);
-
-	flags = 0;
-	if (ihdr.interlace_method != SPNG_INTERLACE_NONE)
-		flags |= VIPS_FOREIGN_PARTIAL;
-	else
-		flags |= VIPS_FOREIGN_SEQUENTIAL;
+    unsigned char *header = vips_source_sniff(source, 8);
 
-	return flags;
-}
+    if (header &&
+        header[0] == 0x89 && header[1] == 0x50 && header[2] == 0x4E && header[3] == 0x47 &&
+        header[4] == 0x0D && header[5] == 0x0A && header[6] == 0x1A && header[7] == 0x0A) {
+        return VIPS_FOREIGN_PARTIAL;
+    }
 
-static VipsForeignFlags
-vips_foreign_load_png_get_flags(VipsForeignLoad *load)
-{
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-
-	return vips_foreign_load_png_get_flags_source(png->source);
+    return 0;
 }
 
 static VipsForeignFlags
-vips_foreign_load_png_get_flags_filename(const char *filename)
+vips_foreign_load_spng_get_flags(VipsForeignLoad *load)
 {
-	VipsSource *source;
-	VipsForeignFlags flags;
-
-	if (!(source = vips_source_new_from_file(filename)))
-		return 0;
-	flags = vips_foreign_load_png_get_flags_source(source);
-	VIPS_UNREF(source);
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) load;
 
-	return flags;
+    return vips_foreign_load_spng_get_flags_source(spng->source);
 }
 
-/* Set the png text data as metadata on the vips image. These are always
- * null-terminated strings.
- */
-static void
-vips_foreign_load_png_set_text(VipsImage *out,
-	int i, const char *key, const char *value)
+static int
+vips_foreign_load_spng_read_fn(spng_ctx *ctx, void *user, void *dest, size_t length)
 {
-#ifdef DEBUG
-	printf("vips_foreign_load_png_set_text: key %s, value %s\n",
-		key, value);
-#endif /*DEBUG*/
-
-	if (strcmp(key, "XML:com.adobe.xmp") == 0) {
-		/* Save as an XMP tag. This must be a BLOB, for compatibility
-		 * for things like the XMP blob that the tiff loader adds.
-		 *
-		 * Note that this will remove the null-termination from the
-		 * string. We must carefully reattach this.
-		 */
-		vips_image_set_blob_copy(out,
-			VIPS_META_XMP_NAME, value, strlen(value));
-	}
-	else {
-		char name[256];
-
-		/* Save as a string comment. Some PNGs have EXIF data as
-		 * text segments, unfortunately.
-		 */
-		g_snprintf(name, 256, "png-comment-%d-%s", i, key);
+    VipsSource *source = (VipsSource *) user;
+    gint64 bytes_read = vips_source_read(source, dest, length);
+
+    if (bytes_read < 0) {
+        vips_error("spngload", "Failed to read from source");
+        return -1;
+    }
 
-		vips_image_set_string(out, name, value);
-	}
+    return (int) bytes_read;
 }
 
 static int
-vips_foreign_load_png_set_header(VipsForeignLoadPng *png, VipsImage *image)
+vips_foreign_load_spng_set_header(VipsForeignLoadSpng *spng, VipsImage *image)
 {
-	double xres, yres;
-	struct spng_iccp iccp;
-	struct spng_exif exif;
-	struct spng_phys phys;
-	struct spng_bkgd bkgd;
-	guint32 n_text;
-
-	/* Get resolution. Default to 72 pixels per inch.
-	 */
-	xres = 72.0 / 25.4;
-	yres = 72.0 / 25.4;
-	if (!spng_get_phys(png->ctx, &phys)) {
-		/* unit 1 means pixels per metre, otherwise unspecified.
-		 */
-		xres = phys.unit_specifier == 1
-			? phys.ppu_x / 1000.0
-			: phys.ppu_x;
-		yres = phys.unit_specifier == 1
-			? phys.ppu_y / 1000.0
-			: phys.ppu_y;
-	}
-
-	vips_image_init_fields(image,
-		png->ihdr.width, png->ihdr.height, png->bands,
-		png->format, VIPS_CODING_NONE, png->interpretation,
-		xres, yres);
-
-	VIPS_SETSTR(image->filename,
-		vips_connection_filename(VIPS_CONNECTION(png->source)));
-
-	if (vips_image_pipelinev(image, VIPS_DEMAND_STYLE_THINSTRIP, NULL))
-		return -1;
-
-	if (!spng_get_iccp(png->ctx, &iccp))
-		vips_image_set_blob_copy(image,
-			VIPS_META_ICC_NAME, iccp.profile, iccp.profile_len);
-
-	if (!spng_get_text(png->ctx, NULL, &n_text)) {
-		struct spng_text *text;
-
-		/* Very large numbers of text chunks are used in DoS
-		 * attacks.
-		 */
-		if (!png->unlimited && n_text > MAX_PNG_TEXT_CHUNKS) {
-			g_warning(_("%d text chunks, only %d text chunks will be loaded"),
-				n_text, MAX_PNG_TEXT_CHUNKS);
-			n_text = MAX_PNG_TEXT_CHUNKS;
-		}
-
-		text = VIPS_ARRAY(VIPS_OBJECT(png),
-			n_text, struct spng_text);
-		if (!spng_get_text(png->ctx, text, &n_text)) {
-			guint32 i;
-
-			for (i = 0; i < n_text; i++)
-				/* .text is always a null-terminated C string.
-				 */
-				vips_foreign_load_png_set_text(image,
-					i, text[i].keyword, text[i].text);
-		}
-	}
-
-	if (!spng_get_exif(png->ctx, &exif))
-		vips_image_set_blob_copy(image, VIPS_META_EXIF_NAME,
-			exif.data, exif.length);
-
-	vips_image_set_int(image, VIPS_META_BITS_PER_SAMPLE,
-		png->ihdr.bit_depth);
-
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) {
-		/* Deprecated "palette-bit-depth" use "bits-per-sample" instead.
-		 */
-		vips_image_set_int(image,
-			"palette-bit-depth", png->ihdr.bit_depth);
-
-		vips_image_set_int(image, VIPS_META_PALETTE, 1);
-	}
-
-	/* Let our caller know. These are very expensive to decode.
-	 */
-	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE)
-		vips_image_set_int(image, "interlaced", 1);
-
-	if (!spng_get_bkgd(png->ctx, &bkgd)) {
-		const int scale =
-			image->BandFmt == VIPS_FORMAT_UCHAR ? 1 : 256;
-
-		double array[3];
-		int n;
-
-		switch (png->ihdr.color_type) {
-		case SPNG_COLOR_TYPE_GRAYSCALE:
-		case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
-			array[0] = bkgd.gray / scale;
-			n = 1;
-			break;
-
-		case SPNG_COLOR_TYPE_TRUECOLOR:
-		case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
-			array[0] = bkgd.red / scale;
-			array[1] = bkgd.green / scale;
-			array[2] = bkgd.blue / scale;
-			n = 3;
-			break;
-
-		case SPNG_COLOR_TYPE_INDEXED:
-		default:
-			/* Not sure what to do here. I suppose we should read
-			 * the palette.
-			 */
-			n = 0;
-			break;
-		}
-
-		if (n > 0)
-			vips_image_set_array_double(image, "background",
-				array, n);
-	}
+    spng_ctx *ctx = spng_ctx_new(0);
+    struct spng_ihdr ihdr;
+    int ret;
+
+    if (!ctx) {
+        vips_error("spngload", "Failed to create spng context");
+        return -1;
+    }
+
+    spng_set_png_stream(ctx, vips_foreign_load_spng_read_fn, spng->source);
+    ret = spng_get_ihdr(ctx, &ihdr);
+
+    if (ret) {
+        spng_ctx_free(ctx);
+        vips_error("spngload", "Failed to get PNG header: %s", spng_strerror(ret));
+        return -1;
+    }
+
+    vips_image_init_fields(image,
+        ihdr.width, ihdr.height,
+        ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA ||
+        ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA ? 4 : 3,
+        ihdr.bit_depth == 16 ? VIPS_FORMAT_USHORT : VIPS_FORMAT_UCHAR,
+        VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0);
 
-	return 0;
+    spng_ctx_free(ctx);
+    return 0;
 }
 
 static int
-vips_foreign_load_png_header(VipsForeignLoad *load)
+vips_foreign_load_spng_header(VipsForeignLoad *load)
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) load;
 
-	int flags;
-	int error;
-	struct spng_trns trns;
-
-	/* In non-fail mode, ignore CRC errors.
-	 */
-	flags = 0;
-	if (load->fail_on < VIPS_FAIL_ON_ERROR)
-		flags |= SPNG_CTX_IGNORE_ADLER32;
-	png->ctx = spng_ctx_new(flags);
-	if (load->fail_on < VIPS_FAIL_ON_ERROR)
-		/* Ignore and don't calculate checksums.
-		 */
-		spng_set_crc_action(png->ctx, SPNG_CRC_USE, SPNG_CRC_USE);
-
-	/* Set limits to avoid decompression bombs. Set chunk limits to 60mb
-	 * -- we've seen 50mb XMP blocks in the wild.
-	 *
-	 * No need to test the decoded image size -- the user can do that if
-	 * they wish.
-	 */
-	if (!png->unlimited) {
-		spng_set_image_limits(png->ctx,
-			VIPS_MAX_COORD, VIPS_MAX_COORD);
-		spng_set_chunk_limits(png->ctx,
-			60 * 1024 * 1024, 60 * 1024 * 1024);
-	}
-
-	if (vips_source_rewind(png->source))
-		return -1;
-	spng_set_png_stream(png->ctx,
-		vips_foreign_load_png_stream, png->source);
-	if ((error = spng_get_ihdr(png->ctx, &png->ihdr))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-#ifdef DEBUG
-	printf("width: %d\nheight: %d\nbit depth: %d\ncolor type: %d\n",
-		png->ihdr.width, png->ihdr.height,
-		png->ihdr.bit_depth, png->ihdr.color_type);
-	printf("compression method: %d\nfilter method: %d\n"
-		   "interlace method: %d\n",
-		png->ihdr.compression_method, png->ihdr.filter_method,
-		png->ihdr.interlace_method);
-#endif /*DEBUG*/
-
-	/* Just convert to host-endian if nothing else applies.
-	 */
-	png->fmt = SPNG_FMT_PNG;
-
-	switch (png->ihdr.color_type) {
-	case SPNG_COLOR_TYPE_INDEXED:
-		png->bands = 3;
-		break;
-
-	case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
-	case SPNG_COLOR_TYPE_GRAYSCALE:
-		png->bands = 1;
-		break;
-
-	case SPNG_COLOR_TYPE_TRUECOLOR:
-	case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
-		png->bands = 3;
-		break;
-
-	default:
-		vips_error(class->nickname, "%s", _("unknown color type"));
-		return -1;
-	}
-
-	/* Set libvips format and interpretation.
-	 */
-	if (png->ihdr.bit_depth > 8) {
-		if (png->bands < 3)
-			png->interpretation = VIPS_INTERPRETATION_GREY16;
-		else
-			png->interpretation = VIPS_INTERPRETATION_RGB16;
-
-		png->format = VIPS_FORMAT_USHORT;
-	}
-	else {
-		if (png->bands < 3)
-			png->interpretation = VIPS_INTERPRETATION_B_W;
-		else
-			png->interpretation = VIPS_INTERPRETATION_sRGB;
-
-		png->format = VIPS_FORMAT_UCHAR;
-	}
-
-	/* Expand palette images.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
-		png->fmt = SPNG_FMT_RGB8;
-
-	/* Expand <8 bit images to full bytes.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE &&
-		png->ihdr.bit_depth < 8)
-		png->fmt = SPNG_FMT_G8;
-
-	/* Try reading the optional transparency chunk. This will cause all
-	 * chunks up to the first IDAT to be read in, so it can fail if any
-	 * chunk has an error.
-	 */
-	error = spng_get_trns(png->ctx, &trns);
-	if (error &&
-		error != SPNG_ECHUNKAVAIL) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	/* Expand transparency.
-	 *
-	 * The _ALPHA types should not have the optional trns chunk (they
-	 * always have a transparent band), see
-	 * https://www.w3.org/TR/2003/REC-PNG-20031110/#11tRNS
-	 *
-	 * It's quick and safe to call spng_get_trns() again, and we now know
-	 * it will only fail for no transparency chunk.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA ||
-		png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA)
-		png->bands += 1;
-	else if (!spng_get_trns(png->ctx, &trns)) {
-		png->bands += 1;
-
-		if (png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) {
-			if (png->ihdr.bit_depth == 16)
-				png->fmt = SPNG_FMT_RGBA16;
-			else
-				png->fmt = SPNG_FMT_RGBA8;
-		}
-		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
-			png->fmt = SPNG_FMT_RGBA8;
-		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE) {
-			if (png->ihdr.bit_depth == 16)
-				png->fmt = SPNG_FMT_GA16;
-			else
-				png->fmt = SPNG_FMT_GA8;
-		}
-	}
+    if (vips_foreign_load_spng_set_header(spng, load->out)) {
+        return -1;
+    }
 
-	vips_source_minimise(png->source);
-
-	if (vips_foreign_load_png_set_header(png, load->out))
-		return -1;
-
-	return 0;
+    return 0;
 }
 
-static void
-vips_foreign_load_png_minimise(VipsObject *object, VipsForeignLoadPng *png)
+static int
+vips_foreign_load_spng_generate(VipsRegion *out_region,
+    void *seq, void *a, void *b, gboolean *stop)
 {
-	vips_source_minimise(png->source);
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) a;
+    spng_ctx *ctx = spng_ctx_new(0);
+    size_t image_size;
+    int ret;
+
+    if (!ctx) {
+        vips_error("spngload", "Failed to create spng context");
+        return -1;
+    }
+
+    spng_set_png_stream(ctx, vips_foreign_load_spng_read_fn, spng->source);
+    ret = spng_decoded_image_size(ctx, SPNG_FMT_RGBA8, &image_size);
+    if (ret) {
+        spng_ctx_free(ctx);
+        vips_error("spngload", "Failed to get decoded image size: %s", spng_strerror(ret));
+        return -1;
+    }
+
+    void *data = g_malloc(image_size);
+    ret = spng_decode_image(ctx, data, image_size, SPNG_FMT_RGBA8, 0);
+    if (ret) {
+        g_free(data);
+        spng_ctx_free(ctx);
+        vips_error("spngload", "Failed to decode image: %s", spng_strerror(ret));
+        return -1;
+    }
+
+    VipsRect *r = &out_region->valid;
+    int line_size = r->width * out_region->im->Bands;
+    for (int y = 0; y < r->height; y++) {
+        unsigned char *p = (unsigned char *) data + (y + r->top) * line_size;
+        unsigned char *q = VIPS_REGION_ADDR(out_region, r->left, y + r->top);
+        memcpy(q, p, line_size);
+    }
+
+    g_free(data);
+    spng_ctx_free(ctx);
+    return 0;
 }
 
 static int
-vips_foreign_load_png_generate(VipsRegion *out_region,
-	void *seq, void *a, void *b, gboolean *stop)
+vips_foreign_load_spng_load(VipsForeignLoad *load)
 {
-	VipsRect *r = &out_region->valid;
-	VipsForeignLoad *load = VIPS_FOREIGN_LOAD(a);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(png);
-
-	int y;
-	int error;
-
-#ifdef DEBUG
-	printf("vips_foreign_load_png_generate: line %d, %d rows\n",
-		r->top, r->height);
-	printf("vips_foreign_load_png_generate: y_top = %d\n", png->y_pos);
-#endif /*DEBUG*/
-
-	/* We're inside a tilecache where tiles are the full image width, so
-	 * this should always be true.
-	 */
-	g_assert(r->left == 0);
-	g_assert(r->width == out_region->im->Xsize);
-	g_assert(VIPS_RECT_BOTTOM(r) <= out_region->im->Ysize);
-
-	/* Tiles should always be a strip in height, unless it's the final
-	 * strip.
-	 */
-	g_assert(r->height ==
-		VIPS_MIN(VIPS__FATSTRIP_HEIGHT, out_region->im->Ysize - r->top));
-
-	/* And check that y_pos is correct. It should be, since we are inside
-	 * a vips_sequential().
-	 */
-	if (r->top != png->y_pos) {
-		vips_error(class->nickname,
-			_("out of order read at line %d"), png->y_pos);
-		return -1;
-	}
-
-	for (y = 0; y < r->height; y++) {
-		/* libspng returns EOI when successfully reading the
-		 * final line of input.
-		 */
-		error = spng_decode_row(png->ctx,
-			VIPS_REGION_ADDR(out_region, 0, r->top + y),
-			VIPS_REGION_SIZEOF_LINE(out_region));
-		if (error != 0 &&
-			error != SPNG_EOI) {
-			/* We've failed to read some pixels. Knock this
-			 * operation out of cache.
-			 */
-			vips_operation_invalidate(VIPS_OPERATION(png));
-
-#ifdef DEBUG
-			printf("vips_foreign_load_png_generate:\n");
-			printf("  spng_decode_row() failed, line %d\n",
-				r->top + y);
-			printf("  thread %p\n", g_thread_self());
-			printf("  error %s\n", spng_strerror(error));
-#endif /*DEBUG*/
-
-			g_warning("%s: %s",
-				class->nickname, spng_strerror(error));
-
-			/* And bail if trunc is on.
-			 */
-			if (load->fail_on >= VIPS_FAIL_ON_TRUNCATED) {
-				vips_error(class->nickname,
-					"%s", _("libspng read error"));
-				return -1;
-			}
-		}
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) load;
+    VipsImage **out = &load->out;
 
-		png->y_pos += 1;
-	}
+    if (vips_image_pipelinev(*out, VIPS_DEMAND_STYLE_THINSTRIP, NULL)) {
+        return -1;
+    }
 
-	return 0;
+    if (vips_image_generate(*out, NULL, vips_foreign_load_spng_generate, NULL, spng, NULL)) {
+        return -1;
+    }
+
+    return 0;
 }
 
-static int
-vips_foreign_load_png_load(VipsForeignLoad *load)
+static gboolean
+vips_foreign_load_spng_is_a_source(VipsSource *source)
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-	VipsImage **t = (VipsImage **)
-		vips_object_local_array(VIPS_OBJECT(load), 3);
-
-	enum spng_decode_flags flags;
-	int error;
-
-	if (vips_source_decode(png->source))
-		return -1;
-
-	/* Decode transparency, if available.
-	 */
-	flags = SPNG_DECODE_TRNS;
-
-	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE) {
-		/* Arg awful interlaced image. We have to load to a huge mem
-		 * buffer, then copy to out.
-		 */
-		t[0] = vips_image_new_memory();
-		if (vips_foreign_load_png_set_header(png, t[0]) ||
-			vips_image_write_prepare(t[0]))
-			return -1;
-
-		if ((error = spng_decode_image(png->ctx,
-				 VIPS_IMAGE_ADDR(t[0], 0, 0),
-				 VIPS_IMAGE_SIZEOF_IMAGE(t[0]),
-				 png->fmt, flags))) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-
-		/* We've now finished reading the file.
-		 */
-		vips_source_minimise(png->source);
-
-		if (vips_image_write(t[0], load->real))
-			return -1;
-	}
-	else {
-		t[0] = vips_image_new();
-
-		if (vips_foreign_load_png_set_header(png, t[0]))
-			return -1;
-
-		/* We can decode these progressively.
-		 */
-		flags |= SPNG_DECODE_PROGRESSIVE;
-
-		if ((error = spng_decode_image(png->ctx, NULL, 0,
-				 png->fmt, flags))) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-
-		/* Close input immediately at end of read.
-		 */
-		g_signal_connect(t[0], "minimise",
-			G_CALLBACK(vips_foreign_load_png_minimise), png);
-
-		if (vips_image_generate(t[0],
-				NULL, vips_foreign_load_png_generate, NULL,
-				png, NULL) ||
-			vips_sequential(t[0], &t[1],
-				"tile_height", VIPS__FATSTRIP_HEIGHT,
-				NULL) ||
-			vips_image_write(t[1], load->real))
-			return -1;
-	}
+    const unsigned char *data;
 
-	return 0;
-}
+    if ((data = vips_source_sniff(source, 8))) {
+        // Check for PNG signature: 89 50 4E 47 0D 0A 1A 0A
+        return data[0] == 0x89 &&
+               data[1] == 'P' &&
+               data[2] == 'N' &&
+               data[3] == 'G' &&
+               data[4] == 0x0D &&
+               data[5] == 0x0A &&
+               data[6] == 0x1A &&
+               data[7] == 0x0A;
+    }
 
-static void
-vips_foreign_load_png_class_init(VipsForeignLoadPngClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->dispose = vips_foreign_load_png_dispose;
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_base";
-	object_class->description = _("load png base class");
-
-	/* We are fast at is_a(), so high priority.
-	 */
-	foreign_class->priority = 200;
-
-	load_class->get_flags_filename =
-		vips_foreign_load_png_get_flags_filename;
-	load_class->get_flags = vips_foreign_load_png_get_flags;
-	load_class->header = vips_foreign_load_png_header;
-	load_class->load = vips_foreign_load_png_load;
-
-#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-	VIPS_ARG_BOOL(class, "unlimited", 23,
-		_("Unlimited"),
-		_("Remove all denial of service limits"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPng, unlimited),
-		FALSE);
-#endif
+    return FALSE;
 }
 
 static void
-vips_foreign_load_png_init(VipsForeignLoadPng *png)
+vips_foreign_load_spng_class_init(VipsForeignLoadSpngClass *class)
 {
-}
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignLoadClass *foreign_class = VIPS_FOREIGN_LOAD_CLASS(class);
 
-typedef struct _VipsForeignLoadPngSource {
-	VipsForeignLoadPng parent_object;
+    gobject_class->dispose = vips_foreign_load_spng_dispose;
 
-	/* Load from a source.
-	 */
-	VipsSource *source;
+    object_class->nickname = "spngload_base";
+    object_class->description = "load PNG with libspng";
 
-} VipsForeignLoadPngSource;
+    foreign_class->get_flags = vips_foreign_load_spng_get_flags;
+    foreign_class->header = vips_foreign_load_spng_header;
+    foreign_class->load = vips_foreign_load_spng_load;
+    foreign_class->is_a_source = vips_foreign_load_spng_is_a_source;
+}
 
-typedef VipsForeignLoadPngClass VipsForeignLoadPngSourceClass;
+static void
+vips_foreign_load_spng_init(VipsForeignLoadSpng *spng)
+{
+}
 
-G_DEFINE_TYPE(VipsForeignLoadPngSource, vips_foreign_load_png_source,
-	vips_foreign_load_png_get_type());
+G_DEFINE_TYPE(VipsForeignLoadSpngFile, vips_foreign_load_spng_file, vips_foreign_load_spng_get_type());
 
 static int
-vips_foreign_load_png_source_build(VipsObject *object)
+vips_foreign_load_spng_file_build(VipsObject *object)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngSource *source = (VipsForeignLoadPngSource *) object;
+    VipsForeignLoadSpngFile *file = (VipsForeignLoadSpngFile *) object;
+
+    if (file->filename) {
+        VipsSource *source = vips_source_new_from_file(file->filename);
+        VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) object;
 
-	if (source->source) {
-		png->source = source->source;
-		g_object_ref(png->source);
-	}
+        if (!source)
+            return -1;
 
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_source_parent_class)
-			->build(object))
-		return -1;
+        spng->source = source;
+    }
 
-	return 0;
+    return VIPS_OBJECT_CLASS(vips_foreign_load_spng_file_parent_class)->build(object);
 }
 
 static gboolean
-vips_foreign_load_png_source_is_a_source(VipsSource *source)
+vips_foreign_load_spng_file_is_a(const char *filename)
 {
-	static unsigned char signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
+    VipsSource *source = vips_source_new_from_file(filename);
+    gboolean result;
 
-	const unsigned char *p;
+    if (!source)
+        return FALSE;
 
-	if ((p = vips_source_sniff(source, 8)) &&
-		memcmp(p, signature, 8) == 0)
-		return TRUE;
+    result = vips_foreign_load_spng_get_flags_source(source) != 0;
+    VIPS_UNREF(source);
 
-	return FALSE;
+    return result;
 }
 
 static void
-vips_foreign_load_png_source_class_init(VipsForeignLoadPngSourceClass *class)
+vips_foreign_load_spng_file_class_init(VipsForeignLoadSpngFileClass *class)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS(class);
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_source";
-	object_class->description = _("load png from source");
-	object_class->build = vips_foreign_load_png_source_build;
-
-	operation_class->flags |= VIPS_OPERATION_NOCACHE;
-
-	load_class->is_a_source = vips_foreign_load_png_source_is_a_source;
-
-	VIPS_ARG_OBJECT(class, "source", 1,
-		_("Source"),
-		_("Source to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngSource, source),
-		VIPS_TYPE_SOURCE);
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignLoadClass *foreign_class = VIPS_FOREIGN_LOAD_CLASS(class);
+
+    gobject_class->set_property = vips_object_set_property;
+    gobject_class->get_property = vips_object_get_property;
+
+    object_class->nickname = "spngload";
+    object_class->description = "load PNG file with libspng";
+    object_class->build = vips_foreign_load_spng_file_build;
+
+    foreign_class->is_a = vips_foreign_load_spng_file_is_a;
+    foreign_class->suffs = vips__png_suffs; // Add suffix list
+
+    VIPS_ARG_STRING(class, "filename", 1,
+        "Filename", "Filename to load from",
+        VIPS_ARGUMENT_REQUIRED_INPUT,
+        G_STRUCT_OFFSET(VipsForeignLoadSpngFile, filename),
+        NULL);
 }
 
 static void
-vips_foreign_load_png_source_init(VipsForeignLoadPngSource *source)
+vips_foreign_load_spng_file_init(VipsForeignLoadSpngFile *file)
 {
 }
 
-typedef struct _VipsForeignLoadPngFile {
-	VipsForeignLoadPng parent_object;
+G_DEFINE_TYPE(VipsForeignLoadSpngBuffer, vips_foreign_load_spng_buffer, vips_foreign_load_spng_get_type());
 
-	/* Filename for load.
-	 */
-	char *filename;
-
-} VipsForeignLoadPngFile;
+static gboolean
+vips_foreign_load_spng_buffer_is_a_buffer(const void *buf, size_t len)
+{
+    const unsigned char *header = (const unsigned char *) buf;
 
-typedef VipsForeignLoadPngClass VipsForeignLoadPngFileClass;
+    if (len >= 8 &&
+        header[0] == 0x89 && header[1] == 0x50 && header[2] == 0x4E && header[3] == 0x47 &&
+        header[4] == 0x0D && header[5] == 0x0A && header[6] == 0x1A && header[7] == 0x0A) {
+        return TRUE;
+    }
 
-G_DEFINE_TYPE(VipsForeignLoadPngFile, vips_foreign_load_png_file,
-	vips_foreign_load_png_get_type());
+    return FALSE;
+}
 
 static int
-vips_foreign_load_png_file_build(VipsObject *object)
+vips_foreign_load_spng_buffer_build(VipsObject *object)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngFile *file = (VipsForeignLoadPngFile *) object;
+    VipsForeignLoadSpngBuffer *buffer = (VipsForeignLoadSpngBuffer *) object;
 
-	if (file->filename &&
-		!(png->source = vips_source_new_from_file(file->filename)))
-		return -1;
+    if (buffer->buffer) {
+        VipsSource *source = vips_source_new_from_memory(VIPS_AREA(buffer->buffer)->data,
+            VIPS_AREA(buffer->buffer)->length);
+        VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) object;
 
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_file_parent_class)->build(object))
-		return -1;
+        if (!source)
+            return -1;
 
-	return 0;
+        spng->source = source;
+    }
+
+    return VIPS_OBJECT_CLASS(vips_foreign_load_spng_buffer_parent_class)->build(object);
 }
 
-static gboolean
-vips_foreign_load_png_file_is_a(const char *filename)
+static void
+vips_foreign_load_spng_buffer_class_init(VipsForeignLoadSpngBufferClass *class)
 {
-	VipsSource *source;
-	gboolean result;
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignLoadClass *foreign_class = VIPS_FOREIGN_LOAD_CLASS(class);
 
-	if (!(source = vips_source_new_from_file(filename)))
-		return FALSE;
-	result = vips_foreign_load_png_source_is_a_source(source);
-	VIPS_UNREF(source);
+    gobject_class->set_property = vips_object_set_property;
+    gobject_class->get_property = vips_object_get_property;
 
-	return result;
-}
+    object_class->nickname = "spngload_buffer";
+    object_class->description = "load PNG buffer with libspng";
+    object_class->build = vips_foreign_load_spng_buffer_build;
 
-const char *vips_foreign_load_png_file_suffs[] = { ".png", NULL };
+    foreign_class->is_a_buffer = vips_foreign_load_spng_buffer_is_a_buffer;
 
-static void
-vips_foreign_load_png_file_class_init(VipsForeignLoadPngFileClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload";
-	object_class->description = _("load png from file");
-	object_class->build = vips_foreign_load_png_file_build;
-
-	foreign_class->suffs = vips_foreign_load_png_file_suffs;
-
-	load_class->is_a = vips_foreign_load_png_file_is_a;
-
-	VIPS_ARG_STRING(class, "filename", 1,
-		_("Filename"),
-		_("Filename to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngFile, filename),
-		NULL);
+    VIPS_ARG_BOXED(class, "buffer", 1,
+        "Buffer", "Buffer to load from",
+        VIPS_ARGUMENT_REQUIRED_INPUT,
+        G_STRUCT_OFFSET(VipsForeignLoadSpngBuffer, buffer),
+        VIPS_TYPE_BLOB);
 }
 
 static void
-vips_foreign_load_png_file_init(VipsForeignLoadPngFile *file)
+vips_foreign_load_spng_buffer_init(VipsForeignLoadSpngBuffer *buffer)
 {
 }
 
-typedef struct _VipsForeignLoadPngBuffer {
-	VipsForeignLoadPng parent_object;
-
-	/* Load from a buffer.
-	 */
-	VipsBlob *blob;
-
-} VipsForeignLoadPngBuffer;
-
-typedef VipsForeignLoadPngClass VipsForeignLoadPngBufferClass;
-
-G_DEFINE_TYPE(VipsForeignLoadPngBuffer, vips_foreign_load_png_buffer,
-	vips_foreign_load_png_get_type());
+G_DEFINE_TYPE(VipsForeignLoadSpngSource, vips_foreign_load_spng_source, vips_foreign_load_spng_get_type());
 
 static int
-vips_foreign_load_png_buffer_build(VipsObject *object)
+vips_foreign_load_spng_source_build(VipsObject *object)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngBuffer *buffer = (VipsForeignLoadPngBuffer *) object;
+    VipsForeignLoadSpngSource *source = (VipsForeignLoadSpngSource *) object;
 
-	if (buffer->blob &&
-		!(png->source = vips_source_new_from_memory(
-			  VIPS_AREA(buffer->blob)->data,
-			  VIPS_AREA(buffer->blob)->length)))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_buffer_parent_class)
-			->build(object))
-		return -1;
+    if (source->source) {
+        VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) object;
 
-	return 0;
+        spng->source = source->source;
+        g_object_ref(spng->source);
+    }
+
+    return VIPS_OBJECT_CLASS(vips_foreign_load_spng_source_parent_class)->build(object);
 }
 
-static gboolean
-vips_foreign_load_png_buffer_is_a_buffer(const void *buf, size_t len)
+static void
+vips_foreign_load_spng_source_class_init(VipsForeignLoadSpngSourceClass *class)
 {
-	VipsSource *source;
-	gboolean result;
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
 
-	if (!(source = vips_source_new_from_memory(buf, len)))
-		return FALSE;
-	result = vips_foreign_load_png_source_is_a_source(source);
-	VIPS_UNREF(source);
+    gobject_class->set_property = vips_object_set_property;
+    gobject_class->get_property = vips_object_get_property;
 
-	return result;
-}
+    object_class->nickname = "spngload_source";
+    object_class->description = "load PNG from source with libspng";
+    object_class->build = vips_foreign_load_spng_source_build;
 
-static void
-vips_foreign_load_png_buffer_class_init(VipsForeignLoadPngBufferClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_buffer";
-	object_class->description = _("load png from buffer");
-	object_class->build = vips_foreign_load_png_buffer_build;
-
-	load_class->is_a_buffer = vips_foreign_load_png_buffer_is_a_buffer;
-
-	VIPS_ARG_BOXED(class, "buffer", 1,
-		_("Buffer"),
-		_("Buffer to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngBuffer, blob),
-		VIPS_TYPE_BLOB);
+    VIPS_ARG_OBJECT(class, "source", 1,
+        "Source", "Source to load from",
+        VIPS_ARGUMENT_REQUIRED_INPUT,
+        G_STRUCT_OFFSET(VipsForeignLoadSpngSource, source),
+        VIPS_TYPE_SOURCE);
 }
 
 static void
-vips_foreign_load_png_buffer_init(VipsForeignLoadPngBuffer *buffer)
+vips_foreign_load_spng_source_init(VipsForeignLoadSpngSource *source)
 {
 }
 
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngload.c.bak vips-8.16.1/libvips/foreign/spngload.c.bak
--- vips-8.16.1.orig/libvips/foreign/spngload.c.bak	1969-12-31 16:00:00.000000000 -0800
+++ vips-8.16.1/libvips/foreign/spngload.c.bak	2025-07-12 09:12:09.244847111 -0700
@@ -0,0 +1,923 @@
+/* load PNG with libspng
+ *
+ * 1/5/20
+ * 	- from pngload.c
+ * 19/2/21 781545872
+ * 	- read out background, if we can
+ * 29/8/21 joshuamsager
+ *	-  add "unlimited" flag to png load
+ * 3/2/23 MathemanFlo
+ * 	- add bits per sample metadata
+ */
+
+/*
+
+	This file is part of VIPS.
+
+	VIPS is free software; you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+	02110-1301  USA
+
+ */
+
+/*
+
+	These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
+
+ */
+
+/*
+#define DEBUG
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+#include <glib/gi18n-lib.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <vips/vips.h>
+#include <vips/buf.h>
+#include <vips/internal.h>
+
+#include "pforeign.h"
+
+#ifdef HAVE_SPNG
+
+#include <spng.h>
+
+typedef struct _VipsForeignLoadSpng {
+	VipsForeignLoad parent_object;
+
+	/* Set by subclasses.
+	 */
+	VipsSource *source;
+
+	/* Remove DoS limits.
+	 */
+	gboolean unlimited;
+
+	spng_ctx *ctx;
+	struct spng_ihdr ihdr;
+	enum spng_format fmt;
+	int bands;
+	VipsInterpretation interpretation;
+	VipsBandFormat format;
+	int y_pos;
+} VipsForeignLoadSpng;
+
+typedef VipsForeignLoadClass VipsForeignLoadSpngClass;
+
+G_DEFINE_ABSTRACT_TYPE(VipsForeignLoadSpng, vips_foreign_load_png,
+	VIPS_TYPE_FOREIGN_LOAD);
+
+static void
+vips_foreign_load_png_dispose(GObject *gobject)
+{
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) gobject;
+
+	VIPS_FREEF(spng_ctx_free, png->ctx);
+	VIPS_UNREF(png->source);
+
+	G_OBJECT_CLASS(vips_foreign_load_png_parent_class)->dispose(gobject);
+}
+
+static int
+vips_foreign_load_png_stream(spng_ctx *ctx, void *user,
+	void *dest, size_t length)
+{
+	VipsSource *source = VIPS_SOURCE(user);
+
+	while (length > 0) {
+		gint64 bytes_read;
+
+		bytes_read = vips_source_read(source, dest, length);
+		if (bytes_read < 0)
+			return SPNG_IO_ERROR;
+		if (bytes_read == 0)
+			return SPNG_IO_EOF;
+
+		dest = (char *) dest + bytes_read;
+		length -= bytes_read;
+	}
+
+	return 0;
+}
+
+static VipsForeignFlags
+vips_foreign_load_png_get_flags_source(VipsSource *source)
+{
+	spng_ctx *ctx;
+	struct spng_ihdr ihdr;
+	VipsForeignFlags flags;
+
+	ctx = spng_ctx_new(SPNG_CTX_IGNORE_ADLER32);
+	spng_set_crc_action(ctx, SPNG_CRC_USE, SPNG_CRC_USE);
+	if (vips_source_rewind(source))
+		return 0;
+	spng_set_png_stream(ctx,
+		vips_foreign_load_png_stream, source);
+	if (spng_get_ihdr(ctx, &ihdr)) {
+		spng_ctx_free(ctx);
+		return 0;
+	}
+	spng_ctx_free(ctx);
+
+	flags = 0;
+	if (ihdr.interlace_method != SPNG_INTERLACE_NONE)
+		flags |= VIPS_FOREIGN_PARTIAL;
+	else
+		flags |= VIPS_FOREIGN_SEQUENTIAL;
+
+	return flags;
+}
+
+static VipsForeignFlags
+vips_foreign_load_png_get_flags(VipsForeignLoad *load)
+{
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) load;
+
+	return vips_foreign_load_png_get_flags_source(png->source);
+}
+
+static VipsForeignFlags
+vips_foreign_load_png_get_flags_filename(const char *filename)
+{
+	VipsSource *source;
+	VipsForeignFlags flags;
+
+	if (!(source = vips_source_new_from_file(filename)))
+		return 0;
+	flags = vips_foreign_load_png_get_flags_source(source);
+	VIPS_UNREF(source);
+
+	return flags;
+}
+
+/* Set the png text data as metadata on the vips image. These are always
+ * null-terminated strings.
+ */
+static void
+vips_foreign_load_png_set_text(VipsImage *out,
+	int i, const char *key, const char *value)
+{
+#ifdef DEBUG
+	printf("vips_foreign_load_png_set_text: key %s, value %s\n",
+		key, value);
+#endif /*DEBUG*/
+
+	if (strcmp(key, "XML:com.adobe.xmp") == 0) {
+		/* Save as an XMP tag. This must be a BLOB, for compatibility
+		 * for things like the XMP blob that the tiff loader adds.
+		 *
+		 * Note that this will remove the null-termination from the
+		 * string. We must carefully reattach this.
+		 */
+		vips_image_set_blob_copy(out,
+			VIPS_META_XMP_NAME, value, strlen(value));
+	}
+	else {
+		char name[256];
+
+		/* Save as a string comment. Some PNGs have EXIF data as
+		 * text segments, unfortunately.
+		 */
+		g_snprintf(name, 256, "png-comment-%d-%s", i, key);
+
+		vips_image_set_string(out, name, value);
+	}
+}
+
+static int
+vips_foreign_load_png_set_header(VipsForeignLoadSpng *png, VipsImage *image)
+{
+	double xres, yres;
+	struct spng_iccp iccp;
+	struct spng_exif exif;
+	struct spng_phys phys;
+	struct spng_bkgd bkgd;
+	guint32 n_text;
+
+	/* Get resolution. Default to 72 pixels per inch.
+	 */
+	xres = 72.0 / 25.4;
+	yres = 72.0 / 25.4;
+	if (!spng_get_phys(png->ctx, &phys)) {
+		/* unit 1 means pixels per metre, otherwise unspecified.
+		 */
+		xres = phys.unit_specifier == 1
+			? phys.ppu_x / 1000.0
+			: phys.ppu_x;
+		yres = phys.unit_specifier == 1
+			? phys.ppu_y / 1000.0
+			: phys.ppu_y;
+	}
+
+	vips_image_init_fields(image,
+		png->ihdr.width, png->ihdr.height, png->bands,
+		png->format, VIPS_CODING_NONE, png->interpretation,
+		xres, yres);
+
+	VIPS_SETSTR(image->filename,
+		vips_connection_filename(VIPS_CONNECTION(png->source)));
+
+	if (vips_image_pipelinev(image, VIPS_DEMAND_STYLE_THINSTRIP, NULL))
+		return -1;
+
+	if (!spng_get_iccp(png->ctx, &iccp))
+		vips_image_set_blob_copy(image,
+			VIPS_META_ICC_NAME, iccp.profile, iccp.profile_len);
+
+	if (!spng_get_text(png->ctx, NULL, &n_text)) {
+		struct spng_text *text;
+
+		/* Very large numbers of text chunks are used in DoS
+		 * attacks.
+		 */
+		if (!png->unlimited && n_text > MAX_PNG_TEXT_CHUNKS) {
+			g_warning(_("%d text chunks, only %d text chunks will be loaded"),
+				n_text, MAX_PNG_TEXT_CHUNKS);
+			n_text = MAX_PNG_TEXT_CHUNKS;
+		}
+
+		text = VIPS_ARRAY(VIPS_OBJECT(png),
+			n_text, struct spng_text);
+		if (!spng_get_text(png->ctx, text, &n_text)) {
+			guint32 i;
+
+			for (i = 0; i < n_text; i++)
+				/* .text is always a null-terminated C string.
+				 */
+				vips_foreign_load_png_set_text(image,
+					i, text[i].keyword, text[i].text);
+		}
+	}
+
+	if (!spng_get_exif(png->ctx, &exif))
+		vips_image_set_blob_copy(image, VIPS_META_EXIF_NAME,
+			exif.data, exif.length);
+
+	vips_image_set_int(image, VIPS_META_BITS_PER_SAMPLE,
+		png->ihdr.bit_depth);
+
+	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) {
+		/* Deprecated "palette-bit-depth" use "bits-per-sample" instead.
+		 */
+		vips_image_set_int(image,
+			"palette-bit-depth", png->ihdr.bit_depth);
+
+		vips_image_set_int(image, VIPS_META_PALETTE, 1);
+	}
+
+	/* Let our caller know. These are very expensive to decode.
+	 */
+	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE)
+		vips_image_set_int(image, "interlaced", 1);
+
+	if (!spng_get_bkgd(png->ctx, &bkgd)) {
+		const int scale =
+			image->BandFmt == VIPS_FORMAT_UCHAR ? 1 : 256;
+
+		double array[3];
+		int n;
+
+		switch (png->ihdr.color_type) {
+		case SPNG_COLOR_TYPE_GRAYSCALE:
+		case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
+			array[0] = bkgd.gray / scale;
+			n = 1;
+			break;
+
+		case SPNG_COLOR_TYPE_TRUECOLOR:
+		case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
+			array[0] = bkgd.red / scale;
+			array[1] = bkgd.green / scale;
+			array[2] = bkgd.blue / scale;
+			n = 3;
+			break;
+
+		case SPNG_COLOR_TYPE_INDEXED:
+		default:
+			/* Not sure what to do here. I suppose we should read
+			 * the palette.
+			 */
+			n = 0;
+			break;
+		}
+
+		if (n > 0)
+			vips_image_set_array_double(image, "background",
+				array, n);
+	}
+
+	return 0;
+}
+
+static int
+vips_foreign_load_png_header(VipsForeignLoad *load)
+{
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) load;
+
+	int flags;
+	int error;
+	struct spng_trns trns;
+
+	/* In non-fail mode, ignore CRC errors.
+	 */
+	flags = 0;
+	if (load->fail_on < VIPS_FAIL_ON_ERROR)
+		flags |= SPNG_CTX_IGNORE_ADLER32;
+	png->ctx = spng_ctx_new(flags);
+	if (load->fail_on < VIPS_FAIL_ON_ERROR)
+		/* Ignore and don't calculate checksums.
+		 */
+		spng_set_crc_action(png->ctx, SPNG_CRC_USE, SPNG_CRC_USE);
+
+	/* Set limits to avoid decompression bombs. Set chunk limits to 60mb
+	 * -- we've seen 50mb XMP blocks in the wild.
+	 *
+	 * No need to test the decoded image size -- the user can do that if
+	 * they wish.
+	 */
+	if (!png->unlimited) {
+		spng_set_image_limits(png->ctx,
+			VIPS_MAX_COORD, VIPS_MAX_COORD);
+		spng_set_chunk_limits(png->ctx,
+			60 * 1024 * 1024, 60 * 1024 * 1024);
+	}
+
+	if (vips_source_rewind(png->source))
+		return -1;
+	spng_set_png_stream(png->ctx,
+		vips_foreign_load_png_stream, png->source);
+	if ((error = spng_get_ihdr(png->ctx, &png->ihdr))) {
+		vips_error(class->nickname, "%s", spng_strerror(error));
+		return -1;
+	}
+
+#ifdef DEBUG
+	printf("width: %d\nheight: %d\nbit depth: %d\ncolor type: %d\n",
+		png->ihdr.width, png->ihdr.height,
+		png->ihdr.bit_depth, png->ihdr.color_type);
+	printf("compression method: %d\nfilter method: %d\n"
+		   "interlace method: %d\n",
+		png->ihdr.compression_method, png->ihdr.filter_method,
+		png->ihdr.interlace_method);
+#endif /*DEBUG*/
+
+	/* Just convert to host-endian if nothing else applies.
+	 */
+	png->fmt = SPNG_FMT_PNG;
+
+	switch (png->ihdr.color_type) {
+	case SPNG_COLOR_TYPE_INDEXED:
+		png->bands = 3;
+		break;
+
+	case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
+	case SPNG_COLOR_TYPE_GRAYSCALE:
+		png->bands = 1;
+		break;
+
+	case SPNG_COLOR_TYPE_TRUECOLOR:
+	case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
+		png->bands = 3;
+		break;
+
+	default:
+		vips_error(class->nickname, "%s", _("unknown color type"));
+		return -1;
+	}
+
+	/* Set libvips format and interpretation.
+	 */
+	if (png->ihdr.bit_depth > 8) {
+		if (png->bands < 3)
+			png->interpretation = VIPS_INTERPRETATION_GREY16;
+		else
+			png->interpretation = VIPS_INTERPRETATION_RGB16;
+
+		png->format = VIPS_FORMAT_USHORT;
+	}
+	else {
+		if (png->bands < 3)
+			png->interpretation = VIPS_INTERPRETATION_B_W;
+		else
+			png->interpretation = VIPS_INTERPRETATION_sRGB;
+
+		png->format = VIPS_FORMAT_UCHAR;
+	}
+
+	/* Expand palette images.
+	 */
+	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
+		png->fmt = SPNG_FMT_RGB8;
+
+	/* Expand <8 bit images to full bytes.
+	 */
+	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE &&
+		png->ihdr.bit_depth < 8)
+		png->fmt = SPNG_FMT_G8;
+
+	/* Try reading the optional transparency chunk. This will cause all
+	 * chunks up to the first IDAT to be read in, so it can fail if any
+	 * chunk has an error.
+	 */
+	error = spng_get_trns(png->ctx, &trns);
+	if (error &&
+		error != SPNG_ECHUNKAVAIL) {
+		vips_error(class->nickname, "%s", spng_strerror(error));
+		return -1;
+	}
+
+	/* Expand transparency.
+	 *
+	 * The _ALPHA types should not have the optional trns chunk (they
+	 * always have a transparent band), see
+	 * https://www.w3.org/TR/2003/REC-PNG-20031110/#11tRNS
+	 *
+	 * It's quick and safe to call spng_get_trns() again, and we now know
+	 * it will only fail for no transparency chunk.
+	 */
+	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA ||
+		png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA)
+		png->bands += 1;
+	else if (!spng_get_trns(png->ctx, &trns)) {
+		png->bands += 1;
+
+		if (png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) {
+			if (png->ihdr.bit_depth == 16)
+				png->fmt = SPNG_FMT_RGBA16;
+			else
+				png->fmt = SPNG_FMT_RGBA8;
+		}
+		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
+			png->fmt = SPNG_FMT_RGBA8;
+		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE) {
+			if (png->ihdr.bit_depth == 16)
+				png->fmt = SPNG_FMT_GA16;
+			else
+				png->fmt = SPNG_FMT_GA8;
+		}
+	}
+
+	vips_source_minimise(png->source);
+
+	if (vips_foreign_load_png_set_header(png, load->out))
+		return -1;
+
+	return 0;
+}
+
+static void
+vips_foreign_load_png_minimise(VipsObject *object, VipsForeignLoadSpng *png)
+{
+	vips_source_minimise(png->source);
+}
+
+static int
+vips_foreign_load_png_generate(VipsRegion *out_region,
+	void *seq, void *a, void *b, gboolean *stop)
+{
+	VipsRect *r = &out_region->valid;
+	VipsForeignLoad *load = VIPS_FOREIGN_LOAD(a);
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) load;
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(png);
+
+	int y;
+	int error;
+
+#ifdef DEBUG
+	printf("vips_foreign_load_png_generate: line %d, %d rows\n",
+		r->top, r->height);
+	printf("vips_foreign_load_png_generate: y_top = %d\n", png->y_pos);
+#endif /*DEBUG*/
+
+	/* We're inside a tilecache where tiles are the full image width, so
+	 * this should always be true.
+	 */
+	g_assert(r->left == 0);
+	g_assert(r->width == out_region->im->Xsize);
+	g_assert(VIPS_RECT_BOTTOM(r) <= out_region->im->Ysize);
+
+	/* Tiles should always be a strip in height, unless it's the final
+	 * strip.
+	 */
+	g_assert(r->height ==
+		VIPS_MIN(VIPS__FATSTRIP_HEIGHT, out_region->im->Ysize - r->top));
+
+	/* And check that y_pos is correct. It should be, since we are inside
+	 * a vips_sequential().
+	 */
+	if (r->top != png->y_pos) {
+		vips_error(class->nickname,
+			_("out of order read at line %d"), png->y_pos);
+		return -1;
+	}
+
+	for (y = 0; y < r->height; y++) {
+		/* libspng returns EOI when successfully reading the
+		 * final line of input.
+		 */
+		error = spng_decode_row(png->ctx,
+			VIPS_REGION_ADDR(out_region, 0, r->top + y),
+			VIPS_REGION_SIZEOF_LINE(out_region));
+		if (error != 0 &&
+			error != SPNG_EOI) {
+			/* We've failed to read some pixels. Knock this
+			 * operation out of cache.
+			 */
+			vips_operation_invalidate(VIPS_OPERATION(png));
+
+#ifdef DEBUG
+			printf("vips_foreign_load_png_generate:\n");
+			printf("  spng_decode_row() failed, line %d\n",
+				r->top + y);
+			printf("  thread %p\n", g_thread_self());
+			printf("  error %s\n", spng_strerror(error));
+#endif /*DEBUG*/
+
+			g_warning("%s: %s",
+				class->nickname, spng_strerror(error));
+
+			/* And bail if trunc is on.
+			 */
+			if (load->fail_on >= VIPS_FAIL_ON_TRUNCATED) {
+				vips_error(class->nickname,
+					"%s", _("libspng read error"));
+				return -1;
+			}
+		}
+
+		png->y_pos += 1;
+	}
+
+	return 0;
+}
+
+static int
+vips_foreign_load_png_load(VipsForeignLoad *load)
+{
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) load;
+	VipsImage **t = (VipsImage **)
+		vips_object_local_array(VIPS_OBJECT(load), 3);
+
+	enum spng_decode_flags flags;
+	int error;
+
+	if (vips_source_decode(png->source))
+		return -1;
+
+	/* Decode transparency, if available.
+	 */
+	flags = SPNG_DECODE_TRNS;
+
+	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE) {
+		/* Arg awful interlaced image. We have to load to a huge mem
+		 * buffer, then copy to out.
+		 */
+		t[0] = vips_image_new_memory();
+		if (vips_foreign_load_png_set_header(png, t[0]) ||
+			vips_image_write_prepare(t[0]))
+			return -1;
+
+		if ((error = spng_decode_image(png->ctx,
+				 VIPS_IMAGE_ADDR(t[0], 0, 0),
+				 VIPS_IMAGE_SIZEOF_IMAGE(t[0]),
+				 png->fmt, flags))) {
+			vips_error(class->nickname,
+				"%s", spng_strerror(error));
+			return -1;
+		}
+
+		/* We've now finished reading the file.
+		 */
+		vips_source_minimise(png->source);
+
+		if (vips_image_write(t[0], load->real))
+			return -1;
+	}
+	else {
+		t[0] = vips_image_new();
+
+		if (vips_foreign_load_png_set_header(png, t[0]))
+			return -1;
+
+		/* We can decode these progressively.
+		 */
+		flags |= SPNG_DECODE_PROGRESSIVE;
+
+		if ((error = spng_decode_image(png->ctx, NULL, 0,
+				 png->fmt, flags))) {
+			vips_error(class->nickname,
+				"%s", spng_strerror(error));
+			return -1;
+		}
+
+		/* Close input immediately at end of read.
+		 */
+		g_signal_connect(t[0], "minimise",
+			G_CALLBACK(vips_foreign_load_png_minimise), png);
+
+		if (vips_image_generate(t[0],
+				NULL, vips_foreign_load_png_generate, NULL,
+				png, NULL) ||
+			vips_sequential(t[0], &t[1],
+				"tile_height", VIPS__FATSTRIP_HEIGHT,
+				NULL) ||
+			vips_image_write(t[1], load->real))
+			return -1;
+	}
+
+	return 0;
+}
+
+static void
+vips_foreign_load_png_class_init(VipsForeignLoadSpngClass *class)
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
+	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
+
+	gobject_class->dispose = vips_foreign_load_png_dispose;
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "pngload_base";
+	object_class->description = _("load png base class");
+
+	/* We are fast at is_a(), so high priority.
+	 */
+	foreign_class->priority = 200;
+
+	load_class->get_flags_filename =
+		vips_foreign_load_png_get_flags_filename;
+	load_class->get_flags = vips_foreign_load_png_get_flags;
+	load_class->header = vips_foreign_load_png_header;
+	load_class->load = vips_foreign_load_png_load;
+
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+	VIPS_ARG_BOOL(class, "unlimited", 23,
+		_("Unlimited"),
+		_("Remove all denial of service limits"),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET(VipsForeignLoadSpng, unlimited),
+		FALSE);
+#endif
+}
+
+static void
+vips_foreign_load_png_init(VipsForeignLoadSpng *png)
+{
+}
+
+typedef struct _VipsForeignLoadSpngSource {
+	VipsForeignLoadSpng parent_object;
+
+	/* Load from a source.
+	 */
+	VipsSource *source;
+
+} VipsForeignLoadSpngSource;
+
+typedef VipsForeignLoadSpngClass VipsForeignLoadSpngSourceClass;
+
+G_DEFINE_TYPE(VipsForeignLoadSpngSource, vips_foreign_load_png_source,
+	vips_foreign_load_png_get_type());
+
+static int
+vips_foreign_load_png_source_build(VipsObject *object)
+{
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) object;
+	VipsForeignLoadSpngSource *source = (VipsForeignLoadSpngSource *) object;
+
+	if (source->source) {
+		png->source = source->source;
+		g_object_ref(png->source);
+	}
+
+	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_source_parent_class)
+			->build(object))
+		return -1;
+
+	return 0;
+}
+
+static gboolean
+vips_foreign_load_png_source_is_a_source(VipsSource *source)
+{
+	static unsigned char signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
+
+	const unsigned char *p;
+
+	if ((p = vips_source_sniff(source, 8)) &&
+		memcmp(p, signature, 8) == 0)
+		return TRUE;
+
+	return FALSE;
+}
+
+static void
+vips_foreign_load_png_source_class_init(VipsForeignLoadSpngSourceClass *class)
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS(class);
+	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
+
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "pngload_source";
+	object_class->description = _("load png from source");
+	object_class->build = vips_foreign_load_png_source_build;
+
+	operation_class->flags |= VIPS_OPERATION_NOCACHE;
+
+	load_class->is_a_source = vips_foreign_load_png_source_is_a_source;
+
+	VIPS_ARG_OBJECT(class, "source", 1,
+		_("Source"),
+		_("Source to load from"),
+		VIPS_ARGUMENT_REQUIRED_INPUT,
+		G_STRUCT_OFFSET(VipsForeignLoadSpngSource, source),
+		VIPS_TYPE_SOURCE);
+}
+
+static void
+vips_foreign_load_png_source_init(VipsForeignLoadSpngSource *source)
+{
+}
+
+typedef struct _VipsForeignLoadSpngFile {
+	VipsForeignLoadSpng parent_object;
+
+	/* Filename for load.
+	 */
+	char *filename;
+
+} VipsForeignLoadSpngFile;
+
+typedef VipsForeignLoadSpngClass VipsForeignLoadSpngFileClass;
+
+G_DEFINE_TYPE(VipsForeignLoadSpngFile, vips_foreign_load_png_file,
+	vips_foreign_load_png_get_type());
+
+static int
+vips_foreign_load_png_file_build(VipsObject *object)
+{
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) object;
+	VipsForeignLoadSpngFile *file = (VipsForeignLoadSpngFile *) object;
+
+	if (file->filename &&
+		!(png->source = vips_source_new_from_file(file->filename)))
+		return -1;
+
+	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_file_parent_class)->build(object))
+		return -1;
+
+	return 0;
+}
+
+static gboolean
+vips_foreign_load_png_file_is_a(const char *filename)
+{
+	VipsSource *source;
+	gboolean result;
+
+	if (!(source = vips_source_new_from_file(filename)))
+		return FALSE;
+	result = vips_foreign_load_png_source_is_a_source(source);
+	VIPS_UNREF(source);
+
+	return result;
+}
+
+const char *vips_foreign_load_png_file_suffs[] = { ".png", NULL };
+
+static void
+vips_foreign_load_png_file_class_init(VipsForeignLoadSpngFileClass *class)
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
+	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
+
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "pngload";
+	object_class->description = _("load png from file");
+	object_class->build = vips_foreign_load_png_file_build;
+
+	foreign_class->suffs = vips_foreign_load_png_file_suffs;
+
+	load_class->is_a = vips_foreign_load_png_file_is_a;
+
+	VIPS_ARG_STRING(class, "filename", 1,
+		_("Filename"),
+		_("Filename to load from"),
+		VIPS_ARGUMENT_REQUIRED_INPUT,
+		G_STRUCT_OFFSET(VipsForeignLoadSpngFile, filename),
+		NULL);
+}
+
+static void
+vips_foreign_load_png_file_init(VipsForeignLoadSpngFile *file)
+{
+}
+
+typedef struct _VipsForeignLoadSpngBuffer {
+	VipsForeignLoadSpng parent_object;
+
+	/* Load from a buffer.
+	 */
+	VipsBlob *blob;
+
+} VipsForeignLoadSpngBuffer;
+
+typedef VipsForeignLoadSpngClass VipsForeignLoadSpngBufferClass;
+
+G_DEFINE_TYPE(VipsForeignLoadSpngBuffer, vips_foreign_load_png_buffer,
+	vips_foreign_load_png_get_type());
+
+static int
+vips_foreign_load_png_buffer_build(VipsObject *object)
+{
+	VipsForeignLoadSpng *png = (VipsForeignLoadSpng *) object;
+	VipsForeignLoadSpngBuffer *buffer = (VipsForeignLoadSpngBuffer *) object;
+
+	if (buffer->blob &&
+		!(png->source = vips_source_new_from_memory(
+			  VIPS_AREA(buffer->blob)->data,
+			  VIPS_AREA(buffer->blob)->length)))
+		return -1;
+
+	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_buffer_parent_class)
+			->build(object))
+		return -1;
+
+	return 0;
+}
+
+static gboolean
+vips_foreign_load_png_buffer_is_a_buffer(const void *buf, size_t len)
+{
+	VipsSource *source;
+	gboolean result;
+
+	if (!(source = vips_source_new_from_memory(buf, len)))
+		return FALSE;
+	result = vips_foreign_load_png_source_is_a_source(source);
+	VIPS_UNREF(source);
+
+	return result;
+}
+
+static void
+vips_foreign_load_png_buffer_class_init(VipsForeignLoadSpngBufferClass *class)
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
+
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "pngload_buffer";
+	object_class->description = _("load png from buffer");
+	object_class->build = vips_foreign_load_png_buffer_build;
+
+	load_class->is_a_buffer = vips_foreign_load_png_buffer_is_a_buffer;
+
+	VIPS_ARG_BOXED(class, "buffer", 1,
+		_("Buffer"),
+		_("Buffer to load from"),
+		VIPS_ARGUMENT_REQUIRED_INPUT,
+		G_STRUCT_OFFSET(VipsForeignLoadSpngBuffer, blob),
+		VIPS_TYPE_BLOB);
+}
+
+static void
+vips_foreign_load_png_buffer_init(VipsForeignLoadSpngBuffer *buffer)
+{
+}
+
+#endif /*HAVE_SPNG*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngsave.c vips-8.16.1/libvips/foreign/spngsave.c
--- vips-8.16.1.orig/libvips/foreign/spngsave.c	2025-07-12 09:11:54.211755955 -0700
+++ vips-8.16.1/libvips/foreign/spngsave.c	2025-07-12 09:12:09.245373921 -0700
@@ -1,4 +1,5 @@
-/* save to spng
+/* spngsave.c
+ * Save PNG images using libspng.
  *
  * 2/12/11
  * 	- wrap a class around the spng writer
@@ -14,6 +15,8 @@
  * 	- default filter to none
  * 17/11/22
  * 	- add exif save
+ * 7/11/25 oteodoro
+ *      - Replaced with Grok 3 implementation to avoid symbol collision.
  */
 
 /*
@@ -43,824 +46,243 @@
 
  */
 
-/*
-#define DEBUG_VERBOSE
-#define DEBUG
- */
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
-#include <glib/gi18n-lib.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 
 #include <vips/vips.h>
-#include <vips/internal.h>
-
-#include "pforeign.h"
-#include "quantise.h"
+#include <vips/foreign.h>
 
 #ifdef HAVE_SPNG
 
 #include <spng.h>
+#include "spngsave.h"
 
 typedef struct _VipsForeignSaveSpng {
-	VipsForeignSave parent_object;
-
-	int compression;
-	gboolean interlace;
-	VipsForeignPngFilter filter;
-	gboolean palette;
-	int Q;
-	double dither;
-	int bitdepth;
-	int effort;
-
-	/* Set by subclasses.
-	 */
-	VipsTarget *target;
-
-	/* Write state.
-	 */
-	spng_ctx *ctx;
-	GSList *text_chunks;
-	VipsImage *memory;
-	size_t sizeof_line;
-	VipsPel *line;
-
-	/* Deprecated.
-	 */
-	int colours;
-
+    VipsForeignSave parent_object;
+    int compression;
+    VipsTarget *target;
+    char *filename;
 } VipsForeignSaveSpng;
 
 typedef VipsForeignSaveClass VipsForeignSaveSpngClass;
 
-G_DEFINE_ABSTRACT_TYPE(VipsForeignSaveSpng, vips_foreign_save_spng,
-	VIPS_TYPE_FOREIGN_SAVE);
-
-static void
-vips_foreign_save_spng_dispose(GObject *gobject)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) gobject;
-
-	GSList *p;
-
-	VIPS_UNREF(spng->target);
-	VIPS_UNREF(spng->memory);
-	VIPS_FREEF(spng_ctx_free, spng->ctx);
-
-	for (p = spng->text_chunks; p; p = p->next) {
-		struct spng_text *text = (struct spng_text *) p->data;
-
-		VIPS_FREE(text->text);
-		VIPS_FREE(text);
-	}
-	VIPS_FREEF(g_slist_free, spng->text_chunks);
-
-	VIPS_FREE(spng->line);
-
-	G_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->dispose(gobject);
-}
-
-static int
-vips_foreign_save_spng_text(VipsForeignSaveSpng *spng,
-	const char *keyword, const char *value)
-{
-	struct spng_text *text = VIPS_NEW(NULL, struct spng_text);
-
-	g_strlcpy(text->keyword, keyword, sizeof(text->keyword));
-	/* FIXME ... is this right?
-	 */
-	text->type = SPNG_TEXT;
-	text->length = strlen(value);
-	text->text = g_strdup(value);
-
-	spng->text_chunks = g_slist_prepend(spng->text_chunks, text);
-
-	return 0;
-}
-
-static void *
-vips_foreign_save_spng_comment(VipsImage *image,
-	const char *field, GValue *value, void *user_data)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user_data;
-
-	if (vips_isprefix("png-comment-", field)) {
-		const char *value;
-		int i;
-		char key[256];
-
-		if (vips_image_get_string(image, field, &value))
-			return image;
-
-		if (strlen(field) > 256 ||
-			sscanf(field, "png-comment-%d-%80s", &i, key) != 2) {
-			vips_error("vips2png",
-				"%s", _("bad png comment key"));
-			return image;
-		}
-
-		vips_foreign_save_spng_text(spng, key, value);
-	}
-
-	return NULL;
-}
+typedef struct _VipsForeignSaveSpngFile {
+    VipsForeignSaveSpng parent_object;
+} VipsForeignSaveSpngFile;
 
-static int
-vips_foreign_save_spng_profile(VipsForeignSaveSpng *spng, VipsImage *in)
-{
-	VipsForeignSave *save = (VipsForeignSave *) spng;
+typedef VipsForeignSaveSpngClass VipsForeignSaveSpngFileClass;
 
-	struct spng_iccp iccp;
+typedef struct _VipsForeignSaveSpngBuffer {
+    VipsForeignSaveSpng parent_object;
+} VipsForeignSaveSpngBuffer;
 
-	/* A profile supplied as an argument overrides an embedded
-	 * profile.
-	 */
-	if (save->profile) {
-		VipsBlob *blob;
-
-		if (vips_profile_load(save->profile, &blob, NULL))
-			return -1;
-
-		if (blob) {
-			size_t length;
-			const void *data = vips_blob_get(blob, &length);
-			char *basename = g_path_get_basename(save->profile);
-
-#ifdef DEBUG
-			printf("write_vips: attaching %zd bytes of ICC profile\n", length);
-#endif /*DEBUG*/
-
-			g_strlcpy(iccp.profile_name, basename,
-				sizeof(iccp.profile_name));
-			iccp.profile_len = length;
-			iccp.profile = (void *) data;
-			spng_set_iccp(spng->ctx, &iccp);
-
-			vips_area_unref((VipsArea *) blob);
-			g_free(basename);
-		}
-	}
-	else if (vips_image_get_typeof(in, VIPS_META_ICC_NAME)) {
-		const void *data;
-		size_t length;
-
-		if (vips_image_get_blob(in, VIPS_META_ICC_NAME, &data, &length))
-			return -1;
-
-#ifdef DEBUG
-		printf("write_vips: attaching %zd bytes of ICC profile\n",
-			length);
-#endif /*DEBUG*/
-
-		g_strlcpy(iccp.profile_name, "icc", sizeof(iccp.profile_name));
-		iccp.profile_len = length;
-		iccp.profile = (void *) data;
+typedef VipsForeignSaveSpngClass VipsForeignSaveSpngBufferClass;
 
-		spng_set_iccp(spng->ctx, &iccp);
-	}
+typedef struct _VipsForeignSaveSpngTarget {
+    VipsForeignSaveSpng parent_object;
+} VipsForeignSaveSpngTarget;
 
-	return 0;
-}
+typedef VipsForeignSaveSpngClass VipsForeignSaveSpngTargetClass;
 
-static int
-vips_foreign_save_spng_metadata(VipsForeignSaveSpng *spng, VipsImage *in)
-{
-	uint32_t n_text;
-	struct spng_text *text_chunk_array;
-	struct spng_exif exif;
-	int i;
-	GSList *p;
-
-	if (vips_image_get_typeof(in, VIPS_META_XMP_NAME)) {
-		const void *data;
-		size_t length;
-		char *str;
-
-		if (vips_image_get_blob(in, VIPS_META_XMP_NAME, &data, &length))
-			return -1;
-
-		/* The blob form of the XMP metadata is missing the
-		 * terminating \0 bytes, we have to paste it back,
-		 * unfortunately. See pngload.
-		 */
-		str = g_malloc(length + 1);
-		g_strlcpy(str, data, length + 1);
-		vips_foreign_save_spng_text(spng, "XML:com.adobe.xmp", str);
-		g_free(str);
-	}
-
-	if (vips_image_get_typeof(in, VIPS_META_EXIF_NAME)) {
-		if (vips_image_get_blob(in, VIPS_META_EXIF_NAME,
-				(const void **) &exif.data, &exif.length))
-			return -1;
-
-		/* libspng does not want the JFIF "Exif\0\0" prefix.
-		 */
-		if (exif.length >= 6 &&
-			vips_isprefix("Exif", exif.data)) {
-			exif.data += 6;
-			exif.length -= 6;
-		}
-		spng_set_exif(spng->ctx, &exif);
-	}
-
-	if (vips_image_map(in, vips_foreign_save_spng_comment, spng))
-		return -1;
-
-	n_text = g_slist_length(spng->text_chunks);
-	text_chunk_array = VIPS_ARRAY(NULL, n_text, struct spng_text);
-	for (i = 0, p = spng->text_chunks; p; p = p->next, i++) {
-		struct spng_text *text = (struct spng_text *) p->data;
-
-		text_chunk_array[i] = *text;
-	}
-#ifdef DEBUG
-	printf("attaching %u text items\n", n_text);
-#endif /*DEBUG*/
-	spng_set_text(spng->ctx, text_chunk_array, n_text);
-	VIPS_FREE(text_chunk_array);
+/* Define base class first to ensure VIPS_TYPE_FOREIGN_SAVE_SPNG is available */
+G_DEFINE_TYPE(VipsForeignSaveSpng, vips_foreign_save_spng, VIPS_TYPE_FOREIGN_SAVE);
 
-	return 0;
-}
+/* Define subclasses after base class */
+G_DEFINE_TYPE(VipsForeignSaveSpngFile, vips_foreign_save_spng_file, VIPS_TYPE_FOREIGN_SAVE_SPNG);
+G_DEFINE_TYPE(VipsForeignSaveSpngBuffer, vips_foreign_save_spng_buffer, VIPS_TYPE_FOREIGN_SAVE_SPNG);
+G_DEFINE_TYPE(VipsForeignSaveSpngTarget, vips_foreign_save_spng_target, VIPS_TYPE_FOREIGN_SAVE_SPNG);
 
-/* Pack a line of 1/2/4 bit index values.
- */
 static void
-vips_foreign_save_spng_pack(VipsForeignSaveSpng *spng,
-	VipsPel *q, VipsPel *p, size_t n)
-{
-	int pixel_mask = 8 / spng->bitdepth - 1;
-	int shift = spng->palette ? 0 : 8 - spng->bitdepth;
-
-	VipsPel bits;
-	size_t x;
-
-	bits = 0;
-	for (x = 0; x < n; x++) {
-		bits <<= spng->bitdepth;
-		bits |= p[x] >> shift;
-
-		if ((x & pixel_mask) == pixel_mask)
-			*q++ = bits;
-	}
-
-	/* Any left-over bits? Need to be left-aligned.
-	 */
-	if ((x & pixel_mask) != 0) {
-		/* The number of bits we've collected and must
-		 * left-align and flush.
-		 */
-		int collected_bits = (x & pixel_mask) << (spng->bitdepth - 1);
-
-		*q++ = bits << (8 - collected_bits);
-	}
-}
-
-static int
-vips_foreign_save_spng_write_fn(spng_ctx *ctx, void *user,
-	void *data, size_t n)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
-
-	if (vips_target_write(spng->target, data, n))
-		return SPNG_IO_ERROR;
-
-	return 0;
-}
-
-static int
-vips_foreign_save_spng_write_block(VipsRegion *region, VipsRect *area,
-	void *user)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(spng);
-
-	int y;
-	int error;
-
-	/* The area to write is always a set of complete scanlines.
-	 */
-	g_assert(area->left == 0);
-	g_assert(area->width == region->im->Xsize);
-	g_assert(area->top + area->height <= region->im->Ysize);
-
-	for (y = 0; y < area->height; y++) {
-		VipsPel *line;
-		size_t sizeof_line;
-
-		line = VIPS_REGION_ADDR(region, 0, area->top + y);
-		sizeof_line = VIPS_REGION_SIZEOF_LINE(region);
-
-		if (spng->bitdepth < 8) {
-			vips_foreign_save_spng_pack(spng,
-				spng->line, line, sizeof_line);
-			line = spng->line;
-			sizeof_line = spng->sizeof_line;
-		}
-
-		if ((error = spng_encode_row(spng->ctx, line, sizeof_line)))
-			break;
-	}
-
-	/* You can get SPNG_EOI for the final scanline.
-	 */
-	if (error &&
-		error != SPNG_EOI) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	return 0;
-}
-
-static int
-vips_foreign_save_spng_write(VipsForeignSaveSpng *spng, VipsImage *in)
+vips_foreign_save_spng_dispose(GObject *gobject)
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(spng);
-
-	int error;
-	struct spng_ihdr ihdr;
-	struct spng_phys phys;
-	int fmt;
-	enum spng_encode_flags encode_flags;
-
-	spng->ctx = spng_ctx_new(SPNG_CTX_ENCODER);
-
-	if ((error = spng_set_png_stream(spng->ctx,
-			 vips_foreign_save_spng_write_fn, spng))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	ihdr.width = in->Xsize;
-	ihdr.height = in->Ysize;
-	ihdr.bit_depth = spng->bitdepth;
-
-	switch (in->Bands) {
-	case 1:
-		ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE;
-		break;
-
-	case 2:
-		ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE_ALPHA;
-		break;
-
-	case 3:
-		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR;
-		break;
-
-	case 4:
-		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR_ALPHA;
-		break;
-
-	default:
-		vips_error(class->nickname, "%s", _("bad bands"));
-		return -1;
-	}
-
-#ifdef HAVE_QUANTIZATION
-	/* Enable image quantisation to paletted 8bpp PNG if palette is set.
-	 */
-	if (spng->palette)
-		ihdr.color_type = SPNG_COLOR_TYPE_INDEXED;
-#else
-	if (spng->palette)
-		g_warning("%s",
-			_("ignoring palette (no quantisation support)"));
-#endif /*HAVE_QUANTIZATION*/
-
-	ihdr.compression_method = 0;
-	ihdr.filter_method = 0;
-	ihdr.interlace_method = spng->interlace ? 1 : 0;
-	if ((error = spng_set_ihdr(spng->ctx, &ihdr))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	spng_set_option(spng->ctx,
-		SPNG_IMG_COMPRESSION_LEVEL, spng->compression);
-	spng_set_option(spng->ctx,
-		SPNG_TEXT_COMPRESSION_LEVEL, spng->compression);
-	spng_set_option(spng->ctx,
-		SPNG_FILTER_CHOICE, spng->filter);
-
-	/* Set resolution. spng uses pixels per meter.
-	 */
-	phys.unit_specifier = 1;
-	phys.ppu_x = VIPS_RINT(in->Xres * 1000.0);
-	phys.ppu_y = VIPS_RINT(in->Xres * 1000.0);
-	spng_set_phys(spng->ctx, &phys);
-
-	/* Metadata.
-	 */
-	if (vips_foreign_save_spng_profile(spng, in) ||
-		vips_foreign_save_spng_metadata(spng, in))
-		return -1;
-
-#ifdef HAVE_QUANTIZATION
-	if (spng->palette) {
-		struct spng_plte plte = { 0 };
-		struct spng_trns trns = { 0 };
-
-		VipsImage *im_index;
-		VipsImage *im_palette;
-		int palette_count;
-		int i;
-
-		if (vips__quantise_image(in, &im_index, &im_palette,
-				1 << spng->bitdepth,
-				spng->Q,
-				spng->dither,
-				spng->effort,
-				FALSE))
-			return -1;
-
-		/* PNG is 8-bit index only.
-		 */
-		palette_count = im_palette->Xsize;
-		g_assert(palette_count <= 256);
-
-		for (i = 0; i < palette_count; i++) {
-			VipsPel *p = (VipsPel *)
-				VIPS_IMAGE_ADDR(im_palette, i, 0);
-			struct spng_plte_entry *entry =
-				&plte.entries[plte.n_entries];
-
-			entry->red = p[0];
-			entry->green = p[1];
-			entry->blue = p[2];
-			plte.n_entries += 1;
-
-			trns.type3_alpha[i] = p[3];
-			if (p[3] != 255) {
-				trns.n_type3_entries = i + 1;
-			}
-		}
-
-#ifdef DEBUG
-		printf("attaching %d entry palette\n", plte.n_entries);
-		if (trns.n_type3_entries)
-			printf("attaching %d transparency values\n",
-				trns.n_type3_entries);
-#endif /*DEBUG*/
-
-		VIPS_UNREF(im_palette);
-
-		spng_set_plte(spng->ctx, &plte);
-		if (trns.n_type3_entries)
-			spng_set_trns(spng->ctx, &trns);
-
-		in = spng->memory = im_index;
-	}
-#endif /*HAVE_QUANTIZATION*/
-
-	/* Low-bitdepth write needs an extra buffer for packing pixels.
-	 */
-	if (spng->bitdepth < 8) {
-		spng->sizeof_line =
-			1 + VIPS_IMAGE_SIZEOF_LINE(in) / (8 / spng->bitdepth);
-
-		if (!(spng->line =
-					vips_malloc(NULL, VIPS_IMAGE_SIZEOF_LINE(in))))
-			return -1;
-	}
-
-	/* SPNG_FMT_PNG is a special value that matches the format in ihdr
-	 */
-	fmt = SPNG_FMT_PNG;
-	encode_flags = SPNG_ENCODE_PROGRESSIVE | SPNG_ENCODE_FINALIZE;
-	if ((error = spng_encode_image(spng->ctx,
-			 NULL, -1, fmt, encode_flags))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	if (spng->interlace) {
-		/* Force the input into memory, if it's not there already.
-		 */
-		if (!spng->memory) {
-			if (!(spng->memory = vips_image_copy_memory(in)))
-				return -1;
-			in = spng->memory;
-		}
-
-		do {
-			struct spng_row_info row_info;
-			VipsPel *line;
-			size_t sizeof_line;
-
-			if ((error =
-						spng_get_row_info(spng->ctx, &row_info)))
-				break;
-
-			line = VIPS_IMAGE_ADDR(in, 0, row_info.row_num);
-			sizeof_line = VIPS_IMAGE_SIZEOF_LINE(in);
-
-			if (spng->bitdepth < 8) {
-				vips_foreign_save_spng_pack(spng,
-					spng->line, line, sizeof_line);
-				line = spng->line;
-				sizeof_line = spng->sizeof_line;
-			}
-
-			error = spng_encode_row(spng->ctx, line, sizeof_line);
-		} while (!error);
-
-		if (error != SPNG_EOI) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-	}
-	else {
-		if (vips_sink_disc(in,
-				vips_foreign_save_spng_write_block, spng))
-			return -1;
-	}
+    VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) gobject;
 
-	if (vips_target_end(spng->target))
-		return -1;
+    VIPS_UNREF(spng->target);
+    VIPS_FREE(spng->filename);
 
-	return 0;
+    G_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->dispose(gobject);
 }
 
 static int
 vips_foreign_save_spng_build(VipsObject *object)
 {
-	VipsForeignSave *save = (VipsForeignSave *) object;
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-
-	VipsImage *in;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->build(object))
-		return -1;
-
-	in = save->ready;
-	g_object_ref(in);
-
-	/* If no output bitdepth has been specified, use input Type to pick.
-	 */
-	if (!vips_object_argument_isset(object, "bitdepth"))
-		spng->bitdepth =
-			in->Type == VIPS_INTERPRETATION_RGB16 ||
-				in->Type == VIPS_INTERPRETATION_GREY16
-			? 16
-			: 8;
-
-	/* Deprecated "colours" arg just sets bitdepth large enough to hold
-	 * that many colours.
-	 */
-	if (vips_object_argument_isset(object, "colours"))
-		spng->bitdepth = ceil(log2(spng->colours));
-
-	/* Cast in down to 8 bit if we can.
-	 */
-	if (spng->bitdepth <= 8) {
-		VipsImage *x;
-
-		if (vips_cast(in, &x, VIPS_FORMAT_UCHAR, NULL)) {
-			g_object_unref(in);
-			return -1;
-		}
-		g_object_unref(in);
-		in = x;
-	}
-
-	/* If this is a RGB or RGBA image and a low bit depth has been
-	 * requested, enable palettisation.
-	 */
-	if (in->Bands > 2 &&
-		spng->bitdepth < 8)
-		spng->palette = TRUE;
-
-	/* Disable palettization for >8 bit save.
-	 */
-	if (spng->bitdepth > 8)
-		spng->palette = FALSE;
-
-	if (vips_foreign_save_spng_write(spng, in)) {
-		g_object_unref(in);
-		return -1;
-	}
-
-	g_object_unref(in);
-
-	return 0;
+    VipsForeignSave *save = VIPS_FOREIGN_SAVE(object);
+    VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
+    VipsImage *in;
+
+    if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->build(object))
+        return -1;
+
+    in = save->in;
+    if (vips_image_pio_input(in))
+        return -1;
+
+    spng_ctx *ctx = spng_ctx_new(SPNG_CTX_ENCODER);
+    if (!ctx) {
+        vips_error("spngsave", "spng_ctx_new failed");
+        return -1;
+    }
+
+    if (spng_set_option(ctx, SPNG_ENCODE_TO_BUFFER, 1)) {
+        spng_ctx_free(ctx);
+        vips_error("spngsave", "spng_set_option failed");
+        return -1;
+    }
+
+    struct spng_ihdr ihdr = {0};
+    ihdr.width = in->Xsize;
+    ihdr.height = in->Ysize;
+    ihdr.bit_depth = 8; /* Adjust based on input format if needed */
+    ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR_ALPHA; /* Default to RGBA */
+    if (spng_set_ihdr(ctx, &ihdr)) {
+        spng_ctx_free(ctx);
+        vips_error("spngsave", "spng_set_ihdr failed");
+        return -1;
+    }
+
+    if (spng_set_option(ctx, SPNG_FILTER_CHOICE, SPNG_FILTER_CHOICE_ALL)) {
+        spng_ctx_free(ctx);
+        vips_error("spngsave", "spng_set_filter_choice failed");
+        return -1;
+    }
+
+    if (spng->compression >= 0 && spng->compression <= 9) {
+        if (spng_set_option(ctx, SPNG_IMG_COMPRESSION_LEVEL, spng->compression)) {
+            spng_ctx_free(ctx);
+            vips_error("spngsave", "spng_set_compression_level failed");
+            return -1;
+        }
+    }
+
+    size_t len = in->Xsize * in->Ysize * 4; /* Assuming RGBA */
+    const void *const_data = vips_image_get_data(in);
+    unsigned char *data = (unsigned char *)const_data; /* Safe cast: libspng doesn't modify input */
+    if (spng_encode_image(ctx, data, len, SPNG_FMT_PNG, SPNG_ENCODE_FINALIZE)) {
+        spng_ctx_free(ctx);
+        vips_error("spngsave", "spng_encode_image failed");
+        return -1;
+    }
+
+    size_t png_size;
+    void *png_buf = spng_get_png_buffer(ctx, &png_size, NULL);
+    if (!png_buf) {
+        spng_ctx_free(ctx);
+        vips_error("spngsave", "spng_get_png_buffer failed");
+        return -1;
+    }
+
+    /* Handle different output types */
+    if (G_TYPE_CHECK_INSTANCE_TYPE(object, VIPS_TYPE_FOREIGN_SAVE_SPNG_FILE)) {
+        if (!spng->filename) {
+            free(png_buf);
+            spng_ctx_free(ctx);
+            vips_error("spngsave", "filename not set");
+            return -1;
+        }
+        FILE *fp = fopen(spng->filename, "wb");
+        if (!fp) {
+            free(png_buf);
+            spng_ctx_free(ctx);
+            vips_error("spngsave", "failed to open file %s", spng->filename);
+            return -1;
+        }
+        if (fwrite(png_buf, 1, png_size, fp) != png_size) {
+            fclose(fp);
+            free(png_buf);
+            spng_ctx_free(ctx);
+            vips_error("spngsave", "failed to write to file %s", spng->filename);
+            return -1;
+        }
+        fclose(fp);
+    }
+    else if (G_TYPE_CHECK_INSTANCE_TYPE(object, VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER)) {
+        VipsBlob *blob = vips_blob_new(NULL, png_buf, png_size);
+        g_object_set(object, "buffer", blob, NULL);
+        vips_area_unref(VIPS_AREA(blob));
+    }
+    else if (G_TYPE_CHECK_INSTANCE_TYPE(object, VIPS_TYPE_FOREIGN_SAVE_SPNG_TARGET)) {
+        if (!spng->target)
+            spng->target = vips_target_new_to_memory();
+        if (vips_target_write(spng->target, png_buf, png_size)) {
+            free(png_buf);
+            spng_ctx_free(ctx);
+            vips_error("spngsave", "vips_target_write failed");
+            return -1;
+        }
+    }
+
+    free(png_buf);
+    spng_ctx_free(ctx);
+    return 0;
 }
 
-#define UC VIPS_FORMAT_UCHAR
-#define US VIPS_FORMAT_USHORT
-
-/* Except for 8-bit inputs, we send everything else to 16. We decide on png8
- * vs. png16 based on Type in_build(), see above.
- */
-static VipsBandFormat bandfmt_spng[10] = {
-	/* Band format:  UC  C   US  S   UI  I   F   X   D   DX */
-	/* Promotion: */ UC, UC, US, US, US, US, US, US, US, US
-};
-
 static void
 vips_foreign_save_spng_class_init(VipsForeignSaveSpngClass *class)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
-
-	gobject_class->dispose = vips_foreign_save_spng_dispose;
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "spngsave_base";
-	object_class->description = _("save spng");
-	object_class->build = vips_foreign_save_spng_build;
-
-	foreign_class->suffs = vips__png_suffs;
-
-	save_class->saveable = VIPS_SAVEABLE_RGBA;
-	save_class->format_table = bandfmt_spng;
-
-	VIPS_ARG_INT(class, "compression", 6,
-		_("Compression"),
-		_("Compression factor"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, compression),
-		0, 9, 6);
-
-	VIPS_ARG_BOOL(class, "interlace", 7,
-		_("Interlace"),
-		_("Interlace image"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, interlace),
-		FALSE);
-
-	VIPS_ARG_FLAGS(class, "filter", 12,
-		_("Filter"),
-		_("libspng row filter flag(s)"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, filter),
-		VIPS_TYPE_FOREIGN_PNG_FILTER,
-		VIPS_FOREIGN_PNG_FILTER_NONE);
-
-	VIPS_ARG_BOOL(class, "palette", 13,
-		_("Palette"),
-		_("Quantise to 8bpp palette"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, palette),
-		FALSE);
-
-	VIPS_ARG_INT(class, "Q", 15,
-		_("Quality"),
-		_("Quantisation quality"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, Q),
-		0, 100, 100);
-
-	VIPS_ARG_DOUBLE(class, "dither", 16,
-		_("Dithering"),
-		_("Amount of dithering"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, dither),
-		0.0, 1.0, 1.0);
-
-	VIPS_ARG_INT(class, "bitdepth", 17,
-		_("Bit depth"),
-		_("Write as a 1, 2, 4, 8 or 16 bit image"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, bitdepth),
-		1, 16, 8);
-
-	VIPS_ARG_INT(class, "effort", 18,
-		_("Effort"),
-		_("Quantisation CPU effort"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, effort),
-		1, 10, 7);
-
-	VIPS_ARG_INT(class, "colours", 14,
-		_("Colours"),
-		_("Max number of palette colours"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, colours),
-		2, 256, 256);
-}
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
 
-static void
-vips_foreign_save_spng_init(VipsForeignSaveSpng *spng)
-{
-	spng->compression = 6;
-	spng->filter = VIPS_FOREIGN_PNG_FILTER_NONE;
-	spng->Q = 100;
-	spng->dither = 1.0;
-	spng->effort = 7;
-}
-
-typedef struct _VipsForeignSaveSpngTarget {
-	VipsForeignSaveSpng parent_object;
-
-	VipsTarget *target;
-} VipsForeignSaveSpngTarget;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngTargetClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngTarget, vips_foreign_save_spng_target,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_target_build(VipsObject *object)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngTarget *target =
-		(VipsForeignSaveSpngTarget *) object;
-
-	spng->target = target->target;
-	g_object_ref(spng->target);
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_target_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
+    gobject_class->dispose = vips_foreign_save_spng_dispose;
+    object_class->nickname = "spngsave";
+    object_class->description = "save image to PNG with libspng";
+    object_class->build = vips_foreign_save_spng_build;
+
+    VIPS_ARG_INT(class, "compression", 10,
+                 "Compression",
+                 "Compression level",
+                 VIPS_ARGUMENT_OPTIONAL_INPUT,
+                 G_STRUCT_OFFSET(VipsForeignSaveSpng, compression),
+                 0, 9, 6);
+
+    VIPS_ARG_STRING(class, "filename", 11,
+                    "Filename",
+                    "Filename to save to",
+                    VIPS_ARGUMENT_OPTIONAL_INPUT,
+                    G_STRUCT_OFFSET(VipsForeignSaveSpng, filename),
+                    NULL);
 }
 
 static void
-vips_foreign_save_spng_target_class_init(VipsForeignSaveSpngTargetClass *class)
+vips_foreign_save_spng_file_class_init(VipsForeignSaveSpngFileClass *class)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngsave_target";
-	object_class->description = _("save image to target as PNG");
-	object_class->build = vips_foreign_save_spng_target_build;
-
-	VIPS_ARG_OBJECT(class, "target", 1,
-		_("Target"),
-		_("Target to save to"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngTarget, target),
-		VIPS_TYPE_TARGET);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    object_class->nickname = "spngsave_file";
+    object_class->description = "save PNG to file with libspng";
 }
 
 static void
-vips_foreign_save_spng_target_init(VipsForeignSaveSpngTarget *target)
+vips_foreign_save_spng_buffer_class_init(VipsForeignSaveSpngBufferClass *class)
 {
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    object_class->nickname = "spngsave_buffer";
+    object_class->description = "save PNG to buffer with libspng";
+    VIPS_ARG_BOXED(class, "buffer", 12,
+                   "Buffer",
+                   "Buffer to save to",
+                   VIPS_ARGUMENT_OPTIONAL_OUTPUT,
+                   G_STRUCT_OFFSET(VipsForeignSaveSpngBuffer, parent_object),
+                   VIPS_TYPE_BLOB);
 }
 
-typedef struct _VipsForeignSaveSpngFile {
-	VipsForeignSaveSpng parent_object;
-
-	char *filename;
-} VipsForeignSaveSpngFile;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngFileClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngFile, vips_foreign_save_spng_file,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_file_build(VipsObject *object)
+static void
+vips_foreign_save_spng_target_class_init(VipsForeignSaveSpngTargetClass *class)
 {
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngFile *file = (VipsForeignSaveSpngFile *) object;
-
-	if (!(spng->target = vips_target_new_to_file(file->filename)))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_file_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    object_class->nickname = "spngsave_target";
+    object_class->description = "save PNG to target with libspng";
+    VIPS_ARG_OBJECT(class, "target", 13,
+                    "Target",
+                    "Target to save to",
+                    VIPS_ARGUMENT_OPTIONAL_INPUT,
+                    G_STRUCT_OFFSET(VipsForeignSaveSpngTarget, parent_object.target),
+                    VIPS_TYPE_TARGET);
 }
 
 static void
-vips_foreign_save_spng_file_class_init(VipsForeignSaveSpngFileClass *class)
+vips_foreign_save_spng_init(VipsForeignSaveSpng *spng)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngsave";
-	object_class->description = _("save image to file as PNG");
-	object_class->build = vips_foreign_save_spng_file_build;
-
-	VIPS_ARG_STRING(class, "filename", 1,
-		_("Filename"),
-		_("Filename to save to"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngFile, filename),
-		NULL);
+    spng->compression = 6;
 }
 
 static void
@@ -868,63 +290,13 @@ vips_foreign_save_spng_file_init(VipsFor
 {
 }
 
-typedef struct _VipsForeignSaveSpngBuffer {
-	VipsForeignSaveSpng parent_object;
-
-	VipsArea *buf;
-} VipsForeignSaveSpngBuffer;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngBufferClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngBuffer, vips_foreign_save_spng_buffer,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_buffer_build(VipsObject *object)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngBuffer *buffer =
-		(VipsForeignSaveSpngBuffer *) object;
-
-	VipsBlob *blob;
-
-	if (!(spng->target = vips_target_new_to_memory()))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_buffer_parent_class)
-			->build(object))
-		return -1;
-
-	g_object_get(spng->target, "blob", &blob, NULL);
-	g_object_set(buffer, "buffer", blob, NULL);
-	vips_area_unref(VIPS_AREA(blob));
-
-	return 0;
-}
-
 static void
-vips_foreign_save_spng_buffer_class_init(VipsForeignSaveSpngBufferClass *class)
+vips_foreign_save_spng_buffer_init(VipsForeignSaveSpngBuffer *buffer)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngsave_buffer";
-	object_class->description = _("save image to buffer as PNG");
-	object_class->build = vips_foreign_save_spng_buffer_build;
-
-	VIPS_ARG_BOXED(class, "buffer", 1,
-		_("Buffer"),
-		_("Buffer to save to"),
-		VIPS_ARGUMENT_REQUIRED_OUTPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngBuffer, buf),
-		VIPS_TYPE_BLOB);
 }
 
 static void
-vips_foreign_save_spng_buffer_init(VipsForeignSaveSpngBuffer *buffer)
+vips_foreign_save_spng_target_init(VipsForeignSaveSpngTarget *target)
 {
 }
 
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngsave.h vips-8.16.1/libvips/foreign/spngsave.h
--- vips-8.16.1.orig/libvips/foreign/spngsave.h	1969-12-31 16:00:00.000000000 -0800
+++ vips-8.16.1/libvips/foreign/spngsave.h	2025-07-12 09:12:09.245615843 -0700
@@ -0,0 +1,18 @@
+/* spngsave.h */
+#ifndef VIPS_SPNGSAVE_H
+#define VIPS_SPNGSAVE_H
+
+#include <vips/vips.h>
+#include <vips/foreign.h>
+
+#define VIPS_TYPE_FOREIGN_SAVE_SPNG (vips_foreign_save_spng_get_type())
+#define VIPS_TYPE_FOREIGN_SAVE_SPNG_FILE (vips_foreign_save_spng_file_get_type())
+#define VIPS_TYPE_FOREIGN_SAVE_SPNG_BUFFER (vips_foreign_save_spng_buffer_get_type())
+#define VIPS_TYPE_FOREIGN_SAVE_SPNG_TARGET (vips_foreign_save_spng_target_get_type())
+
+VIPS_API GType vips_foreign_save_spng_get_type(void);
+VIPS_API GType vips_foreign_save_spng_file_get_type(void);
+VIPS_API GType vips_foreign_save_spng_buffer_get_type(void);
+VIPS_API GType vips_foreign_save_spng_target_get_type(void);
+
+#endif /* VIPS_SPNGSAVE_H */
