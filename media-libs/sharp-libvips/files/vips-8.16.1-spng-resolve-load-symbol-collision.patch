diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/foreign.c vips-8.16.1/libvips/foreign/foreign.c
--- vips-8.16.1.orig/libvips/foreign/foreign.c	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/foreign.c	2025-07-13 02:23:09.712464875 -0700
@@ -72,6 +72,10 @@
 #include <vips/debug.h>
 
 #include "pforeign.h"
+#ifdef HAVE_SPNG
+#include "spngload.h"
+#include "spngsave.h"
+#endif
 
 /**
  * SECTION: foreign
@@ -2960,6 +2964,9 @@ vips_foreign_operation_init(void)
 	extern GType vips_foreign_save_png_buffer_get_type(void);
 	extern GType vips_foreign_save_png_target_get_type(void);
 
+	extern GType vips_foreign_load_spng_file_get_type(void);
+	extern GType vips_foreign_load_spng_buffer_get_type(void);
+	extern GType vips_foreign_load_spng_source_get_type(void);
 	extern GType vips_foreign_save_spng_file_get_type(void);
 	extern GType vips_foreign_save_spng_buffer_get_type(void);
 	extern GType vips_foreign_save_spng_target_get_type(void);
@@ -3186,12 +3193,10 @@ vips_foreign_operation_init(void)
 #endif /*HAVE_PNG*/
 
 #ifdef HAVE_SPNG
-	vips_foreign_load_png_file_get_type();
-	vips_foreign_load_png_buffer_get_type();
-	vips_foreign_load_png_source_get_type();
-	vips_foreign_save_spng_file_get_type();
-	vips_foreign_save_spng_buffer_get_type();
-	vips_foreign_save_spng_target_get_type();
+        vips__foreign_load_operation = g_slist_prepend(vips__foreign_load_operation,
+            GINT_TO_POINTER(vips_foreign_load_spng_get_type()));
+        g_type_ensure(vips_foreign_load_spng_get_type());
+        g_type_ensure(vips_foreign_save_spng_get_type());
 #endif /*HAVE_SPNG*/
 
 #ifdef HAVE_MATIO
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/meson.build vips-8.16.1/libvips/foreign/meson.build
--- vips-8.16.1.orig/libvips/foreign/meson.build	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/meson.build	2025-07-13 02:23:09.713717361 -0700
@@ -44,8 +44,6 @@ foreign_sources = files(
     'radsave.c',
     'rawload.c',
     'rawsave.c',
-    'spngload.c',
-    'spngsave.c',
     'svgload.c',
     'tiff2vips.c',
     'tiff.c',
@@ -61,6 +59,10 @@ foreign_sources = files(
     'webpsave.c',
 )
 
+if spng_dep.found()
+    foreign_sources += ['spngload.c', 'spngsave.c']
+endif
+
 foreign_headers = files(
     'dbh.h',
     'jpeg.h',
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngload.c vips-8.16.1/libvips/foreign/spngload.c
--- vips-8.16.1.orig/libvips/foreign/spngload.c	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/spngload.c	2025-07-13 02:24:26.726398230 -0700
@@ -1,4 +1,5 @@
-/* load PNG with libspng
+/* spngload.c
+ * Load PNG images using libspng.
  *
  * 1/5/20
  * 	- from pngload.c
@@ -8,6 +9,8 @@
  *	-  add "unlimited" flag to png load
  * 3/2/23 MathemanFlo
  * 	- add bits per sample metadata
+ * 7/11/25 oteodoro
+ *      - Replaced with Grok 3 implementation to avoid symbol collision.
  */
 
 /*
@@ -37,887 +40,366 @@
 
  */
 
-/*
-#define DEBUG
- */
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
-#include <glib/gi18n-lib.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 
 #include <vips/vips.h>
-#include <vips/buf.h>
-#include <vips/internal.h>
-
-#include "pforeign.h"
+#include <stdio.h>
 
 #ifdef HAVE_SPNG
 
 #include <spng.h>
+#include "spngload.h"
 
-typedef struct _VipsForeignLoadPng {
-	VipsForeignLoad parent_object;
-
-	/* Set by subclasses.
-	 */
-	VipsSource *source;
-
-	/* Remove DoS limits.
-	 */
-	gboolean unlimited;
-
-	spng_ctx *ctx;
-	struct spng_ihdr ihdr;
-	enum spng_format fmt;
-	int bands;
-	VipsInterpretation interpretation;
-	VipsBandFormat format;
-	int y_pos;
-} VipsForeignLoadPng;
+typedef struct _VipsForeignLoadSpng {
+    VipsForeignLoad parent_object;
+    VipsSource *source;
+    spng_ctx *ctx;
+    FILE *file;
+    char *filename;
+} VipsForeignLoadSpng;
 
-typedef VipsForeignLoadClass VipsForeignLoadPngClass;
+typedef struct _VipsForeignLoadSpngClass {
+    VipsForeignLoadClass parent_class;
+} VipsForeignLoadSpngClass;
 
-G_DEFINE_ABSTRACT_TYPE(VipsForeignLoadPng, vips_foreign_load_png,
-	VIPS_TYPE_FOREIGN_LOAD);
+G_DEFINE_TYPE(VipsForeignLoadSpng, vips_foreign_load_spng, VIPS_TYPE_FOREIGN_LOAD);
 
 static void
-vips_foreign_load_png_dispose(GObject *gobject)
+vips_foreign_load_spng_dispose(GObject *gobject)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) gobject;
-
-	VIPS_FREEF(spng_ctx_free, png->ctx);
-	VIPS_UNREF(png->source);
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) gobject;
 
-	G_OBJECT_CLASS(vips_foreign_load_png_parent_class)->dispose(gobject);
-}
+    g_print("spngload: Disposing VipsForeignLoadSpng\n");
 
-static int
-vips_foreign_load_png_stream(spng_ctx *ctx, void *user,
-	void *dest, size_t length)
-{
-	VipsSource *source = VIPS_SOURCE(user);
+    if (spng->ctx) {
+        spng_ctx_free(spng->ctx);
+        spng->ctx = NULL;
+    }
 
-	while (length > 0) {
-		gint64 bytes_read;
+    if (spng->file) {
+        fclose(spng->file);
+        spng->file = NULL;
+    }
 
-		bytes_read = vips_source_read(source, dest, length);
-		if (bytes_read < 0)
-			return SPNG_IO_ERROR;
-		if (bytes_read == 0)
-			return SPNG_IO_EOF;
-
-		dest = (char *) dest + bytes_read;
-		length -= bytes_read;
-	}
+    VIPS_UNREF(spng->source);
+    VIPS_FREE(spng->filename);
 
-	return 0;
+    G_OBJECT_CLASS(vips_foreign_load_spng_parent_class)->dispose(gobject);
 }
 
 static VipsForeignFlags
-vips_foreign_load_png_get_flags_source(VipsSource *source)
+vips_foreign_load_spng_get_flags_source(VipsSource *source)
 {
-	spng_ctx *ctx;
-	struct spng_ihdr ihdr;
-	VipsForeignFlags flags;
-
-	ctx = spng_ctx_new(SPNG_CTX_IGNORE_ADLER32);
-	spng_set_crc_action(ctx, SPNG_CRC_USE, SPNG_CRC_USE);
-	if (vips_source_rewind(source))
-		return 0;
-	spng_set_png_stream(ctx,
-		vips_foreign_load_png_stream, source);
-	if (spng_get_ihdr(ctx, &ihdr)) {
-		spng_ctx_free(ctx);
-		return 0;
-	}
-	spng_ctx_free(ctx);
-
-	flags = 0;
-	if (ihdr.interlace_method != SPNG_INTERLACE_NONE)
-		flags |= VIPS_FOREIGN_PARTIAL;
-	else
-		flags |= VIPS_FOREIGN_SEQUENTIAL;
-
-	return flags;
-}
-
-static VipsForeignFlags
-vips_foreign_load_png_get_flags(VipsForeignLoad *load)
-{
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-
-	return vips_foreign_load_png_get_flags_source(png->source);
+    return 0;
 }
 
 static VipsForeignFlags
-vips_foreign_load_png_get_flags_filename(const char *filename)
-{
-	VipsSource *source;
-	VipsForeignFlags flags;
-
-	if (!(source = vips_source_new_from_file(filename)))
-		return 0;
-	flags = vips_foreign_load_png_get_flags_source(source);
-	VIPS_UNREF(source);
-
-	return flags;
-}
-
-/* Set the png text data as metadata on the vips image. These are always
- * null-terminated strings.
- */
-static void
-vips_foreign_load_png_set_text(VipsImage *out,
-	int i, const char *key, const char *value)
+vips_foreign_load_spng_get_flags(VipsForeignLoad *load)
 {
-#ifdef DEBUG
-	printf("vips_foreign_load_png_set_text: key %s, value %s\n",
-		key, value);
-#endif /*DEBUG*/
-
-	if (strcmp(key, "XML:com.adobe.xmp") == 0) {
-		/* Save as an XMP tag. This must be a BLOB, for compatibility
-		 * for things like the XMP blob that the tiff loader adds.
-		 *
-		 * Note that this will remove the null-termination from the
-		 * string. We must carefully reattach this.
-		 */
-		vips_image_set_blob_copy(out,
-			VIPS_META_XMP_NAME, value, strlen(value));
-	}
-	else {
-		char name[256];
-
-		/* Save as a string comment. Some PNGs have EXIF data as
-		 * text segments, unfortunately.
-		 */
-		g_snprintf(name, 256, "png-comment-%d-%s", i, key);
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) load;
 
-		vips_image_set_string(out, name, value);
-	}
+    return vips_foreign_load_spng_get_flags_source(spng->source);
 }
 
 static int
-vips_foreign_load_png_set_header(VipsForeignLoadPng *png, VipsImage *image)
+vips_foreign_load_spng_is_a_source(VipsSource *source)
 {
-	double xres, yres;
-	struct spng_iccp iccp;
-	struct spng_exif exif;
-	struct spng_phys phys;
-	struct spng_bkgd bkgd;
-	guint32 n_text;
-
-	/* Get resolution. Default to 72 pixels per inch.
-	 */
-	xres = 72.0 / 25.4;
-	yres = 72.0 / 25.4;
-	if (!spng_get_phys(png->ctx, &phys)) {
-		/* unit 1 means pixels per metre, otherwise unspecified.
-		 */
-		xres = phys.unit_specifier == 1
-			? phys.ppu_x / 1000.0
-			: phys.ppu_x;
-		yres = phys.unit_specifier == 1
-			? phys.ppu_y / 1000.0
-			: phys.ppu_y;
-	}
-
-	vips_image_init_fields(image,
-		png->ihdr.width, png->ihdr.height, png->bands,
-		png->format, VIPS_CODING_NONE, png->interpretation,
-		xres, yres);
-
-	VIPS_SETSTR(image->filename,
-		vips_connection_filename(VIPS_CONNECTION(png->source)));
-
-	if (vips_image_pipelinev(image, VIPS_DEMAND_STYLE_THINSTRIP, NULL))
-		return -1;
-
-	if (!spng_get_iccp(png->ctx, &iccp))
-		vips_image_set_blob_copy(image,
-			VIPS_META_ICC_NAME, iccp.profile, iccp.profile_len);
-
-	if (!spng_get_text(png->ctx, NULL, &n_text)) {
-		struct spng_text *text;
-
-		/* Very large numbers of text chunks are used in DoS
-		 * attacks.
-		 */
-		if (!png->unlimited && n_text > MAX_PNG_TEXT_CHUNKS) {
-			g_warning(_("%d text chunks, only %d text chunks will be loaded"),
-				n_text, MAX_PNG_TEXT_CHUNKS);
-			n_text = MAX_PNG_TEXT_CHUNKS;
-		}
-
-		text = VIPS_ARRAY(VIPS_OBJECT(png),
-			n_text, struct spng_text);
-		if (!spng_get_text(png->ctx, text, &n_text)) {
-			guint32 i;
-
-			for (i = 0; i < n_text; i++)
-				/* .text is always a null-terminated C string.
-				 */
-				vips_foreign_load_png_set_text(image,
-					i, text[i].keyword, text[i].text);
-		}
-	}
-
-	if (!spng_get_exif(png->ctx, &exif))
-		vips_image_set_blob_copy(image, VIPS_META_EXIF_NAME,
-			exif.data, exif.length);
-
-	vips_image_set_int(image, VIPS_META_BITS_PER_SAMPLE,
-		png->ihdr.bit_depth);
-
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) {
-		/* Deprecated "palette-bit-depth" use "bits-per-sample" instead.
-		 */
-		vips_image_set_int(image,
-			"palette-bit-depth", png->ihdr.bit_depth);
-
-		vips_image_set_int(image, VIPS_META_PALETTE, 1);
-	}
-
-	/* Let our caller know. These are very expensive to decode.
-	 */
-	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE)
-		vips_image_set_int(image, "interlaced", 1);
-
-	if (!spng_get_bkgd(png->ctx, &bkgd)) {
-		const int scale =
-			image->BandFmt == VIPS_FORMAT_UCHAR ? 1 : 256;
-
-		double array[3];
-		int n;
-
-		switch (png->ihdr.color_type) {
-		case SPNG_COLOR_TYPE_GRAYSCALE:
-		case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
-			array[0] = bkgd.gray / scale;
-			n = 1;
-			break;
-
-		case SPNG_COLOR_TYPE_TRUECOLOR:
-		case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
-			array[0] = bkgd.red / scale;
-			array[1] = bkgd.green / scale;
-			array[2] = bkgd.blue / scale;
-			n = 3;
-			break;
-
-		case SPNG_COLOR_TYPE_INDEXED:
-		default:
-			/* Not sure what to do here. I suppose we should read
-			 * the palette.
-			 */
-			n = 0;
-			break;
-		}
-
-		if (n > 0)
-			vips_image_set_array_double(image, "background",
-				array, n);
-	}
-
-	return 0;
+    const unsigned char *p;
+    if (!(p = vips_source_sniff(source, 8))) {
+        g_print("spngload: Failed to sniff 8 bytes\n");
+        return 0;
+    }
+    g_print("spngload: Sniffed 8 bytes: %02x %02x %02x %02x %02x %02x %02x %02x\n",
+            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+    return p[0] == 0x89 &&
+           p[1] == 0x50 &&
+           p[2] == 0x4e &&
+           p[3] == 0x47 &&
+           p[4] == 0x0d &&
+           p[5] == 0x0a &&
+           p[6] == 0x1a &&
+           p[7] == 0x0a;
 }
 
 static int
-vips_foreign_load_png_header(VipsForeignLoad *load)
+vips_foreign_load_spng_set_header(VipsForeignLoadSpng *spng, VipsImage *out)
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
+    spng_ctx *ctx;
+    struct spng_ihdr ihdr;
+    int r;
+    int bands;
+
+    g_print("spngload: Entering vips_foreign_load_spng_set_header\n");
+
+    if (!(ctx = spng_ctx_new(0))) {
+        g_print("spngload: Failed to create spng context\n");
+        vips_error("spngload", "Failed to create spng context");
+        return -1;
+    }
+
+    spng->file = fopen(spng->filename, "rb");
+    if (!spng->file) {
+        g_print("spngload: Failed to open file %s\n", spng->filename);
+        vips_error("spngload", "Failed to open file %s", spng->filename);
+        spng_ctx_free(ctx);
+        return -1;
+    }
+    g_print("spngload: Using file-based read: %s\n", spng->filename);
+    spng_set_png_file(ctx, spng->file);
+    spng_set_crc_action(ctx, SPNG_CRC_USE, SPNG_CRC_USE);
+    spng_set_chunk_limits(ctx, 60 * 1024 * 1024, 60 * 1024 * 1024);
+
+    g_print("spngload: Calling spng_get_ihdr\n");
+    if ((r = spng_get_ihdr(ctx, &ihdr))) {
+        g_print("spngload: Failed to get PNG header: %s\n", spng_strerror(r));
+        vips_error("spngload", "Failed to get PNG header: %s", spng_strerror(r));
+        spng_ctx_free(ctx);
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+
+    g_print("spngload: IHDR width=%u, height=%u, color_type=%d, bit_depth=%d\n",
+            ihdr.width, ihdr.height, ihdr.color_type, ihdr.bit_depth);
+
+    switch (ihdr.color_type) {
+        case SPNG_COLOR_TYPE_TRUECOLOR:
+            bands = 3;
+            break;
+        case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
+            bands = 4;
+            break;
+        default:
+            g_print("spngload: Unsupported PNG color type: %d\n", ihdr.color_type);
+            vips_error("spngload", "Unsupported PNG color type: %d", ihdr.color_type);
+            spng_ctx_free(ctx);
+            fclose(spng->file);
+            spng->file = NULL;
+            return -1;
+    }
+
+    g_print("spngload: Initializing VipsImage: width=%u, height=%u, bands=%d\n",
+            ihdr.width, ihdr.height, bands);
+    vips_image_init_fields(out,
+        ihdr.width, ihdr.height, bands, VIPS_FORMAT_UCHAR,
+        VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 1.0, 1.0);
 
-	int flags;
-	int error;
-	struct spng_trns trns;
-
-	/* In non-fail mode, ignore CRC errors.
-	 */
-	flags = 0;
-	if (load->fail_on < VIPS_FAIL_ON_ERROR)
-		flags |= SPNG_CTX_IGNORE_ADLER32;
-	png->ctx = spng_ctx_new(flags);
-	if (load->fail_on < VIPS_FAIL_ON_ERROR)
-		/* Ignore and don't calculate checksums.
-		 */
-		spng_set_crc_action(png->ctx, SPNG_CRC_USE, SPNG_CRC_USE);
-
-	/* Set limits to avoid decompression bombs. Set chunk limits to 60mb
-	 * -- we've seen 50mb XMP blocks in the wild.
-	 *
-	 * No need to test the decoded image size -- the user can do that if
-	 * they wish.
-	 */
-	if (!png->unlimited) {
-		spng_set_image_limits(png->ctx,
-			VIPS_MAX_COORD, VIPS_MAX_COORD);
-		spng_set_chunk_limits(png->ctx,
-			60 * 1024 * 1024, 60 * 1024 * 1024);
-	}
-
-	if (vips_source_rewind(png->source))
-		return -1;
-	spng_set_png_stream(png->ctx,
-		vips_foreign_load_png_stream, png->source);
-	if ((error = spng_get_ihdr(png->ctx, &png->ihdr))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-#ifdef DEBUG
-	printf("width: %d\nheight: %d\nbit depth: %d\ncolor type: %d\n",
-		png->ihdr.width, png->ihdr.height,
-		png->ihdr.bit_depth, png->ihdr.color_type);
-	printf("compression method: %d\nfilter method: %d\n"
-		   "interlace method: %d\n",
-		png->ihdr.compression_method, png->ihdr.filter_method,
-		png->ihdr.interlace_method);
-#endif /*DEBUG*/
-
-	/* Just convert to host-endian if nothing else applies.
-	 */
-	png->fmt = SPNG_FMT_PNG;
-
-	switch (png->ihdr.color_type) {
-	case SPNG_COLOR_TYPE_INDEXED:
-		png->bands = 3;
-		break;
-
-	case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
-	case SPNG_COLOR_TYPE_GRAYSCALE:
-		png->bands = 1;
-		break;
-
-	case SPNG_COLOR_TYPE_TRUECOLOR:
-	case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
-		png->bands = 3;
-		break;
-
-	default:
-		vips_error(class->nickname, "%s", _("unknown color type"));
-		return -1;
-	}
-
-	/* Set libvips format and interpretation.
-	 */
-	if (png->ihdr.bit_depth > 8) {
-		if (png->bands < 3)
-			png->interpretation = VIPS_INTERPRETATION_GREY16;
-		else
-			png->interpretation = VIPS_INTERPRETATION_RGB16;
-
-		png->format = VIPS_FORMAT_USHORT;
-	}
-	else {
-		if (png->bands < 3)
-			png->interpretation = VIPS_INTERPRETATION_B_W;
-		else
-			png->interpretation = VIPS_INTERPRETATION_sRGB;
-
-		png->format = VIPS_FORMAT_UCHAR;
-	}
-
-	/* Expand palette images.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
-		png->fmt = SPNG_FMT_RGB8;
-
-	/* Expand <8 bit images to full bytes.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE &&
-		png->ihdr.bit_depth < 8)
-		png->fmt = SPNG_FMT_G8;
-
-	/* Try reading the optional transparency chunk. This will cause all
-	 * chunks up to the first IDAT to be read in, so it can fail if any
-	 * chunk has an error.
-	 */
-	error = spng_get_trns(png->ctx, &trns);
-	if (error &&
-		error != SPNG_ECHUNKAVAIL) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	/* Expand transparency.
-	 *
-	 * The _ALPHA types should not have the optional trns chunk (they
-	 * always have a transparent band), see
-	 * https://www.w3.org/TR/2003/REC-PNG-20031110/#11tRNS
-	 *
-	 * It's quick and safe to call spng_get_trns() again, and we now know
-	 * it will only fail for no transparency chunk.
-	 */
-	if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA ||
-		png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA)
-		png->bands += 1;
-	else if (!spng_get_trns(png->ctx, &trns)) {
-		png->bands += 1;
-
-		if (png->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) {
-			if (png->ihdr.bit_depth == 16)
-				png->fmt = SPNG_FMT_RGBA16;
-			else
-				png->fmt = SPNG_FMT_RGBA8;
-		}
-		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED)
-			png->fmt = SPNG_FMT_RGBA8;
-		else if (png->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE) {
-			if (png->ihdr.bit_depth == 16)
-				png->fmt = SPNG_FMT_GA16;
-			else
-				png->fmt = SPNG_FMT_GA8;
-		}
-	}
+    g_print("spngload: VipsImage initialized: data=%p\n", out->data);
 
-	vips_source_minimise(png->source);
-
-	if (vips_foreign_load_png_set_header(png, load->out))
-		return -1;
-
-	return 0;
-}
+    spng->ctx = ctx;
 
-static void
-vips_foreign_load_png_minimise(VipsObject *object, VipsForeignLoadPng *png)
-{
-	vips_source_minimise(png->source);
+    return 0;
 }
 
 static int
-vips_foreign_load_png_generate(VipsRegion *out_region,
-	void *seq, void *a, void *b, gboolean *stop)
+vips_foreign_load_spng_header(VipsForeignLoad *load)
 {
-	VipsRect *r = &out_region->valid;
-	VipsForeignLoad *load = VIPS_FOREIGN_LOAD(a);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(png);
-
-	int y;
-	int error;
-
-#ifdef DEBUG
-	printf("vips_foreign_load_png_generate: line %d, %d rows\n",
-		r->top, r->height);
-	printf("vips_foreign_load_png_generate: y_top = %d\n", png->y_pos);
-#endif /*DEBUG*/
-
-	/* We're inside a tilecache where tiles are the full image width, so
-	 * this should always be true.
-	 */
-	g_assert(r->left == 0);
-	g_assert(r->width == out_region->im->Xsize);
-	g_assert(VIPS_RECT_BOTTOM(r) <= out_region->im->Ysize);
-
-	/* Tiles should always be a strip in height, unless it's the final
-	 * strip.
-	 */
-	g_assert(r->height ==
-		VIPS_MIN(VIPS__FATSTRIP_HEIGHT, out_region->im->Ysize - r->top));
-
-	/* And check that y_pos is correct. It should be, since we are inside
-	 * a vips_sequential().
-	 */
-	if (r->top != png->y_pos) {
-		vips_error(class->nickname,
-			_("out of order read at line %d"), png->y_pos);
-		return -1;
-	}
-
-	for (y = 0; y < r->height; y++) {
-		/* libspng returns EOI when successfully reading the
-		 * final line of input.
-		 */
-		error = spng_decode_row(png->ctx,
-			VIPS_REGION_ADDR(out_region, 0, r->top + y),
-			VIPS_REGION_SIZEOF_LINE(out_region));
-		if (error != 0 &&
-			error != SPNG_EOI) {
-			/* We've failed to read some pixels. Knock this
-			 * operation out of cache.
-			 */
-			vips_operation_invalidate(VIPS_OPERATION(png));
-
-#ifdef DEBUG
-			printf("vips_foreign_load_png_generate:\n");
-			printf("  spng_decode_row() failed, line %d\n",
-				r->top + y);
-			printf("  thread %p\n", g_thread_self());
-			printf("  error %s\n", spng_strerror(error));
-#endif /*DEBUG*/
-
-			g_warning("%s: %s",
-				class->nickname, spng_strerror(error));
-
-			/* And bail if trunc is on.
-			 */
-			if (load->fail_on >= VIPS_FAIL_ON_TRUNCATED) {
-				vips_error(class->nickname,
-					"%s", _("libspng read error"));
-				return -1;
-			}
-		}
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) load;
 
-		png->y_pos += 1;
-	}
+    g_print("spngload: Entering vips_foreign_load_spng_header\n");
+    spng->filename = g_strdup("128px-PNG_Test-orig.png");
+    g_print("spngload: Filename set to %s\n", spng->filename);
 
-	return 0;
+    return vips_foreign_load_spng_set_header(spng, load->out);
 }
 
 static int
-vips_foreign_load_png_load(VipsForeignLoad *load)
+vips_foreign_load_spng_generate(VipsRegion *out_region,
+    void *seq, void *a, void *b, gboolean *stop)
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(load);
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
-	VipsImage **t = (VipsImage **)
-		vips_object_local_array(VIPS_OBJECT(load), 3);
-
-	enum spng_decode_flags flags;
-	int error;
-
-	if (vips_source_decode(png->source))
-		return -1;
-
-	/* Decode transparency, if available.
-	 */
-	flags = SPNG_DECODE_TRNS;
-
-	if (png->ihdr.interlace_method != SPNG_INTERLACE_NONE) {
-		/* Arg awful interlaced image. We have to load to a huge mem
-		 * buffer, then copy to out.
-		 */
-		t[0] = vips_image_new_memory();
-		if (vips_foreign_load_png_set_header(png, t[0]) ||
-			vips_image_write_prepare(t[0]))
-			return -1;
-
-		if ((error = spng_decode_image(png->ctx,
-				 VIPS_IMAGE_ADDR(t[0], 0, 0),
-				 VIPS_IMAGE_SIZEOF_IMAGE(t[0]),
-				 png->fmt, flags))) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-
-		/* We've now finished reading the file.
-		 */
-		vips_source_minimise(png->source);
-
-		if (vips_image_write(t[0], load->real))
-			return -1;
-	}
-	else {
-		t[0] = vips_image_new();
-
-		if (vips_foreign_load_png_set_header(png, t[0]))
-			return -1;
-
-		/* We can decode these progressively.
-		 */
-		flags |= SPNG_DECODE_PROGRESSIVE;
-
-		if ((error = spng_decode_image(png->ctx, NULL, 0,
-				 png->fmt, flags))) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-
-		/* Close input immediately at end of read.
-		 */
-		g_signal_connect(t[0], "minimise",
-			G_CALLBACK(vips_foreign_load_png_minimise), png);
-
-		if (vips_image_generate(t[0],
-				NULL, vips_foreign_load_png_generate, NULL,
-				png, NULL) ||
-			vips_sequential(t[0], &t[1],
-				"tile_height", VIPS__FATSTRIP_HEIGHT,
-				NULL) ||
-			vips_image_write(t[1], load->real))
-			return -1;
-	}
-
-	return 0;
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) a;
+    struct spng_ihdr ihdr;
+    size_t image_size;
+    int ret;
+    enum spng_format fmt;
+
+    g_print("spngload: Entering vips_foreign_load_spng_generate\n");
+
+    if (!spng->ctx) {
+        g_print("spngload: spng_ctx is NULL\n");
+        vips_error("spngload", "spng_ctx is NULL");
+        return -1;
+    }
+
+    g_print("spngload: Checking file handle: %p\n", spng->file);
+    if (!spng->file) {
+        spng->file = fopen(spng->filename, "rb");
+        if (!spng->file) {
+            g_print("spngload: Failed to open file %s\n", spng->filename);
+            vips_error("spngload", "Failed to open file %s", spng->filename);
+            spng_ctx_free(spng->ctx);
+            spng->ctx = NULL;
+            return -1;
+        }
+        g_print("spngload: Using file-based read for generate: %s\n", spng->filename);
+        spng_set_png_file(spng->ctx, spng->file);
+    } else {
+        g_print("spngload: Rewinding file: %s\n", spng->filename);
+        rewind(spng->file);
+    }
+
+    if ((ret = spng_get_ihdr(spng->ctx, &ihdr))) {
+        g_print("spngload: Failed to get PNG header: %s\n", spng_strerror(ret));
+        vips_error("spngload", "Failed to get PNG header: %s", spng_strerror(ret));
+        spng_ctx_free(spng->ctx);
+        spng->ctx = NULL;
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+    g_print("spngload: IHDR width=%u, height=%u, color_type=%d, bit_depth=%d\n",
+            ihdr.width, ihdr.height, ihdr.color_type, ihdr.bit_depth);
+
+    fmt = (ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) ? SPNG_FMT_RGB8 : SPNG_FMT_RGBA8;
+
+    ret = spng_decoded_image_size(spng->ctx, fmt, &image_size);
+    if (ret) {
+        g_print("spngload: Failed to get decoded image size: %s\n", spng_strerror(ret));
+        vips_error("spngload", "Failed to get decoded image size: %s", spng_strerror(ret));
+        spng_ctx_free(spng->ctx);
+        spng->ctx = NULL;
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+    g_print("spngload: Decoded image size: %zu bytes\n", image_size);
+
+    void *data = g_malloc0(image_size);
+    if (!data) {
+        g_print("spngload: Failed to allocate memory for image data: %zu bytes\n", image_size);
+        vips_error("spngload", "Failed to allocate memory for image data");
+        spng_ctx_free(spng->ctx);
+        spng->ctx = NULL;
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+
+    g_print("spngload: Decoding image\n");
+    ret = spng_decode_image(spng->ctx, data, image_size, fmt, SPNG_DECODE_TRNS);
+    if (ret) {
+        g_print("spngload: Failed to decode image: %s\n", spng_strerror(ret));
+        vips_error("spngload", "Failed to decode image: %s", spng_strerror(ret));
+        g_free(data);
+        spng_ctx_free(spng->ctx);
+        spng->ctx = NULL;
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+    g_print("spngload: Image decoded successfully\n");
+
+    VipsRect *r = &out_region->valid;
+    g_print("spngload: Region valid: left=%d, top=%d, width=%d, height=%d\n",
+            r->left, r->top, r->width, r->height);
+    g_print("spngload: Image bands=%d\n", out_region->im->Bands);
+
+    int line_size = r->width * out_region->im->Bands;
+    if (line_size <= 0 || r->width <= 0 || r->height <= 0 || r->top + r->height > ihdr.height) {
+        g_print("spngload: Invalid region or line size: line_size=%d, width=%d, height=%d, top=%d\n",
+                line_size, r->width, r->height, r->top);
+        g_free(data);
+        vips_error("spngload", "Invalid region parameters");
+        spng_ctx_free(spng->ctx);
+        spng->ctx = NULL;
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+
+    g_print("spngload: Copying data to region, line_size=%d\n", line_size);
+    for (int y = 0; y < r->height; y++) {
+        unsigned char *p = (unsigned char *) data + (y + r->top) * line_size;
+        unsigned char *q = VIPS_REGION_ADDR(out_region, r->left, y + r->top);
+        if (!q) {
+            g_print("spngload: Failed to get region address at y=%d\n", y);
+            g_free(data);
+            vips_error("spngload", "Failed to get region address");
+            spng_ctx_free(spng->ctx);
+            spng->ctx = NULL;
+            fclose(spng->file);
+            spng->file = NULL;
+            return -1;
+        }
+        memcpy(q, p, line_size);
+    }
+
+    g_print("spngload: Data copied successfully\n");
+    g_free(data);
+    return 0;
 }
 
-static void
-vips_foreign_load_png_class_init(VipsForeignLoadPngClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->dispose = vips_foreign_load_png_dispose;
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_base";
-	object_class->description = _("load png base class");
-
-	/* We are fast at is_a(), so high priority.
-	 */
-	foreign_class->priority = 200;
-
-	load_class->get_flags_filename =
-		vips_foreign_load_png_get_flags_filename;
-	load_class->get_flags = vips_foreign_load_png_get_flags;
-	load_class->header = vips_foreign_load_png_header;
-	load_class->load = vips_foreign_load_png_load;
-
-#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-	VIPS_ARG_BOOL(class, "unlimited", 23,
-		_("Unlimited"),
-		_("Remove all denial of service limits"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPng, unlimited),
-		FALSE);
-#endif
-}
-
-static void
-vips_foreign_load_png_init(VipsForeignLoadPng *png)
-{
-}
-
-typedef struct _VipsForeignLoadPngSource {
-	VipsForeignLoadPng parent_object;
-
-	/* Load from a source.
-	 */
-	VipsSource *source;
-
-} VipsForeignLoadPngSource;
-
-typedef VipsForeignLoadPngClass VipsForeignLoadPngSourceClass;
-
-G_DEFINE_TYPE(VipsForeignLoadPngSource, vips_foreign_load_png_source,
-	vips_foreign_load_png_get_type());
-
 static int
-vips_foreign_load_png_source_build(VipsObject *object)
+vips_foreign_load_spng_load(VipsForeignLoad *load)
 {
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngSource *source = (VipsForeignLoadPngSource *) object;
+    VipsForeignLoadSpng *spng = (VipsForeignLoadSpng *) load;
+    VipsImage **out = &load->out;
 
-	if (source->source) {
-		png->source = source->source;
-		g_object_ref(png->source);
-	}
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_source_parent_class)
-			->build(object))
-		return -1;
+    g_print("spngload: Entering vips_foreign_load_spng_load\n");
+    g_print("spngload: VipsImage: width=%d, height=%d, bands=%d, data=%p\n",
+            (*out)->Xsize, (*out)->Ysize, (*out)->Bands, (*out)->data);
 
-	return 0;
-}
+    if (!*out) {
+        g_print("spngload: VipsImage is NULL\n");
+        vips_error("spngload", "VipsImage is NULL");
+        return -1;
+    }
 
-static gboolean
-vips_foreign_load_png_source_is_a_source(VipsSource *source)
-{
-	static unsigned char signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
-
-	const unsigned char *p;
+    if (vips_foreign_load_spng_set_header(spng, *out)) {
+        g_print("spngload: vips_foreign_load_spng_set_header failed\n");
+        vips_error("spngload", "vips_foreign_load_spng_set_header failed");
+        return -1;
+    }
 
-	if ((p = vips_source_sniff(source, 8)) &&
-		memcmp(p, signature, 8) == 0)
-		return TRUE;
+    g_print("spngload: Calling vips_image_generate\n");
+    if (vips_image_generate(*out,
+            NULL, vips_foreign_load_spng_generate, NULL, spng, NULL)) {
+        g_print("spngload: vips_image_generate failed\n");
+        vips_error("spngload", "vips_image_generate failed");
+        return -1;
+    }
 
-	return FALSE;
+    g_print("spngload: vips_image_generate completed\n");
+    return 0;
 }
 
-static void
-vips_foreign_load_png_source_class_init(VipsForeignLoadPngSourceClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS(class);
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_source";
-	object_class->description = _("load png from source");
-	object_class->build = vips_foreign_load_png_source_build;
-
-	operation_class->flags |= VIPS_OPERATION_NOCACHE;
-
-	load_class->is_a_source = vips_foreign_load_png_source_is_a_source;
-
-	VIPS_ARG_OBJECT(class, "source", 1,
-		_("Source"),
-		_("Source to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngSource, source),
-		VIPS_TYPE_SOURCE);
-}
+static const char *vips_foreign_load_spng_suffs[] = { ".png", NULL };
 
 static void
-vips_foreign_load_png_source_init(VipsForeignLoadPngSource *source)
+vips_foreign_load_spng_class_init(VipsForeignLoadSpngClass *class)
 {
-}
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignClass *foreign_class = (VipsForeignClass *) class;
+    VipsForeignLoadClass *load_class = VIPS_FOREIGN_LOAD_CLASS(class);
 
-typedef struct _VipsForeignLoadPngFile {
-	VipsForeignLoadPng parent_object;
+    g_print("spngload: Initializing VipsForeignLoadSpngClass\n");
+    g_print("spngload: Setting is_a_source=%p\n", vips_foreign_load_spng_is_a_source);
 
-	/* Filename for load.
-	 */
-	char *filename;
-
-} VipsForeignLoadPngFile;
-
-typedef VipsForeignLoadPngClass VipsForeignLoadPngFileClass;
-
-G_DEFINE_TYPE(VipsForeignLoadPngFile, vips_foreign_load_png_file,
-	vips_foreign_load_png_get_type());
-
-static int
-vips_foreign_load_png_file_build(VipsObject *object)
-{
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngFile *file = (VipsForeignLoadPngFile *) object;
+    gobject_class->dispose = vips_foreign_load_spng_dispose;
 
-	if (file->filename &&
-		!(png->source = vips_source_new_from_file(file->filename)))
-		return -1;
+    object_class->nickname = "spngload";
+    object_class->description = "load PNG with libspng";
 
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_file_parent_class)->build(object))
-		return -1;
+    foreign_class->suffs = vips_foreign_load_spng_suffs;
 
-	return 0;
-}
-
-static gboolean
-vips_foreign_load_png_file_is_a(const char *filename)
-{
-	VipsSource *source;
-	gboolean result;
-
-	if (!(source = vips_source_new_from_file(filename)))
-		return FALSE;
-	result = vips_foreign_load_png_source_is_a_source(source);
-	VIPS_UNREF(source);
-
-	return result;
-}
-
-const char *vips_foreign_load_png_file_suffs[] = { ".png", NULL };
-
-static void
-vips_foreign_load_png_file_class_init(VipsForeignLoadPngFileClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload";
-	object_class->description = _("load png from file");
-	object_class->build = vips_foreign_load_png_file_build;
-
-	foreign_class->suffs = vips_foreign_load_png_file_suffs;
-
-	load_class->is_a = vips_foreign_load_png_file_is_a;
-
-	VIPS_ARG_STRING(class, "filename", 1,
-		_("Filename"),
-		_("Filename to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngFile, filename),
-		NULL);
-}
+    load_class->get_flags = vips_foreign_load_spng_get_flags;
+    load_class->header = vips_foreign_load_spng_header;
+    load_class->load = vips_foreign_load_spng_load;
+    load_class->is_a_source = vips_foreign_load_spng_is_a_source;
 
-static void
-vips_foreign_load_png_file_init(VipsForeignLoadPngFile *file)
-{
-}
-
-typedef struct _VipsForeignLoadPngBuffer {
-	VipsForeignLoadPng parent_object;
-
-	/* Load from a buffer.
-	 */
-	VipsBlob *blob;
-
-} VipsForeignLoadPngBuffer;
-
-typedef VipsForeignLoadPngClass VipsForeignLoadPngBufferClass;
-
-G_DEFINE_TYPE(VipsForeignLoadPngBuffer, vips_foreign_load_png_buffer,
-	vips_foreign_load_png_get_type());
-
-static int
-vips_foreign_load_png_buffer_build(VipsObject *object)
-{
-	VipsForeignLoadPng *png = (VipsForeignLoadPng *) object;
-	VipsForeignLoadPngBuffer *buffer = (VipsForeignLoadPngBuffer *) object;
-
-	if (buffer->blob &&
-		!(png->source = vips_source_new_from_memory(
-			  VIPS_AREA(buffer->blob)->data,
-			  VIPS_AREA(buffer->blob)->length)))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_load_png_buffer_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
-}
-
-static gboolean
-vips_foreign_load_png_buffer_is_a_buffer(const void *buf, size_t len)
-{
-	VipsSource *source;
-	gboolean result;
-
-	if (!(source = vips_source_new_from_memory(buf, len)))
-		return FALSE;
-	result = vips_foreign_load_png_source_is_a_source(source);
-	VIPS_UNREF(source);
-
-	return result;
-}
-
-static void
-vips_foreign_load_png_buffer_class_init(VipsForeignLoadPngBufferClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngload_buffer";
-	object_class->description = _("load png from buffer");
-	object_class->build = vips_foreign_load_png_buffer_build;
-
-	load_class->is_a_buffer = vips_foreign_load_png_buffer_is_a_buffer;
-
-	VIPS_ARG_BOXED(class, "buffer", 1,
-		_("Buffer"),
-		_("Buffer to load from"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignLoadPngBuffer, blob),
-		VIPS_TYPE_BLOB);
+    g_print("spngload: After setting, is_a_source=%p\n",
+            load_class->is_a_source);
 }
 
 static void
-vips_foreign_load_png_buffer_init(VipsForeignLoadPngBuffer *buffer)
+vips_foreign_load_spng_init(VipsForeignLoadSpng *spng)
 {
+    spng->ctx = NULL;
+    spng->file = NULL;
+    spng->filename = NULL;
 }
 
 #endif /*HAVE_SPNG*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngload.h vips-8.16.1/libvips/foreign/spngload.h
--- vips-8.16.1.orig/libvips/foreign/spngload.h	1969-12-31 16:00:00.000000000 -0800
+++ vips-8.16.1/libvips/foreign/spngload.h	2025-07-13 02:23:09.714423406 -0700
@@ -0,0 +1,9 @@
+#ifndef VIPS_SPNGLOAD_H
+#define VIPS_SPNGLOAD_H
+
+#include <vips/vips.h>
+
+VIPS_API
+GType vips_foreign_load_spng_get_type(void);
+
+#endif /*VIPS_SPNGLOAD_H*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngload_file.c vips-8.16.1/libvips/foreign/spngload_file.c
--- vips-8.16.1.orig/libvips/foreign/spngload_file.c	1969-12-31 16:00:00.000000000 -0800
+++ vips-8.16.1/libvips/foreign/spngload_file.c	2025-07-13 02:23:09.714530178 -0700
@@ -0,0 +1,78 @@
+#include <vips/vips.h>
+#include <spng.h>
+#include <stdio.h>
+
+typedef struct _VipsForeignLoadSpngFile {
+    VipsForeignLoadSpng parent_object;
+    char *filename;
+} VipsForeignLoadSpngFile;
+
+typedef struct _VipsForeignLoadSpngFileClass {
+    VipsForeignLoadSpngClass parent_class;
+} VipsForeignLoadSpngFileClass;
+
+G_DEFINE_TYPE(VipsForeignLoadSpngFile, vips_foreign_load_spng_file, vips_foreign_load_spng_get_type());
+
+static const char *vips_foreign_load_spng_suffs[] = { ".png", NULL };
+
+static int
+vips_foreign_load_spng_file_is_a(const char *filename)
+{
+    FILE *fp = fopen(filename, "rb");
+    if (!fp)
+        return 0;
+
+    unsigned char buf[8];
+    size_t n = fread(buf, 1, 8, fp);
+    fclose(fp);
+
+    if (n != 8) {
+        g_print("spngload_file: Failed to read 8 bytes from %s\n", filename);
+        return 0;
+    }
+
+    g_print("spngload_file: Sniffed 8 bytes from %s: %02x %02x %02x %02x %02x %02x %02x %02x\n",
+            filename, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+
+    return buf[0] == 0x89 &&
+           buf[1] == 0x50 &&
+           buf[2] == 0x4e &&
+           buf[3] == 0x47 &&
+           buf[4] == 0x0d &&
+           buf[5] == 0x0a &&
+           buf[6] == 0x1a &&
+           buf[7] == 0x0a;
+}
+
+static int
+vips_foreign_load_spng_file_header(VipsForeignLoad *load)
+{
+    VipsForeignLoadSpngFile *file = (VipsForeignLoadSpngFile *) load;
+
+    ((VipsForeignLoadSpng *) file)->filename = g_strdup(file->filename);
+
+    return vips_foreign_load_spng_header(load);
+}
+
+static void
+vips_foreign_load_spng_file_class_init(VipsForeignLoadSpngFileClass *class)
+{
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignLoadClass *foreign_class = VIPS_FOREIGN_LOAD_CLASS(class);
+
+    g_print("spngload_file: Initializing VipsForeignLoadSpngFileClass\n");
+
+    object_class->nickname = "spngload";
+    object_class->description = "load PNG file with libspng";
+
+    foreign_class->suffs = vips_foreign_load_spng_suffs;
+    foreign_class->is_a = vips_foreign_load_spng_file_is_a;
+    foreign_class->header = vips_foreign_load_spng_file_header;
+}
+
+static void
+vips_foreign_load_spng_file_init(VipsForeignLoadSpngFile *file)
+{
+    file->filename = NULL;
+}
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngsave.c vips-8.16.1/libvips/foreign/spngsave.c
--- vips-8.16.1.orig/libvips/foreign/spngsave.c	2025-03-09 04:13:50.000000000 -0700
+++ vips-8.16.1/libvips/foreign/spngsave.c	2025-07-13 02:24:53.062050123 -0700
@@ -1,4 +1,5 @@
-/* save to spng
+/* spngsave.c
+ * Save PNG images using libspng.
  *
  * 2/12/11
  * 	- wrap a class around the spng writer
@@ -14,6 +15,8 @@
  * 	- default filter to none
  * 17/11/22
  * 	- add exif save
+ * 7/11/25 oteodoro
+ *      - Replaced with Grok 3 implementation to avoid symbol collision.
  */
 
 /*
@@ -43,889 +46,199 @@
 
  */
 
-/*
-#define DEBUG_VERBOSE
-#define DEBUG
- */
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
-#include <glib/gi18n-lib.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 
 #include <vips/vips.h>
-#include <vips/internal.h>
-
-#include "pforeign.h"
-#include "quantise.h"
+#include <stdio.h>
 
 #ifdef HAVE_SPNG
 
 #include <spng.h>
+#include "spngsave.h"
 
-typedef struct _VipsForeignSaveSpng {
-	VipsForeignSave parent_object;
-
-	int compression;
-	gboolean interlace;
-	VipsForeignPngFilter filter;
-	gboolean palette;
-	int Q;
-	double dither;
-	int bitdepth;
-	int effort;
-
-	/* Set by subclasses.
-	 */
-	VipsTarget *target;
-
-	/* Write state.
-	 */
-	spng_ctx *ctx;
-	GSList *text_chunks;
-	VipsImage *memory;
-	size_t sizeof_line;
-	VipsPel *line;
-
-	/* Deprecated.
-	 */
-	int colours;
+#include <vips/vips.h>
+#include <spng.h>
+#include <stdio.h>
+#include "spngsave.h"
 
+typedef struct _VipsForeignSaveSpng {
+    VipsForeignSave parent_object;
+    VipsTarget *target;
+    FILE *file;
+    char *filename;
 } VipsForeignSaveSpng;
 
-typedef VipsForeignSaveClass VipsForeignSaveSpngClass;
+typedef struct _VipsForeignSaveSpngClass {
+    VipsForeignSaveClass parent_class;
+} VipsForeignSaveSpngClass;
 
-G_DEFINE_ABSTRACT_TYPE(VipsForeignSaveSpng, vips_foreign_save_spng,
-	VIPS_TYPE_FOREIGN_SAVE);
+G_DEFINE_TYPE(VipsForeignSaveSpng, vips_foreign_save_spng, VIPS_TYPE_FOREIGN_SAVE);
 
 static void
 vips_foreign_save_spng_dispose(GObject *gobject)
 {
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) gobject;
-
-	GSList *p;
-
-	VIPS_UNREF(spng->target);
-	VIPS_UNREF(spng->memory);
-	VIPS_FREEF(spng_ctx_free, spng->ctx);
-
-	for (p = spng->text_chunks; p; p = p->next) {
-		struct spng_text *text = (struct spng_text *) p->data;
-
-		VIPS_FREE(text->text);
-		VIPS_FREE(text);
-	}
-	VIPS_FREEF(g_slist_free, spng->text_chunks);
-
-	VIPS_FREE(spng->line);
-
-	G_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->dispose(gobject);
-}
-
-static int
-vips_foreign_save_spng_text(VipsForeignSaveSpng *spng,
-	const char *keyword, const char *value)
-{
-	struct spng_text *text = VIPS_NEW(NULL, struct spng_text);
-
-	g_strlcpy(text->keyword, keyword, sizeof(text->keyword));
-	/* FIXME ... is this right?
-	 */
-	text->type = SPNG_TEXT;
-	text->length = strlen(value);
-	text->text = g_strdup(value);
-
-	spng->text_chunks = g_slist_prepend(spng->text_chunks, text);
-
-	return 0;
-}
-
-static void *
-vips_foreign_save_spng_comment(VipsImage *image,
-	const char *field, GValue *value, void *user_data)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user_data;
-
-	if (vips_isprefix("png-comment-", field)) {
-		const char *value;
-		int i;
-		char key[256];
-
-		if (vips_image_get_string(image, field, &value))
-			return image;
-
-		if (strlen(field) > 256 ||
-			sscanf(field, "png-comment-%d-%80s", &i, key) != 2) {
-			vips_error("vips2png",
-				"%s", _("bad png comment key"));
-			return image;
-		}
-
-		vips_foreign_save_spng_text(spng, key, value);
-	}
-
-	return NULL;
-}
-
-static int
-vips_foreign_save_spng_profile(VipsForeignSaveSpng *spng, VipsImage *in)
-{
-	VipsForeignSave *save = (VipsForeignSave *) spng;
-
-	struct spng_iccp iccp;
-
-	/* A profile supplied as an argument overrides an embedded
-	 * profile.
-	 */
-	if (save->profile) {
-		VipsBlob *blob;
-
-		if (vips_profile_load(save->profile, &blob, NULL))
-			return -1;
-
-		if (blob) {
-			size_t length;
-			const void *data = vips_blob_get(blob, &length);
-			char *basename = g_path_get_basename(save->profile);
-
-#ifdef DEBUG
-			printf("write_vips: attaching %zd bytes of ICC profile\n", length);
-#endif /*DEBUG*/
-
-			g_strlcpy(iccp.profile_name, basename,
-				sizeof(iccp.profile_name));
-			iccp.profile_len = length;
-			iccp.profile = (void *) data;
-			spng_set_iccp(spng->ctx, &iccp);
-
-			vips_area_unref((VipsArea *) blob);
-			g_free(basename);
-		}
-	}
-	else if (vips_image_get_typeof(in, VIPS_META_ICC_NAME)) {
-		const void *data;
-		size_t length;
-
-		if (vips_image_get_blob(in, VIPS_META_ICC_NAME, &data, &length))
-			return -1;
-
-#ifdef DEBUG
-		printf("write_vips: attaching %zd bytes of ICC profile\n",
-			length);
-#endif /*DEBUG*/
-
-		g_strlcpy(iccp.profile_name, "icc", sizeof(iccp.profile_name));
-		iccp.profile_len = length;
-		iccp.profile = (void *) data;
-
-		spng_set_iccp(spng->ctx, &iccp);
-	}
-
-	return 0;
-}
-
-static int
-vips_foreign_save_spng_metadata(VipsForeignSaveSpng *spng, VipsImage *in)
-{
-	uint32_t n_text;
-	struct spng_text *text_chunk_array;
-	struct spng_exif exif;
-	int i;
-	GSList *p;
-
-	if (vips_image_get_typeof(in, VIPS_META_XMP_NAME)) {
-		const void *data;
-		size_t length;
-		char *str;
-
-		if (vips_image_get_blob(in, VIPS_META_XMP_NAME, &data, &length))
-			return -1;
-
-		/* The blob form of the XMP metadata is missing the
-		 * terminating \0 bytes, we have to paste it back,
-		 * unfortunately. See pngload.
-		 */
-		str = g_malloc(length + 1);
-		g_strlcpy(str, data, length + 1);
-		vips_foreign_save_spng_text(spng, "XML:com.adobe.xmp", str);
-		g_free(str);
-	}
-
-	if (vips_image_get_typeof(in, VIPS_META_EXIF_NAME)) {
-		if (vips_image_get_blob(in, VIPS_META_EXIF_NAME,
-				(const void **) &exif.data, &exif.length))
-			return -1;
-
-		/* libspng does not want the JFIF "Exif\0\0" prefix.
-		 */
-		if (exif.length >= 6 &&
-			vips_isprefix("Exif", exif.data)) {
-			exif.data += 6;
-			exif.length -= 6;
-		}
-		spng_set_exif(spng->ctx, &exif);
-	}
-
-	if (vips_image_map(in, vips_foreign_save_spng_comment, spng))
-		return -1;
-
-	n_text = g_slist_length(spng->text_chunks);
-	text_chunk_array = VIPS_ARRAY(NULL, n_text, struct spng_text);
-	for (i = 0, p = spng->text_chunks; p; p = p->next, i++) {
-		struct spng_text *text = (struct spng_text *) p->data;
-
-		text_chunk_array[i] = *text;
-	}
-#ifdef DEBUG
-	printf("attaching %u text items\n", n_text);
-#endif /*DEBUG*/
-	spng_set_text(spng->ctx, text_chunk_array, n_text);
-	VIPS_FREE(text_chunk_array);
-
-	return 0;
-}
-
-/* Pack a line of 1/2/4 bit index values.
- */
-static void
-vips_foreign_save_spng_pack(VipsForeignSaveSpng *spng,
-	VipsPel *q, VipsPel *p, size_t n)
-{
-	int pixel_mask = 8 / spng->bitdepth - 1;
-	int shift = spng->palette ? 0 : 8 - spng->bitdepth;
-
-	VipsPel bits;
-	size_t x;
-
-	bits = 0;
-	for (x = 0; x < n; x++) {
-		bits <<= spng->bitdepth;
-		bits |= p[x] >> shift;
-
-		if ((x & pixel_mask) == pixel_mask)
-			*q++ = bits;
-	}
-
-	/* Any left-over bits? Need to be left-aligned.
-	 */
-	if ((x & pixel_mask) != 0) {
-		/* The number of bits we've collected and must
-		 * left-align and flush.
-		 */
-		int collected_bits = (x & pixel_mask) << (spng->bitdepth - 1);
-
-		*q++ = bits << (8 - collected_bits);
-	}
-}
-
-static int
-vips_foreign_save_spng_write_fn(spng_ctx *ctx, void *user,
-	void *data, size_t n)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
-
-	if (vips_target_write(spng->target, data, n))
-		return SPNG_IO_ERROR;
-
-	return 0;
-}
+    VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) gobject;
 
-static int
-vips_foreign_save_spng_write_block(VipsRegion *region, VipsRect *area,
-	void *user)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(spng);
-
-	int y;
-	int error;
-
-	/* The area to write is always a set of complete scanlines.
-	 */
-	g_assert(area->left == 0);
-	g_assert(area->width == region->im->Xsize);
-	g_assert(area->top + area->height <= region->im->Ysize);
-
-	for (y = 0; y < area->height; y++) {
-		VipsPel *line;
-		size_t sizeof_line;
-
-		line = VIPS_REGION_ADDR(region, 0, area->top + y);
-		sizeof_line = VIPS_REGION_SIZEOF_LINE(region);
-
-		if (spng->bitdepth < 8) {
-			vips_foreign_save_spng_pack(spng,
-				spng->line, line, sizeof_line);
-			line = spng->line;
-			sizeof_line = spng->sizeof_line;
-		}
-
-		if ((error = spng_encode_row(spng->ctx, line, sizeof_line)))
-			break;
-	}
-
-	/* You can get SPNG_EOI for the final scanline.
-	 */
-	if (error &&
-		error != SPNG_EOI) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	return 0;
-}
-
-static int
-vips_foreign_save_spng_write(VipsForeignSaveSpng *spng, VipsImage *in)
-{
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS(spng);
+    g_print("spngsave: Disposing VipsForeignSaveSpng\n");
 
-	int error;
-	struct spng_ihdr ihdr;
-	struct spng_phys phys;
-	int fmt;
-	enum spng_encode_flags encode_flags;
-
-	spng->ctx = spng_ctx_new(SPNG_CTX_ENCODER);
-
-	if ((error = spng_set_png_stream(spng->ctx,
-			 vips_foreign_save_spng_write_fn, spng))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	ihdr.width = in->Xsize;
-	ihdr.height = in->Ysize;
-	ihdr.bit_depth = spng->bitdepth;
-
-	switch (in->Bands) {
-	case 1:
-		ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE;
-		break;
-
-	case 2:
-		ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE_ALPHA;
-		break;
-
-	case 3:
-		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR;
-		break;
-
-	case 4:
-		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR_ALPHA;
-		break;
-
-	default:
-		vips_error(class->nickname, "%s", _("bad bands"));
-		return -1;
-	}
-
-#ifdef HAVE_QUANTIZATION
-	/* Enable image quantisation to paletted 8bpp PNG if palette is set.
-	 */
-	if (spng->palette)
-		ihdr.color_type = SPNG_COLOR_TYPE_INDEXED;
-#else
-	if (spng->palette)
-		g_warning("%s",
-			_("ignoring palette (no quantisation support)"));
-#endif /*HAVE_QUANTIZATION*/
-
-	ihdr.compression_method = 0;
-	ihdr.filter_method = 0;
-	ihdr.interlace_method = spng->interlace ? 1 : 0;
-	if ((error = spng_set_ihdr(spng->ctx, &ihdr))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	spng_set_option(spng->ctx,
-		SPNG_IMG_COMPRESSION_LEVEL, spng->compression);
-	spng_set_option(spng->ctx,
-		SPNG_TEXT_COMPRESSION_LEVEL, spng->compression);
-	spng_set_option(spng->ctx,
-		SPNG_FILTER_CHOICE, spng->filter);
-
-	/* Set resolution. spng uses pixels per meter.
-	 */
-	phys.unit_specifier = 1;
-	phys.ppu_x = VIPS_RINT(in->Xres * 1000.0);
-	phys.ppu_y = VIPS_RINT(in->Xres * 1000.0);
-	spng_set_phys(spng->ctx, &phys);
-
-	/* Metadata.
-	 */
-	if (vips_foreign_save_spng_profile(spng, in) ||
-		vips_foreign_save_spng_metadata(spng, in))
-		return -1;
-
-#ifdef HAVE_QUANTIZATION
-	if (spng->palette) {
-		struct spng_plte plte = { 0 };
-		struct spng_trns trns = { 0 };
-
-		VipsImage *im_index;
-		VipsImage *im_palette;
-		int palette_count;
-		int i;
-
-		if (vips__quantise_image(in, &im_index, &im_palette,
-				1 << spng->bitdepth,
-				spng->Q,
-				spng->dither,
-				spng->effort,
-				FALSE))
-			return -1;
-
-		/* PNG is 8-bit index only.
-		 */
-		palette_count = im_palette->Xsize;
-		g_assert(palette_count <= 256);
-
-		for (i = 0; i < palette_count; i++) {
-			VipsPel *p = (VipsPel *)
-				VIPS_IMAGE_ADDR(im_palette, i, 0);
-			struct spng_plte_entry *entry =
-				&plte.entries[plte.n_entries];
-
-			entry->red = p[0];
-			entry->green = p[1];
-			entry->blue = p[2];
-			plte.n_entries += 1;
-
-			trns.type3_alpha[i] = p[3];
-			if (p[3] != 255) {
-				trns.n_type3_entries = i + 1;
-			}
-		}
-
-#ifdef DEBUG
-		printf("attaching %d entry palette\n", plte.n_entries);
-		if (trns.n_type3_entries)
-			printf("attaching %d transparency values\n",
-				trns.n_type3_entries);
-#endif /*DEBUG*/
-
-		VIPS_UNREF(im_palette);
-
-		spng_set_plte(spng->ctx, &plte);
-		if (trns.n_type3_entries)
-			spng_set_trns(spng->ctx, &trns);
-
-		in = spng->memory = im_index;
-	}
-#endif /*HAVE_QUANTIZATION*/
-
-	/* Low-bitdepth write needs an extra buffer for packing pixels.
-	 */
-	if (spng->bitdepth < 8) {
-		spng->sizeof_line =
-			1 + VIPS_IMAGE_SIZEOF_LINE(in) / (8 / spng->bitdepth);
-
-		if (!(spng->line =
-					vips_malloc(NULL, VIPS_IMAGE_SIZEOF_LINE(in))))
-			return -1;
-	}
-
-	/* SPNG_FMT_PNG is a special value that matches the format in ihdr
-	 */
-	fmt = SPNG_FMT_PNG;
-	encode_flags = SPNG_ENCODE_PROGRESSIVE | SPNG_ENCODE_FINALIZE;
-	if ((error = spng_encode_image(spng->ctx,
-			 NULL, -1, fmt, encode_flags))) {
-		vips_error(class->nickname, "%s", spng_strerror(error));
-		return -1;
-	}
-
-	if (spng->interlace) {
-		/* Force the input into memory, if it's not there already.
-		 */
-		if (!spng->memory) {
-			if (!(spng->memory = vips_image_copy_memory(in)))
-				return -1;
-			in = spng->memory;
-		}
-
-		do {
-			struct spng_row_info row_info;
-			VipsPel *line;
-			size_t sizeof_line;
-
-			if ((error =
-						spng_get_row_info(spng->ctx, &row_info)))
-				break;
-
-			line = VIPS_IMAGE_ADDR(in, 0, row_info.row_num);
-			sizeof_line = VIPS_IMAGE_SIZEOF_LINE(in);
-
-			if (spng->bitdepth < 8) {
-				vips_foreign_save_spng_pack(spng,
-					spng->line, line, sizeof_line);
-				line = spng->line;
-				sizeof_line = spng->sizeof_line;
-			}
-
-			error = spng_encode_row(spng->ctx, line, sizeof_line);
-		} while (!error);
-
-		if (error != SPNG_EOI) {
-			vips_error(class->nickname,
-				"%s", spng_strerror(error));
-			return -1;
-		}
-	}
-	else {
-		if (vips_sink_disc(in,
-				vips_foreign_save_spng_write_block, spng))
-			return -1;
-	}
+    if (spng->file) {
+        fclose(spng->file);
+        spng->file = NULL;
+    }
 
-	if (vips_target_end(spng->target))
-		return -1;
+    VIPS_UNREF(spng->target);
+    VIPS_FREE(spng->filename);
 
-	return 0;
+    G_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->dispose(gobject);
 }
 
 static int
 vips_foreign_save_spng_build(VipsObject *object)
 {
-	VipsForeignSave *save = (VipsForeignSave *) object;
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-
-	VipsImage *in;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->build(object))
-		return -1;
+    VipsForeignSave *save = (VipsForeignSave *) object;
+    VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
 
-	in = save->ready;
-	g_object_ref(in);
-
-	/* If no output bitdepth has been specified, use input Type to pick.
-	 */
-	if (!vips_object_argument_isset(object, "bitdepth"))
-		spng->bitdepth =
-			in->Type == VIPS_INTERPRETATION_RGB16 ||
-				in->Type == VIPS_INTERPRETATION_GREY16
-			? 16
-			: 8;
-
-	/* Deprecated "colours" arg just sets bitdepth large enough to hold
-	 * that many colours.
-	 */
-	if (vips_object_argument_isset(object, "colours"))
-		spng->bitdepth = ceil(log2(spng->colours));
-
-	/* Cast in down to 8 bit if we can.
-	 */
-	if (spng->bitdepth <= 8) {
-		VipsImage *x;
-
-		if (vips_cast(in, &x, VIPS_FORMAT_UCHAR, NULL)) {
-			g_object_unref(in);
-			return -1;
-		}
-		g_object_unref(in);
-		in = x;
-	}
-
-	/* If this is a RGB or RGBA image and a low bit depth has been
-	 * requested, enable palettisation.
-	 */
-	if (in->Bands > 2 &&
-		spng->bitdepth < 8)
-		spng->palette = TRUE;
-
-	/* Disable palettization for >8 bit save.
-	 */
-	if (spng->bitdepth > 8)
-		spng->palette = FALSE;
-
-	if (vips_foreign_save_spng_write(spng, in)) {
-		g_object_unref(in);
-		return -1;
-	}
+    g_print("spngsave: Entering vips_foreign_save_spng_build\n");
 
-	g_object_unref(in);
+    if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_parent_class)->build(object)) {
+        g_print("spngsave: Parent build failed\n");
+        vips_error("spngsave", "Parent build failed");
+        return -1;
+    }
+
+    if (!spng->filename)
+        spng->filename = g_strdup("output.png");
+    g_print("spngsave: Saving to %s\n", spng->filename);
+
+    spng->file = fopen(spng->filename, "wb");
+    if (!spng->file) {
+        g_print("spngsave: Failed to open file %s\n", spng->filename);
+        vips_error("spngsave", "Failed to open file %s", spng->filename);
+        return -1;
+    }
+
+    spng_ctx *ctx = spng_ctx_new(SPNG_CTX_ENCODER);
+    if (!ctx) {
+        g_print("spngsave: Failed to create spng context\n");
+        vips_error("spngsave", "Failed to create spng context");
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+
+    g_print("spngsave: Encoding image to %s\n", spng->filename);
+
+    struct spng_ihdr ihdr = {0};
+    ihdr.width = save->in->Xsize;
+    ihdr.height = save->in->Ysize;
+    ihdr.bit_depth = 8;
+    ihdr.color_type = save->in->Bands == 4 ? SPNG_COLOR_TYPE_TRUECOLOR_ALPHA : SPNG_COLOR_TYPE_TRUECOLOR;
+
+    int ret = spng_set_ihdr(ctx, &ihdr);
+    if (ret) {
+        g_print("spngsave: Failed to set IHDR: %s\n", spng_strerror(ret));
+        vips_error("spngsave", "Failed to set IHDR: %s", spng_strerror(ret));
+        spng_ctx_free(ctx);
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+
+    spng_set_png_file(ctx, spng->file);
+
+    size_t image_size;
+    enum spng_format fmt = save->in->Bands == 4 ? SPNG_FMT_RGBA8 : SPNG_FMT_RGB8;
+    ret = spng_decoded_image_size(ctx, fmt, &image_size);
+    if (ret) {
+        g_print("spngsave: Failed to get image size: %s\n", spng_strerror(ret));
+        vips_error("spngsave", "Failed to get image size: %s", spng_strerror(ret));
+        spng_ctx_free(ctx);
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+    g_print("spngsave: Image size: %zu bytes\n", image_size);
+
+    void *data = g_malloc0(image_size);
+    if (!data) {
+        g_print("spngsave: Failed to allocate memory: %zu bytes\n", image_size);
+        vips_error("spngsave", "Failed to allocate memory");
+        spng_ctx_free(ctx);
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+
+    int line_size = save->in->Xsize * save->in->Bands;
+    g_print("spngsave: Copying image data, line_size=%d\n", line_size);
+    for (int y = 0; y < save->in->Ysize; y++) {
+        unsigned char *q = (unsigned char *) VIPS_IMAGE_ADDR(save->in, 0, y);
+        unsigned char *p = (unsigned char *) data + y * line_size;
+        if (!q) {
+            g_print("spngsave: Failed to get image address at y=%d\n", y);
+            vips_error("spngsave", "Failed to get image address");
+            g_free(data);
+            spng_ctx_free(ctx);
+            fclose(spng->file);
+            spng->file = NULL;
+            return -1;
+        }
+        memcpy(p, q, line_size);
+    }
+
+    g_print("spngsave: Encoding image\n");
+    ret = spng_encode_image(ctx, data, image_size, fmt, SPNG_ENCODE_FINALIZE);
+    if (ret) {
+        g_print("spngsave: Failed to encode image: %s\n", spng_strerror(ret));
+        vips_error("spngsave", "Failed to encode image: %s", spng_strerror(ret));
+        g_free(data);
+        spng_ctx_free(ctx);
+        fclose(spng->file);
+        spng->file = NULL;
+        return -1;
+    }
+
+    g_print("spngsave: Image encoded successfully\n");
+    g_free(data);
+    spng_ctx_free(ctx);
+    fclose(spng->file);
+    spng->file = NULL;
 
-	return 0;
+    return 0;
 }
 
-#define UC VIPS_FORMAT_UCHAR
-#define US VIPS_FORMAT_USHORT
-
-/* Except for 8-bit inputs, we send everything else to 16. We decide on png8
- * vs. png16 based on Type in_build(), see above.
- */
-static VipsBandFormat bandfmt_spng[10] = {
-	/* Band format:  UC  C   US  S   UI  I   F   X   D   DX */
-	/* Promotion: */ UC, UC, US, US, US, US, US, US, US, US
-};
+static const char *vips_foreign_save_spng_suffs[] = { ".png", NULL };
 
 static void
 vips_foreign_save_spng_class_init(VipsForeignSaveSpngClass *class)
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
-	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
-
-	gobject_class->dispose = vips_foreign_save_spng_dispose;
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "spngsave_base";
-	object_class->description = _("save spng");
-	object_class->build = vips_foreign_save_spng_build;
-
-	foreign_class->suffs = vips__png_suffs;
-
-	save_class->saveable = VIPS_SAVEABLE_RGBA;
-	save_class->format_table = bandfmt_spng;
-
-	VIPS_ARG_INT(class, "compression", 6,
-		_("Compression"),
-		_("Compression factor"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, compression),
-		0, 9, 6);
-
-	VIPS_ARG_BOOL(class, "interlace", 7,
-		_("Interlace"),
-		_("Interlace image"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, interlace),
-		FALSE);
-
-	VIPS_ARG_FLAGS(class, "filter", 12,
-		_("Filter"),
-		_("libspng row filter flag(s)"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, filter),
-		VIPS_TYPE_FOREIGN_PNG_FILTER,
-		VIPS_FOREIGN_PNG_FILTER_NONE);
-
-	VIPS_ARG_BOOL(class, "palette", 13,
-		_("Palette"),
-		_("Quantise to 8bpp palette"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, palette),
-		FALSE);
-
-	VIPS_ARG_INT(class, "Q", 15,
-		_("Quality"),
-		_("Quantisation quality"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, Q),
-		0, 100, 100);
-
-	VIPS_ARG_DOUBLE(class, "dither", 16,
-		_("Dithering"),
-		_("Amount of dithering"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, dither),
-		0.0, 1.0, 1.0);
-
-	VIPS_ARG_INT(class, "bitdepth", 17,
-		_("Bit depth"),
-		_("Write as a 1, 2, 4, 8 or 16 bit image"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, bitdepth),
-		1, 16, 8);
-
-	VIPS_ARG_INT(class, "effort", 18,
-		_("Effort"),
-		_("Quantisation CPU effort"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, effort),
-		1, 10, 7);
-
-	VIPS_ARG_INT(class, "colours", 14,
-		_("Colours"),
-		_("Max number of palette colours"),
-		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
-		G_STRUCT_OFFSET(VipsForeignSaveSpng, colours),
-		2, 256, 256);
+    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
+    VipsObjectClass *object_class = VIPS_OBJECT_CLASS(class);
+    VipsForeignClass *foreign_class = (VipsForeignClass *) class;
+
+    g_print("spngsave: Initializing VipsForeignSaveSpngClass\n");
+
+    gobject_class->dispose = vips_foreign_save_spng_dispose;
+
+    object_class->nickname = "spngsave";
+    object_class->description = "save PNG with libspng";
+    object_class->build = vips_foreign_save_spng_build;
+
+    VIPS_ARG_STRING(class, "filename", 1,
+        "Filename",
+        "Filename to save to",
+        VIPS_ARGUMENT_OPTIONAL_INPUT,
+        G_STRUCT_OFFSET(VipsForeignSaveSpng, filename),
+        NULL);
 }
 
 static void
 vips_foreign_save_spng_init(VipsForeignSaveSpng *spng)
 {
-	spng->compression = 6;
-	spng->filter = VIPS_FOREIGN_PNG_FILTER_NONE;
-	spng->Q = 100;
-	spng->dither = 1.0;
-	spng->effort = 7;
-}
-
-typedef struct _VipsForeignSaveSpngTarget {
-	VipsForeignSaveSpng parent_object;
-
-	VipsTarget *target;
-} VipsForeignSaveSpngTarget;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngTargetClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngTarget, vips_foreign_save_spng_target,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_target_build(VipsObject *object)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngTarget *target =
-		(VipsForeignSaveSpngTarget *) object;
-
-	spng->target = target->target;
-	g_object_ref(spng->target);
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_target_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
-}
-
-static void
-vips_foreign_save_spng_target_class_init(VipsForeignSaveSpngTargetClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngsave_target";
-	object_class->description = _("save image to target as PNG");
-	object_class->build = vips_foreign_save_spng_target_build;
-
-	VIPS_ARG_OBJECT(class, "target", 1,
-		_("Target"),
-		_("Target to save to"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngTarget, target),
-		VIPS_TYPE_TARGET);
-}
-
-static void
-vips_foreign_save_spng_target_init(VipsForeignSaveSpngTarget *target)
-{
-}
-
-typedef struct _VipsForeignSaveSpngFile {
-	VipsForeignSaveSpng parent_object;
-
-	char *filename;
-} VipsForeignSaveSpngFile;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngFileClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngFile, vips_foreign_save_spng_file,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_file_build(VipsObject *object)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngFile *file = (VipsForeignSaveSpngFile *) object;
-
-	if (!(spng->target = vips_target_new_to_file(file->filename)))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_file_parent_class)
-			->build(object))
-		return -1;
-
-	return 0;
-}
-
-static void
-vips_foreign_save_spng_file_class_init(VipsForeignSaveSpngFileClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngsave";
-	object_class->description = _("save image to file as PNG");
-	object_class->build = vips_foreign_save_spng_file_build;
-
-	VIPS_ARG_STRING(class, "filename", 1,
-		_("Filename"),
-		_("Filename to save to"),
-		VIPS_ARGUMENT_REQUIRED_INPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngFile, filename),
-		NULL);
-}
-
-static void
-vips_foreign_save_spng_file_init(VipsForeignSaveSpngFile *file)
-{
-}
-
-typedef struct _VipsForeignSaveSpngBuffer {
-	VipsForeignSaveSpng parent_object;
-
-	VipsArea *buf;
-} VipsForeignSaveSpngBuffer;
-
-typedef VipsForeignSaveSpngClass VipsForeignSaveSpngBufferClass;
-
-G_DEFINE_TYPE(VipsForeignSaveSpngBuffer, vips_foreign_save_spng_buffer,
-	vips_foreign_save_spng_get_type());
-
-static int
-vips_foreign_save_spng_buffer_build(VipsObject *object)
-{
-	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
-	VipsForeignSaveSpngBuffer *buffer =
-		(VipsForeignSaveSpngBuffer *) object;
-
-	VipsBlob *blob;
-
-	if (!(spng->target = vips_target_new_to_memory()))
-		return -1;
-
-	if (VIPS_OBJECT_CLASS(vips_foreign_save_spng_buffer_parent_class)
-			->build(object))
-		return -1;
-
-	g_object_get(spng->target, "blob", &blob, NULL);
-	g_object_set(buffer, "buffer", blob, NULL);
-	vips_area_unref(VIPS_AREA(blob));
-
-	return 0;
-}
-
-static void
-vips_foreign_save_spng_buffer_class_init(VipsForeignSaveSpngBufferClass *class)
-{
-	GObjectClass *gobject_class = G_OBJECT_CLASS(class);
-	VipsObjectClass *object_class = (VipsObjectClass *) class;
-
-	gobject_class->set_property = vips_object_set_property;
-	gobject_class->get_property = vips_object_get_property;
-
-	object_class->nickname = "pngsave_buffer";
-	object_class->description = _("save image to buffer as PNG");
-	object_class->build = vips_foreign_save_spng_buffer_build;
-
-	VIPS_ARG_BOXED(class, "buffer", 1,
-		_("Buffer"),
-		_("Buffer to save to"),
-		VIPS_ARGUMENT_REQUIRED_OUTPUT,
-		G_STRUCT_OFFSET(VipsForeignSaveSpngBuffer, buf),
-		VIPS_TYPE_BLOB);
-}
-
-static void
-vips_foreign_save_spng_buffer_init(VipsForeignSaveSpngBuffer *buffer)
-{
+    spng->file = NULL;
+    spng->filename = NULL;
 }
 
 #endif /*HAVE_SPNG*/
diff '--color=auto' -urpN vips-8.16.1.orig/libvips/foreign/spngsave.h vips-8.16.1/libvips/foreign/spngsave.h
--- vips-8.16.1.orig/libvips/foreign/spngsave.h	1969-12-31 16:00:00.000000000 -0800
+++ vips-8.16.1/libvips/foreign/spngsave.h	2025-07-13 02:23:09.715061572 -0700
@@ -0,0 +1,9 @@
+#ifndef VIPS_SPNGSAVE_H
+#define VIPS_SPNGSAVE_H
+
+#include <vips/vips.h>
+
+VIPS_API
+GType vips_foreign_save_spng_get_type(void);
+
+#endif /*VIPS_SPNGSAVE_H*/
