diff -urp AppImageKit-9999.orig/ci/build-appdir.sh AppImageKit-9999/ci/build-appdir.sh
--- AppImageKit-9999.orig/ci/build-appdir.sh	2023-01-14 15:38:12.689903859 -0800
+++ AppImageKit-9999/ci/build-appdir.sh	2023-01-14 15:38:43.939141372 -0800
@@ -39,12 +39,17 @@ mkdir -p "$appimagetool_appdir"/usr/lib/
 
 # Copy AppDir specific files
 cp "$repo_root"/resources/AppRun "$appimagetool_appdir"
+if ! [ -e "$install_prefix"/usr/lib/appimagekit/mksquashfs ] ; then
+    mkdir -p "$install_prefix"/usr/lib/appimagekit
+    cp $(which mksquashfs) "$install_prefix"/usr/lib/appimagekit
+fi
 cp "$install_prefix"/usr/lib/appimagekit/mksquashfs "$appimagetool_appdir"/usr/lib/appimagekit/
 
-# prefer binaries from /deps, if available
-export PATH=/deps/bin:"$PATH"
+# prefer binaries from ${WORKDIR}/deps, if available
+export PATH="${WORKDIR}/deps/bin:$PATH"
 cp "$(which desktop-file-validate)" "$appimagetool_appdir"/usr/bin/
 cp "$(which zsyncmake)" "$appimagetool_appdir"/usr/bin/
+cp "$(which appstreamcli)" "$appimagetool_appdir"/usr/bin/ || die
 
 cp "$repo_root"/resources/appimagetool.desktop "$appimagetool_appdir"
 cp "$repo_root"/resources/appimagetool.png "$appimagetool_appdir"/appimagetool.png
@@ -54,10 +59,10 @@ cp "$appimagetool_appdir"/appimagetool.p
 # https://github.com/AppImage/AppImageKit/issues/1171
 install -D "$(which desktop-file-validate)" "$appimagetool_appdir"/usr/bin/
 
-if [ -d /deps/ ]; then
+if [ -d "${WORKDIR}/deps/" ]; then
     # deploy GLib, gpgme and gcrypt
     mkdir -p "$appimagetool_appdir"/usr/lib/
-    cp /deps/lib/lib*.so* "$appimagetool_appdir"/usr/lib/
+    cp "${WORKDIR}"/deps/lib/lib*.so* "$appimagetool_appdir"/usr/lib/
 
 
     case "$ARCH" in
@@ -81,6 +86,7 @@ if [ -d /deps/ ]; then
     # see this thread for more information on the topic:
     # https://mail.gnome.org/archives/gtk-devel-list/2012-July/msg00062.html
     # libpcre is used by desktop-file-validate
+    [ "${CI}" != "" ] && \
     for pattern in libffi libpcre; do
         # even though it is likely not necessary, we deploy every viable version of the libraries just to make sure...
         ldconfig -p | grep "$pattern" | grep "$libarch" | while read -r line; do
@@ -88,4 +94,6 @@ if [ -d /deps/ ]; then
             cp "$lib" "$appimagetool_appdir"/usr/lib/
         done
     done
+    cp "libffi.so"* "$appimagetool_appdir"/usr/lib/
+    cp "libpcre.so" "$appimagetool_appdir"/usr/lib/
 fi
diff -urp AppImageKit-9999.orig/ci/build-binaries-and-appimage.sh AppImageKit-9999/ci/build-binaries-and-appimage.sh
--- AppImageKit-9999.orig/ci/build-binaries-and-appimage.sh	2023-01-14 15:38:12.689903859 -0800
+++ AppImageKit-9999/ci/build-binaries-and-appimage.sh	2023-01-14 15:38:43.943141531 -0800
@@ -6,9 +6,9 @@ set -o functrace
 
 # make sure the prebuilt libraries in the container will be found
 # (in case we're building in an AppImageBuild container)
-export LD_LIBRARY_PATH=/deps/lib:"$LD_LIBRARY_PATH"
-export PKG_CONFIG_PATH=/deps/lib/pkgconfig/
-export PATH=/deps/bin:"$PATH"
+export LD_LIBRARY_PATH="${WORKDIR}/deps/lib:$LD_LIBRARY_PATH"
+export PKG_CONFIG_PATH="${WORKDIR}/deps/lib/pkgconfig/"
+export PATH="${WORKDIR}/deps/bin:$PATH"
 
 # note: signing is not working at the moment
 # see ci-build.sh for more information
@@ -24,7 +24,9 @@ if [ -d /dev/shm ] && mount | grep /dev/
         USE_SHM=1
     fi
 fi
-if [[ "$USE_SHM" = "1" ]]; then
+if [[ -e "${T}" ]] ; then
+    TEMP_BASE="${T}"
+elif [[ "$USE_SHM" = "1" ]]; then
     TEMP_BASE=/dev/shm
 elif [ -d /docker-ramdisk ]; then
     TEMP_BASE=/docker-ramdisk
@@ -40,7 +42,7 @@ cleanup () {
     fi
 }
 
-trap cleanup EXIT
+#trap cleanup EXIT
 
 REPO_ROOT="$(readlink -f "$(dirname "${BASH_SOURCE[0]}")"/..)"
 OLD_CWD="$(readlink -f .)"
@@ -52,7 +54,11 @@ cmake "$REPO_ROOT" \
     -DCMAKE_INSTALL_PREFIX=/usr \
     -DCMAKE_BUILD_TYPE=RelWithDebInfo \
     -DBUILD_TESTING=ON \
-    -DAPPIMAGEKIT_PACKAGE_DEBS=ON
+    -DAPPIMAGEKIT_PACKAGE_DEBS=ON \
+    -DUSE_SYSTEM_LIBAPPIMAGE=ON \
+    -DUSE_SYSTEM_MKSQUASHFS=ON \
+    -DUSE_SYSTEM_SQUASHFUSE=ON \
+    -DUSE_SYSTEM_XZ=ON
 
 # run build
 if [[ "$CI" != "" ]]; then
@@ -96,7 +102,7 @@ find "$install_prefix"
 # seems to work -- let's build an AppImage
 # we start by putting the rest of the files into the AppDir
 
-"$appdir"/AppRun ./appimagetool.AppDir/ -v \
+"$appdir"/AppRun ./appimagetool.AppDir/ -n -v \
     -u "gh-releases-zsync|AppImage|AppImageKit|continuous|appimagetool-$ARCH.AppImage.zsync" \
     appimagetool-"$ARCH".AppImage
 
diff -urp AppImageKit-9999.orig/ci/build.sh AppImageKit-9999/ci/build.sh
--- AppImageKit-9999.orig/ci/build.sh	2023-01-14 15:38:12.689903859 -0800
+++ AppImageKit-9999/ci/build.sh	2023-01-14 15:40:33.007460348 -0800
@@ -53,16 +53,25 @@ repo_root="$this_dir"/..
 # docker image name
 docker_image=quay.io/appimage/appimagebuild:"$docker_dist"-"${docker_arch:-$ARCH}"
 # make sure it's up to date
-docker pull "$docker_image"
+if [ "${CI}" != "" ] ; then
+    docker pull "$docker_image"
+fi
 
 # prepare output directory
-mkdir -p out/
+if [[ "$CI" != "" ]] ; then
+    OUTPUT_DIR="out"
+    OUTPUT_ADIR="/out"
+else
+    OUTPUT_DIR="${WORKDIR}/out"
+    OUTPUT_ADIR="${WORKDIR}/out"
+fi
+mkdir -p "${OUTPUT_DIR}/"
 
 # we run all builds with non-privileged user accounts to make sure the build doesn't depend on such features
 uid="$(id -u)"
 
 # When running under Podman (on hosts where `docker` is a shim that invokes `podman`),
-# UID/GID mappings may lead to permission errors when copying artifacts to `/out`.
+# UID/GID mappings may lead to permission errors when copying artifacts to `${OUTPUT_ADIR}`.
 # We set the user namespace mode to `keep-id` to make sure that the host UID/GID
 # are mapped to the same values inside the container, but using this environment
 # variable (a) to not affect builds using Docker, and (b) to allow overriding the
@@ -75,7 +84,7 @@ common_docker_opts=(
     -e ARCH="$ARCH"
     -i
     -v "$repo_root":/ws
-    -v "$(readlink -f out/)":/out
+    -v $(readlink -f "${OUTPUT_DIR}/"):"${OUTPUT_ADIR}"
 )
 
 # make ctrl-c work
@@ -87,12 +96,16 @@ fi
 # TODO: make gnupg home available, e.g., through "-v" "$HOME"/.gnupg:/root/.gnupg
 # TODO: this ^ won't work since we don't build as root any more
 # note: we enforce using the same UID in the container as outside, so that the created files are owned by the caller
-docker run --rm \
-    --user "$uid" \
-    "${common_docker_opts[@]}" \
-    "-v" "$HOME"/.gnupg:/root/.gnupg \
-    "$docker_image" \
-    /bin/bash -xc "cd /out && /ws/ci/build-binaries-and-appimage.sh --run-tests"
+if [ "${CI}" != "" ] ; then
+    docker run --rm \
+        --user "$uid" \
+        "${common_docker_opts[@]}" \
+        "-v" "$HOME"/.gnupg:/root/.gnupg \
+        "$docker_image" \
+        /bin/bash -xc "cd ${OUTPUT_ADIR} && /ws/ci/build-binaries-and-appimage.sh --run-tests"
+else
+        cd "${OUTPUT_ADIR}" && "${S}/ci/build-binaries-and-appimage.sh" --run-tests
+fi
 
 # test appimagetool-"$ARCH".AppImage
 # note: if we're in a CI system, we allow the use of FUSE in the container, to make sure that this functionality works as intended
@@ -119,22 +132,27 @@ if [[ "$ARCH" != "arm"* ]] && [[ "$ARCH"
 
     # to make fuse happy, we need to use a "real" user
     # as we don't want to use root, we use the user "build" we created in AppImageBuild
-    docker run --rm \
-        --user build \
-        "${docker_test_opts[@]}" \
-        "$docker_image" \
-        /bin/bash -xc "cd /out && bash /ws/ci/test-appimage.sh ./appimagetool-\"$ARCH\".AppImage"
+    if [ "${CI}" != "" ] ; then
+        docker run --rm \
+            --user build \
+            "${docker_test_opts[@]}" \
+            "$docker_image" \
+            /bin/bash -xc "cd ${OUTPUT_ADIR} && bash /ws/ci/test-appimage.sh ./appimagetool-\"$ARCH\".AppImage"
+    else
+        # Something is broken
+        cd "${OUTPUT_ADIR}" && "${S}/ci/test-appimage.sh" "./appimagetool-$ARCH.AppImage"
+    fi
 fi
 
 # remove binaries from output directory
-ls -al out/
-rm out/appimagetool
-rm out/{validate,digest}
+ls -al "${OUTPUT_DIR}/"
+rm "${OUTPUT_DIR}/appimagetool"
+rm "${OUTPUT_DIR}/"{validate,digest}
 
 # make sure the runtime contains the magic bytes
-hexdump -Cv out/runtime | head -n 1 | grep "41 49 02 00"
+hexdump -Cv "${OUTPUT_DIR}/runtime" | head -n 1 | grep "41 49 02 00"
 # fix filename for upload
-mv out/runtime out/runtime-"$ARCH"
+mv "${OUTPUT_DIR}/runtime" "${OUTPUT_DIR}/runtime-$ARCH"
 
 # fix filename for upload
-mv out/AppRun out/AppRun-"$ARCH"
+mv "${OUTPUT_DIR}/AppRun" "${OUTPUT_DIR}/AppRun-$ARCH"
diff -urp AppImageKit-9999.orig/ci/test-appimage.sh AppImageKit-9999/ci/test-appimage.sh
--- AppImageKit-9999.orig/ci/test-appimage.sh	2023-01-14 15:38:12.689903859 -0800
+++ AppImageKit-9999/ci/test-appimage.sh	2023-01-14 15:38:43.943141531 -0800
@@ -20,11 +20,15 @@ fi
 appimagetool="$1"
 
 if [[ "$PATCH_OUT_MAGIC_BYTES" != "" ]]; then
-    tmpdir="$(mktemp -d /tmp/appimage-test-XXXXX)"
+    if [[ -e "${T}" ]] ; then
+        tmpdir=$(mktemp -d "${T}/appimage-test-XXXXX")
+    else
+        tmpdir="$(mktemp -d /tmp/appimage-test-XXXXX)"
+    fi
     cleanup() {
         [[ -d "$tmpdir" ]] && rm -r "$tmpdir"
     }
-    trap cleanup EXIT
+    #trap cleanup EXIT
 
     echo "Copying appimagetool and patching out magic bytes"
     cp "$appimagetool" "$tmpdir/"
diff -urp AppImageKit-9999.orig/ci/test-appimagetool.sh AppImageKit-9999/ci/test-appimagetool.sh
--- AppImageKit-9999.orig/ci/test-appimagetool.sh	2023-01-14 15:38:12.689903859 -0800
+++ AppImageKit-9999/ci/test-appimagetool.sh	2023-01-14 15:38:43.943141531 -0800
@@ -23,7 +23,9 @@ fi
 
 # we always build in a temporary directory
 # use RAM disk if possible
-if [ -d /dev/shm ] && mount | grep /dev/shm | grep -v -q noexec; then
+if [[ -e "${T}" ]] ; then
+    TEMP_BASE="${T}"
+elif [ -d /dev/shm ] && mount | grep /dev/shm | grep -v -q noexec; then
     TEMP_BASE=/dev/shm
 elif [ -d /docker-ramdisk ]; then
     TEMP_BASE=/docker-ramdisk
@@ -39,7 +41,7 @@ cleanup () {
     fi
 }
 
-trap cleanup EXIT
+#trap cleanup EXIT
 
 REPO_ROOT="$(readlink -f "$(dirname "${BASH_SOURCE[0]}")"/..)"
 OLD_CWD="$(readlink -f .)"
diff -urp AppImageKit-9999.orig/cmake/toolchains/aarch64-linux-gnu.cmake AppImageKit-9999/cmake/toolchains/aarch64-linux-gnu.cmake
--- AppImageKit-9999.orig/cmake/toolchains/aarch64-linux-gnu.cmake	2023-01-14 15:38:12.693904017 -0800
+++ AppImageKit-9999/cmake/toolchains/aarch64-linux-gnu.cmake	2023-01-14 15:38:43.943141531 -0800
@@ -10,9 +10,9 @@ set(CMAKE_CXX_COMPILER "${triple}-g++" C
 
 set(TOOLS_PREFIX "${triple}-" CACHE STRING "" FORCE)
 
-set(DEPENDENCIES_CFLAGS "-I/deps/include" CACHE STRING "" FORCE)
+set(DEPENDENCIES_CFLAGS "-I${WORKDIR}/deps/include" CACHE STRING "" FORCE)
 set(DEPENDENCIES_CPPFLAGS "${DEPENDENCIES_CFLAGS}" CACHE STRING "" FORCE)
-set(DEPENDENCIES_LDFLAGS "-L/deps/lib/" CACHE STRING "" FORCE)
+set(DEPENDENCIES_LDFLAGS "-L${WORKDIR}/deps/lib/" CACHE STRING "" FORCE)
 
 # host = target system
 # build = build system
diff -urp AppImageKit-9999.orig/cmake/toolchains/arm-linux-gnueabihf.cmake AppImageKit-9999/cmake/toolchains/arm-linux-gnueabihf.cmake
--- AppImageKit-9999.orig/cmake/toolchains/arm-linux-gnueabihf.cmake	2023-01-14 15:38:12.693904017 -0800
+++ AppImageKit-9999/cmake/toolchains/arm-linux-gnueabihf.cmake	2023-01-14 15:38:43.943141531 -0800
@@ -10,9 +10,9 @@ set(CMAKE_CXX_COMPILER "${triple}-g++" C
 
 set(TOOLS_PREFIX "${triple}-" CACHE STRING "" FORCE)
 
-set(DEPENDENCIES_CFLAGS "-I/deps/include" CACHE STRING "" FORCE)
+set(DEPENDENCIES_CFLAGS "-I${WORKDIR}/deps/include" CACHE STRING "" FORCE)
 set(DEPENDENCIES_CPPFLAGS "${DEPENDENCIES_CFLAGS}" CACHE STRING "" FORCE)
-set(DEPENDENCIES_LDFLAGS "-L/deps/lib/" CACHE STRING "" FORCE)
+set(DEPENDENCIES_LDFLAGS "-L${WORKDIR}/deps/lib/" CACHE STRING "" FORCE)
 
 # host = target system
 # build = build system
diff -urp AppImageKit-9999.orig/lib/libappimage/travis/build-and-test.sh AppImageKit-9999/lib/libappimage/travis/build-and-test.sh
--- AppImageKit-9999.orig/lib/libappimage/travis/build-and-test.sh	2023-01-14 15:38:16.298046748 -0800
+++ AppImageKit-9999/lib/libappimage/travis/build-and-test.sh	2023-01-14 15:38:43.943141531 -0800
@@ -4,7 +4,9 @@ set -e
 set -x
 
 # use RAM disk if possible
-if [ "$CI" == "" ] && [ -d /dev/shm ]; then
+if [[ -e "${T}" ]] ; then
+    TEMP_BASE="${T}"
+elif [ "$CI" == "" ] && [ -d /dev/shm ]; then
     TEMP_BASE=/dev/shm
 else
     TEMP_BASE=/tmp
