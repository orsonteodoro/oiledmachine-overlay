--- a/src/components/messageInput.tsx.orig	2025-08-10 10:13:57.474745277 -0700
+++ b/src/components/messageInput.tsx	2025-08-10 10:15:44.974276221 -0700
@@ -63,7 +63,9 @@ export default function MessageInput({
             // both are 16000
             const audioCtx = new AudioContext();
             const buffer = audioCtx.createBuffer(1, audio.length, 16000);
-            buffer.copyToChannel(audio, 0, 0);
+            const arrayBuffer = audio.buffer instanceof ArrayBuffer ? audio.buffer : new ArrayBuffer(audio.buffer.byteLength);
+            const audioArrayBuffer = new Float32Array(arrayBuffer);
+            buffer.copyToChannel(audioArrayBuffer, 0, 0);
             transcriber.start(buffer);
             break;
           }
@@ -71,7 +73,18 @@ export default function MessageInput({
             console.debug('whisper_openai attempt');
             const wav = new WaveFile();
             wav.fromScratch(1, 16000, '32f', audio);
-            const file = new File([wav.toBuffer()], "input.wav", { type: "audio/wav" });
+
+            // Convert Uint8Array<ArrayBufferLike> to Uint8Array<ArrayBuffer>
+            const wavBuffer = wav.toBuffer();
+            const arrayBuffer = wavBuffer.buffer instanceof ArrayBuffer
+              ? wavBuffer.buffer
+              : new ArrayBuffer(wavBuffer.buffer.byteLength);
+            const wavArrayBuffer = new Uint8Array(arrayBuffer);
+            if (!(wavBuffer.buffer instanceof ArrayBuffer)) {
+              wavArrayBuffer.set(wavBuffer); // Copy data if necessary
+            }
+
+            const file = new File([wavArrayBuffer], "input.wav", { type: "audio/wav" });
 
             let prompt;
             // TODO load prompt if it exists
@@ -92,7 +105,18 @@ export default function MessageInput({
             const wav = new WaveFile();
             wav.fromScratch(1, 16000, '32f', audio);
             wav.toBitDepth('16');
-            const file = new File([wav.toBuffer()], "input.wav", { type: "audio/wav" });
+
+            // Convert Uint8Array<ArrayBufferLike> to Uint8Array<ArrayBuffer>
+            const wavBuffer = wav.toBuffer();
+            const arrayBuffer = wavBuffer.buffer instanceof ArrayBuffer
+              ? wavBuffer.buffer
+              : new ArrayBuffer(wavBuffer.buffer.byteLength);
+            const wavArrayBuffer = new Uint8Array(arrayBuffer);
+            if (!(wavBuffer.buffer instanceof ArrayBuffer)) {
+              wavArrayBuffer.set(wavBuffer); // Copy data if necessary
+            }
+
+            const file = new File([wavArrayBuffer], "input.wav", { type: "audio/wav" });
 
             let prompt;
             // TODO load prompt if it exists
--- a/src/features/lipSync/lipSync.ts.orig	2025-08-10 10:48:11.905368127 -0700
+++ b/src/features/lipSync/lipSync.ts	2025-08-10 10:51:49.742468255 -0700
@@ -11,15 +11,28 @@ export class LipSync {
     this.audio = audio;
 
     this.analyser = audio.createAnalyser();
-    this.timeDomainData = new Float32Array(TIME_DOMAIN_DATA_LENGTH);
+    this.analyser.fftSize = TIME_DOMAIN_DATA_LENGTH; // Ensure fftSize matches
+    // Explicitly create Float32Array with ArrayBuffer
+    const arrayBuffer: ArrayBuffer = new ArrayBuffer(TIME_DOMAIN_DATA_LENGTH * 4); // 4 bytes per float
+    this.timeDomainData = new Float32Array(arrayBuffer);
   }
 
   public update(): LipSyncAnalyzeResult {
-    this.analyser.getFloatTimeDomainData(this.timeDomainData);
+    // Ensure compatibility by creating a new Float32Array if needed
+    const compatibleData: Float32Array = new Float32Array(
+      this.timeDomainData.buffer instanceof ArrayBuffer
+        ? this.timeDomainData.buffer
+        : new ArrayBuffer(TIME_DOMAIN_DATA_LENGTH * 4)
+    );
+    if (!(this.timeDomainData.buffer instanceof ArrayBuffer)) {
+      compatibleData.set(this.timeDomainData); // Copy data if necessary
+    }
+
+    this.analyser.getFloatTimeDomainData(compatibleData);
 
     let volume = 0.0;
     for (let i = 0; i < TIME_DOMAIN_DATA_LENGTH; i++) {
-      volume = Math.max(volume, Math.abs(this.timeDomainData[i]));
+      volume = Math.max(volume, Math.abs(compatibleData[i]));
     }
 
     // cook
