<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pkgmetadata SYSTEM "https://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<!-- ebuild fork only on the oiledmachine-overlay -->
		<name>Orson Teodoro</name>
		<email>orsonteodoro@hotmail.com</email>
	</maintainer>
	<maintainer type="project">
		<!-- ebuild originators -->
		<email>llvm@gentoo.org</email>
	</maintainer>
	<longdescription>
	Low Level Virtual Machine (LLVM) is:

	1. A compilation strategy designed to enable effective program optimization
		across the entire lifetime of a program. LLVM supports effective
		optimization at compile time, link-time (particularly interprocedural),
		run-time and offline (i.e., after software is installed), while
		remaining transparent to developers and maintaining compatibility with
		existing build scripts.
	2. A virtual instruction set - LLVM is a low-level object code representation
		that uses simple RISC-like instructions, but provides rich,
		language-independent, type information and dataflow (SSA) information
		about operands. This combination enables sophisticated transformations
		on object code, while remaining light-weight enough to be attached to
		the executable. This combination is key to allowing link-time, run-time,
		and offline transformations.
	3. A compiler infrastructure - LLVM is also a collection of source code that
		implements the language and compilation strategy. The primary components
		of the LLVM infrastructure are a GCC-based C and C++ front-end, a
		link-time optimization framework with a growing set of global and
		interprocedural analyses and transformations, static back-ends for many
		popular (and some obscure) architectures, a back-end which emits
		portable C code, and a Just-In-Time compilers for several architectures.
	4. LLVM does not imply things that you would expect from a high-level virtual
		machine. It does not require garbage collection or run-time code
		generation (In fact, LLVM makes a great static compiler!). Note that
		optional LLVM components can be used to build high-level virtual
		machines and other systems that need these services.

	This ebuild fork changes the following:

		* Makes available, builds, installs BOLT support.
		* Reduce spam and slowdown with -static-libstdc++.
		* Applies disable-peepholes patch for stability or overlap reasons.
		* Profile Guided Optimization (PGO) build support.

	For this repo only, due to limited time and lack of time to verify working
	ebuilds completely, only live ebuilds and point releases will be kept.  Release
	candidates and inits will be ignored.


	PGO notes:

	The motiviation for PGOing this library is that it serves as the backend
	to clang containing optimization portion for the IR (Intermediate
	Representation).

	Choose one of the correct steps to building a PGO optimized build:

	As clang[-bootstrap] USE flag:

	1. emerge -1 =llvm-${PV}[bootstrap,-pgo,abi0,...,abiN]
	2. emerge -1 lld
	3. emerge -1 =clang-${PV}[-pgo,abi0,...,abiN]
	4. emerge -1 =llvm-${PV}[-bootstrap,pgo,pgo_trainer...]
	5. emerge -1 =clang-${PV}[-bootstrap,pgo,abi0,...,abiN,pgo_trainer...]

	As clang[+bootstrap] USE flag:

	1. emerge -1 =llvm-${PV}[bootstrap,-pgo,abi0,...,abiN]
	2. emerge -1 lld
	3. emerge -1 =clang-${PV}[bootstrap,pgo,abi0,...,abiN,pgo_trainer...]
	4. emerge -1 =llvm-${PV}[-bootstrap,pgo,pgo_trainer...]

	Both llvm-${PV} and clang-${PV} have matching ${PV}s (or commits) within the
	  same slots to avoid missing symbols.
	The abi0, ..., abiN set must match in llvm-${PV} and in clang-${PV}.
	PGO trainer(s) must be chosen that reflect typical use.


	An environment variable named EGIT_COMMIT_LLVM_TEST_SUITE can be used to
	checkout the exact commit for the llvm-test-suite repo for the branch
	with the same major version.  By default it is set to the latest
	commit of that branch in live ebuilds and to the same point release
	in point releases.


	BOLT notes:

	BOLT support requires commit 4c106cfdf7cf7eec861ad3983a3dd9a9e8f3a8ae or newer
	circa Jan 11, 2022 and is only offered in LLVM 14 or newer.  In its current
	form it requires LBR support for the CPU.

	BOLT users please see
	https://github.com/llvm/llvm-project/blob/main/bolt/README.md#input-binary-requirements
	https://github.com/llvm/llvm-project/blob/main/bolt/docs/OptimizingClang.md


	BOLT optimized builds steps:

	1.  emerge -1 llvm-${PV}:${SLOT}[bolt,bolt-prepare]
	2.  emerge -1 lld
	3.  emerge -1 clang:${PV}:${SLOT}[bolt]
	4.  emerge --config =llvm-${PV}

	Both clang must be built with the same ${SLOT} as llvm, but the llvm backend
	should be the same version or commit as the one used to build with clang.  BOLT
	profiling is done within the clang package.  This profile(s) is then used in
	step 4 to generate an optimized libLLVM.so.  libLLVM.so contains the binary
	code (or brains) used as the optimization backend for clang.

	BOLT profiling for the LLVM library is done in the clang package and not within
	this package.  Some reasons why it is designed this way:

	1.  It reduces the duplicate code between the two packages for BOLT training.
	2.  BOLT training is performed only in one run instead of two times.
	3.  It avoids the missing symbol problem when using clang, which is the
	biggest reason.
	4.  Less maintenence cost in trying to fix both packages.
	5.  Running the BOLT profiling inside the clang package closely resembles
	typical use.


	disable-peepholes notes:

	To obtain the default behavior as if disable-peepholes was not applied, one may
	pass to C{,XX}FLAGS

	  -mllvm -disable-wrongs-opts=false -mllvm -disable-all-peepholes=false

	The patch defaults are effectively set to

	  -mllvm -disable-wrongs-opts=true -mllvm -disable-all-peepholes=false


	References:
	[1] https://llvm.org/docs/HowToBuildWithPGO.html
	</longdescription>
	<use>
		<flag name="binutils-plugin">Build the binutils plugin</flag>
		<flag name="bolt">Build the Binary Optimization and Layout Tool
			to improve CPU caching and branch prediction using execution
			sampling data used to optimize code layout.  (EXPERIMENTAL)
			</flag>
		<flag name="bolt-prepare">BOLT prepare the LLVM library.</flag>
		<flag name="bootstrap">Build against a vanilla unpatched compiler.  This
			USE flag can be used to undo a broken build by avoiding a
			possibly broken patched one or a broken LLVM lib build.</flag>
		<flag name="dump">Build with dump functions to print additional
			(debugging) information</flag>
		<flag name="doc">Build and install the HTML documentation and regenerate
			the man pages</flag>
		<flag name="exegesis">Enable performance counter support for
			llvm-exegesis tool that can be used to measure host machine
			instruction characteristics</flag>
		<flag name="gold">Build the gold linker plugin</flag>
		<flag name="ncurses">Support querying terminal properties using ncurses'
			terminfo</flag>
		<flag name="pgo">Build with Profile Guided Optimization which may reduce
			compile times of other programs by 20%, with a PGOed clang
			package.</flag>
		<flag name="pgo_trainer_build_self">Trains and generates a PGO profile by
			building the source code itself</flag>
		<flag name="pgo_trainer_test_suite">Runs the test-suite to build a
			PGO profile from built benchmarks examples which may be consumed
			by the optimizers.</flag>
		<flag name="xar">Support dumping LLVM bitcode sections in Mach-O files
			(uses <pkg>app-arch/xar</pkg>)</flag>
		<flag name="z3">Enable support for <pkg>sci-mathematics/z3</pkg>
			constraint solver</flag>
		<flag name="rN">FOR INTERNAL USE ONLY.  Bump revision but save CCACHE
			paths for faster rebuilds.</flag>
	</use>
</pkgmetadata>
