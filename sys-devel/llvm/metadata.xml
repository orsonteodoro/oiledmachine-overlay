<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pkgmetadata SYSTEM "https://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer type="person">
		<!-- ebuild fork only on the oiledmachine-overlay -->
		<name>Orson Teodoro</name>
		<email>orsonteodoro@hotmail.com</email>
	</maintainer>
	<maintainer type="project">
		<!-- ebuild originators -->
		<email>llvm@gentoo.org</email>
	</maintainer>
	<longdescription>
	Low Level Virtual Machine (LLVM) is:

	1. A compilation strategy designed to enable effective program optimization
		across the entire lifetime of a program. LLVM supports effective
		optimization at compile time, link-time (particularly interprocedural),
		run-time and offline (i.e., after software is installed), while
		remaining transparent to developers and maintaining compatibility with
		existing build scripts.
	2. A virtual instruction set - LLVM is a low-level object code representation
		that uses simple RISC-like instructions, but provides rich,
		language-independent, type information and dataflow (SSA) information
		about operands. This combination enables sophisticated transformations
		on object code, while remaining light-weight enough to be attached to
		the executable. This combination is key to allowing link-time, run-time,
		and offline transformations.
	3. A compiler infrastructure - LLVM is also a collection of source code that
		implements the language and compilation strategy. The primary components
		of the LLVM infrastructure are a GCC-based C and C++ front-end, a
		link-time optimization framework with a growing set of global and
		interprocedural analyses and transformations, static back-ends for many
		popular (and some obscure) architectures, a back-end which emits
		portable C code, and a Just-In-Time compilers for several architectures.
	4. LLVM does not imply things that you would expect from a high-level virtual
		machine. It does not require garbage collection or run-time code
		generation (In fact, LLVM makes a great static compiler!). Note that
		optional LLVM components can be used to build high-level virtual
		machines and other systems that need these services.

	This ebuild fork changes the following:

		* Makes available, builds, installs BOLT support.
		* Reduce spam and slowdown with -static-libstdc++.
		* Applies disable-peepholes patch for stability or overlap reasons.
		* Profile Guided Optimization (PGO) build support.

	For this repo only, due to limited time and lack of time to verify working
	ebuilds completely, only live ebuilds and point releases will be kept.  Release
	candidates and inits will be ignored.


	PGO notes:

	The motiviation for PGOing this library is that it serves as the backend
	to clang containing optimization portion for the IR (Intermediate
	Representation).

	Choose one of the correct steps to building a PGO optimized build:

	As clang[-bootstrap] USE flag:

	1. emerge -1 =llvm-${PV}[bootstrap,-pgo,abi0,...,abiN]
	2. emerge -1 lld
	3. emerge -1 =clang-${PV}[-pgo,abi0,...,abiN]
	4. emerge -1 =llvm-${PV}[-bootstrap,pgo,pgo_trainer...]
	5. emerge -1 =clang-${PV}[-bootstrap,pgo,abi0,...,abiN,pgo_trainer...]

	As clang[+bootstrap] USE flag:

	1. emerge -1 =llvm-${PV}[bootstrap,-pgo,abi0,...,abiN]
	2. emerge -1 lld
	3. emerge -1 =clang-${PV}[bootstrap,pgo,abi0,...,abiN,pgo_trainer...]
	4. emerge -1 =llvm-${PV}[-bootstrap,pgo,pgo_trainer...]

	Both llvm-${PV} and clang-${PV} have matching ${PV}s (or commits) within the
	  same slots to avoid missing symbols.
	The abi0, ..., abiN set must match in llvm-${PV} and in clang-${PV}.
	PGO trainer(s) must be chosen that reflect typical use.


	An environment variable named EGIT_COMMIT_LLVM_TEST_SUITE can be used to
	checkout the exact commit for the llvm-test-suite repo for the branch
	with the same major version.  By default it is set to the latest
	commit of that branch in live ebuilds and to the same point release
	in point releases.


	BOLT notes:

	BOLT support requires commit 4c106cfdf7cf7eec861ad3983a3dd9a9e8f3a8ae or newer
	circa Jan 11, 2022 and is only offered in LLVM 14 or newer.

	BOLT users please see
	https://github.com/llvm/llvm-project/blob/main/bolt/README.md#input-binary-requirements
	https://github.com/llvm/llvm-project/blob/main/bolt/docs/OptimizingClang.md


	disable-peepholes notes:

	To obtain the default behavior as if disable-peepholes was not applied, one may
	pass to C{,XX}FLAGS

	  -mllvm -disable-wrongs-opts=false -mllvm -disable-all-peepholes=false

	The patch defaults are effectively set to

	  -mllvm -disable-wrongs-opts=true -mllvm -disable-all-peepholes=false

	</longdescription>
	<use>
		<flag name="binutils-plugin">Build the binutils plugin</flag>
		<flag name="bolt">Build the Binary Optimization and Layout Tool
			to improve CPU caching and branch prediction using execution
			sampling data used to optimize code layout.  (EXPERIMENTAL)
			</flag>
		<flag name="bootstrap">Build against a vanilla unpatched compiler.  This
			USE flag can be used to undo a broken build by avoiding a
			possibly broken patched one or a broken LLVM lib build.</flag>
		<flag name="dump">Build with dump functions to print additional
			(debugging) information</flag>
		<flag name="doc">Build and install the HTML documentation and regenerate
			the man pages</flag>
		<flag name="exegesis">Enable performance counter support for
			llvm-exegesis tool that can be used to measure host machine
			instruction characteristics</flag>
		<flag name="gold">Build the gold linker plugin</flag>
		<flag name="ncurses">Support querying terminal properties using ncurses'
			terminfo</flag>
		<flag name="pgo">Build with Profile Guided Optimization</flag>
		<flag name="pgo_trainer_build_self">Trains and generates a PGO profile by
			building the source code itself</flag>
		<flag name="pgo_trainer_test_suite">Runs the test-suite to build a
			PGO profile from built benchmarks examples which may be consumed
			by the optimizers.</flag>
		<flag name="souper">Apply the disable-peepholes patch required by Souper
			superoptimizer and pulls in the Souper package as a PDEPEND.
			The Souper optimization pass can further reduce code size by
			~4.4% or 3 MB in some cases with a tradeoff of a 2% runtime
			penalty.  This will add new flags to toggle the built-in
			compiler peepholes optimization, overlapping optimizations that
			Souper provides, in addition to disablement of code that may
			produce undefined behavior during the Souper optimization pass
			that may lead to a crash.  (EXPERIMENTAL)</flag>
		<flag name="xar">Support dumping LLVM bitcode sections in Mach-O files
			(uses <pkg>app-arch/xar</pkg>)</flag>
		<flag name="z3">Enable support for <pkg>sci-mathematics/z3</pkg>
			constraint solver</flag>
		<flag name="rN">FOR INTERNAL USE ONLY.  Bump revision but save CCACHE
			paths for faster rebuilds.</flag>
	</use>
</pkgmetadata>
