Patch status:  Testing

Mostly the same as disable-peepholes-v07.diff but forward ported to 13.x.

The header license of many of these files:

// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

The original .diff patch can be obtained from:
https://github.com/regehr/llvm-project/compare/757752f568db698e3c0c35065c008489f2319a7b..disable-peepholes-v07.diff

For details see:
https://github.com/regehr/llvm-project/compare/757752f568db698e3c0c35065c008489f2319a7b..disable-peepholes-v07

Additional notes:
Some hunks related to lit were dropped or already applied upstream.
Some hunks were dropped related to omitCheck* in work/llvm/lib/Analysis/InstructionSimplify.cpp.
The testing scripts is not updated to be version and dev environment agnostic.

diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/include/llvm/Transforms/Scalar/DCE.h work/llvm/include/llvm/Transforms/Scalar/DCE.h
--- work.orig/llvm/include/llvm/Transforms/Scalar/DCE.h	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/include/llvm/Transforms/Scalar/DCE.h	2022-02-09 07:27:18.056120397 -0800
@@ -13,9 +13,12 @@
 #ifndef LLVM_TRANSFORMS_SCALAR_DCE_H
 #define LLVM_TRANSFORMS_SCALAR_DCE_H
 
+#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/PassManager.h"
 
+bool eliminateDeadCode(llvm::Function &F, llvm::TargetLibraryInfo *TLI);
+
 namespace llvm {
 
 /// Basic Dead Code Elimination pass.
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Analysis/InstructionSimplify.cpp work/llvm/lib/Analysis/InstructionSimplify.cpp
--- work.orig/llvm/lib/Analysis/InstructionSimplify.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Analysis/InstructionSimplify.cpp	2022-02-09 08:47:10.647062017 -0800
@@ -42,11 +42,26 @@
 #include "llvm/IR/Operator.h"
 #include "llvm/IR/PatternMatch.h"
 #include "llvm/IR/ValueHandle.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/KnownBits.h"
 #include <algorithm>
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+bool DisablePeepholes = DISABLE_PEEPHOLES_DEFAULT_VALUE;
+bool DisableWrongOptimizations = DISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE;
+
+// "true" for 2nd template argument means use external storage
+static cl::opt<bool, true>
+DisablePeepholesOption("disable-all-peepholes",
+                       cl::desc("Don't perform peephole optimizations"),
+                       cl::location(DisablePeepholes));
+
+static cl::opt<bool, true>
+DisableWrongOptsOption("disable-wrongs-opts",
+                       cl::desc("Disable optimizations that may increase the amount of undefined behavior"),
+                       cl::location(DisableWrongOptimizations));
+
 #define DEBUG_TYPE "instsimplify"
 
 enum { RecursionLimit = 3 };
@@ -77,6 +92,9 @@ static Value *SimplifySelectInst(Value *
 
 static Value *foldSelectWithBinaryOp(Value *Cond, Value *TrueVal,
                                      Value *FalseVal) {
+  if (DisablePeepholes)
+    return nullptr;
+
   BinaryOperator::BinaryOps BinOpCode;
   if (auto *BO = dyn_cast<BinaryOperator>(Cond))
     BinOpCode = BO->getOpcode();
@@ -132,6 +150,9 @@ static Constant *getTrue(Type *Ty) {
 /// isSameCompare - Is V equivalent to the comparison "LHS Pred RHS"?
 static bool isSameCompare(Value *V, CmpInst::Predicate Pred, Value *LHS,
                           Value *RHS) {
+  if (DisablePeepholes)
+    return false;
+
   CmpInst *Cmp = dyn_cast<CmpInst>(V);
   if (!Cmp)
     return false;
@@ -188,6 +209,9 @@ static Value *handleOtherCmpSelSimplific
                                                Value *Cond,
                                                const SimplifyQuery &Q,
                                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the false value simplified to false, then the result of the compare
   // is equal to "Cond && TCmp".  This also catches the case when the false
   // value simplified to false and the true value to true, returning "Cond".
@@ -243,6 +267,9 @@ static bool valueDominatesPHI(Value *V,
 static Value *expandBinOp(Instruction::BinaryOps Opcode, Value *V,
                           Value *OtherOp, Instruction::BinaryOps OpcodeToExpand,
                           const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   auto *B = dyn_cast<BinaryOperator>(V);
   if (!B || B->getOpcode() != OpcodeToExpand)
     return nullptr;
@@ -279,6 +306,9 @@ static Value *expandCommutativeBinOp(Ins
                                      Instruction::BinaryOps OpcodeToExpand,
                                      const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -296,6 +326,9 @@ static Value *SimplifyAssociativeBinOp(I
                                        Value *LHS, Value *RHS,
                                        const SimplifyQuery &Q,
                                        unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(Instruction::isAssociative(Opcode) && "Not an associative operation!");
 
   // Recursion is always used, so bail out at once if we already hit the limit.
@@ -395,6 +428,9 @@ static Value *SimplifyAssociativeBinOp(I
 static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -473,6 +509,9 @@ static Value *ThreadBinOpOverSelect(Inst
 static Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q,
                                   unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -519,6 +558,9 @@ static Value *ThreadCmpOverSelect(CmpIns
 static Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,
                                  Value *RHS, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -561,6 +603,9 @@ static Value *ThreadBinOpOverPHI(Instruc
 /// otherwise returns null.
 static Value *ThreadCmpOverPHI(CmpInst::Predicate Pred, Value *LHS, Value *RHS,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -620,6 +665,9 @@ static Value *SimplifyAddInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Add, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X + undef -> undef
   if (Q.isUndefValue(Op1))
     return Op1;
@@ -717,6 +765,9 @@ static Constant *stripAndComputeConstant
 /// If the difference is not a constant, returns zero.
 static Constant *computePointerDifference(const DataLayout &DL, Value *LHS,
                                           Value *RHS) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Constant *LHSOffset = stripAndComputeConstantOffsets(DL, LHS);
   Constant *RHSOffset = stripAndComputeConstantOffsets(DL, RHS);
 
@@ -739,6 +790,9 @@ static Value *SimplifySubInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Sub, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X - poison -> poison
   // poison - X -> poison
   if (isa<PoisonValue>(Op0) || isa<PoisonValue>(Op1))
@@ -879,6 +933,9 @@ static Value *SimplifyMulInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Mul, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X * poison -> poison
   if (isa<PoisonValue>(Op1))
     return Op1;
@@ -940,6 +997,9 @@ Value *llvm::SimplifyMulInst(Value *Op0,
 /// This applies to all 4 opcodes (sdiv/udiv/srem/urem).
 static Value *simplifyDivRem(Instruction::BinaryOps Opcode, Value *Op0,
                              Value *Op1, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   bool IsDiv = (Opcode == Instruction::SDiv || Opcode == Instruction::UDiv);
   bool IsSigned = (Opcode == Instruction::SDiv || Opcode == Instruction::SRem);
 
@@ -1031,6 +1091,9 @@ static bool isICmpTrue(ICmpInst::Predica
 /// to simplify X % Y to X.
 static bool isDivZero(Value *X, Value *Y, const SimplifyQuery &Q,
                       unsigned MaxRecurse, bool IsSigned) {
+  if (DisablePeepholes)
+    return false;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return false;
@@ -1085,6 +1148,9 @@ static Value *simplifyDiv(Instruction::B
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Opcode, Op0, Op1, Q))
     return V;
 
@@ -1129,6 +1195,9 @@ static Value *simplifyRem(Instruction::B
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Opcode, Op0, Op1, Q))
     return V;
 
@@ -1170,6 +1239,9 @@ static Value *simplifyRem(Instruction::B
 /// If not, this returns null.
 static Value *SimplifySDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If two operands are negated and no signed overflow, return -1.
   if (isKnownNegation(Op0, Op1, /*NeedNSW=*/true))
     return Constant::getAllOnesValue(Op0->getType());
@@ -1196,6 +1268,9 @@ Value *llvm::SimplifyUDivInst(Value *Op0
 /// If not, this returns null.
 static Value *SimplifySRemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the divisor is 0, the result is undefined, so assume the divisor is -1.
   // srem Op0, (sext i1 X) --> srem Op0, -1 --> 0
   Value *X;
@@ -1260,6 +1335,9 @@ static Value *SimplifyShift(Instruction:
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // poison shift by X -> poison
   if (isa<PoisonValue>(Op0))
     return Op0;
@@ -1327,6 +1405,9 @@ static Value *SimplifyShift(Instruction:
 static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
                                  Value *Op1, bool isExact, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V =
           SimplifyShift(Opcode, Op0, Op1, /*IsNSW*/ false, Q, MaxRecurse))
     return V;
@@ -1354,6 +1435,9 @@ static Value *SimplifyRightShift(Instruc
 /// If not, this returns null.
 static Value *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V =
           SimplifyShift(Instruction::Shl, Op0, Op1, isNSW, Q, MaxRecurse))
     return V;
@@ -1387,6 +1471,9 @@ Value *llvm::SimplifyShlInst(Value *Op0,
 /// If not, this returns null.
 static Value *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::LShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
       return V;
@@ -1425,6 +1512,9 @@ Value *llvm::SimplifyLShrInst(Value *Op0
 /// If not, this returns null.
 static Value *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::AShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
     return V;
@@ -1457,6 +1547,9 @@ Value *llvm::SimplifyAShrInst(Value *Op0
 static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
                                          ICmpInst *UnsignedICmp, bool IsAnd,
                                          const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X, *Y;
 
   ICmpInst::Predicate EqPred;
@@ -1565,6 +1658,9 @@ static Value *simplifyUnsignedRangeCheck
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1590,6 +1686,9 @@ static Value *simplifyAndOfICmpsWithSame
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1618,6 +1717,9 @@ static Value *simplifyOrOfICmpsWithSameO
 /// the other.
 static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                 bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look for this pattern: {and/or} (icmp X, C0), (icmp X, C1)).
   if (Cmp0->getOperand(0) != Cmp1->getOperand(0))
     return nullptr;
@@ -1655,6 +1757,9 @@ static Value *simplifyAndOrOfICmpsWithCo
 
 static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                            bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate P0 = Cmp0->getPredicate(), P1 = Cmp1->getPredicate();
   if (!match(Cmp0->getOperand(1), m_Zero()) ||
       !match(Cmp1->getOperand(1), m_Zero()) || P0 != P1)
@@ -1692,6 +1797,9 @@ static Value *simplifyAndOrOfICmpsWithZe
 
 static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                         const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) & (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1740,6 +1848,9 @@ static Value *simplifyAndOfICmpsWithAdd(
 /// Try to eliminate compares with signed or unsigned min/max constants.
 static Value *simplifyAndOrOfICmpsWithLimitConst(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                  bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Canonicalize an equality compare as Cmp0.
   if (Cmp1->isEquality())
     std::swap(Cmp0, Cmp1);
@@ -1799,6 +1910,9 @@ static Value *simplifyAndOrOfICmpsWithLi
 
 static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                  const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/true, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/true, Q))
@@ -1828,6 +1942,9 @@ static Value *simplifyAndOfICmps(ICmpIns
 
 static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                        const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) | (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1875,6 +1992,9 @@ static Value *simplifyOrOfICmpsWithAdd(I
 
 static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                 const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/false, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/false, Q))
@@ -1904,6 +2024,9 @@ static Value *simplifyOrOfICmps(ICmpInst
 
 static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
                                    FCmpInst *LHS, FCmpInst *RHS, bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);
   Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);
   if (LHS0->getType() != RHS0->getType())
@@ -1942,6 +2065,9 @@ static Value *simplifyAndOrOfFCmps(const
 
 static Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,
                                   Value *Op0, Value *Op1, bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look through casts of the 'and' operands to find compares.
   auto *Cast0 = dyn_cast<CastInst>(Op0);
   auto *Cast1 = dyn_cast<CastInst>(Op1);
@@ -1980,6 +2106,9 @@ static Value *simplifyAndOrOfCmps(const
 /// source value and inverted constant (identity: C - X -> ~(X + ~C)).
 static Value *simplifyLogicOfAddSub(Value *Op0, Value *Op1,
                                     Instruction::BinaryOps Opcode) {
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(Op0->getType() == Op1->getType() && "Mismatched binop types");
   assert(BinaryOperator::isBitwiseLogicOp(Opcode) && "Expected logic op");
   Value *X;
@@ -2007,6 +2136,9 @@ static Value *SimplifyAndInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::And, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X & poison -> poison
   if (isa<PoisonValue>(Op1))
     return Op1;
@@ -2179,6 +2311,9 @@ static Value *SimplifyOrInst(Value *Op0,
   if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X | poison -> poison
   if (isa<PoisonValue>(Op1))
     return Op1;
@@ -2359,6 +2494,9 @@ static Value *SimplifyXorInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Xor, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // A ^ undef -> undef
   if (Q.isUndefValue(Op1))
     return Op1;
@@ -2410,6 +2548,9 @@ static Type *GetCompareTy(Value *Op) {
 /// Helper function for analyzing max/min idioms.
 static Value *ExtractEquivalentCondition(Value *V, CmpInst::Predicate Pred,
                                          Value *LHS, Value *RHS) {
+  if (DisablePeepholes)
+    return nullptr;
+
   SelectInst *SI = dyn_cast<SelectInst>(V);
   if (!SI)
     return nullptr;
@@ -2456,6 +2597,9 @@ static Value *ExtractEquivalentCondition
 static Constant *
 computePointerICmp(CmpInst::Predicate Pred, Value *LHS, Value *RHS,
                    const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   const DataLayout &DL = Q.DL;
   const TargetLibraryInfo *TLI = Q.TLI;
   const DominatorTree *DT = Q.DT;
@@ -2646,6 +2790,9 @@ computePointerICmp(CmpInst::Predicate Pr
 /// Fold an icmp when its operands have i1 scalar type.
 static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Type *OpTy = LHS->getType();   // The operand type.
   if (!OpTy->isIntOrIntVectorTy(1))
@@ -2720,6 +2867,9 @@ static Value *simplifyICmpOfBools(CmpIns
 /// Try hard to fold icmp with zero RHS because this is a common case.
 static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
                                    Value *RHS, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!match(RHS, m_Zero()))
     return nullptr;
 
@@ -2782,6 +2932,9 @@ static Value *simplifyICmpWithZero(CmpIn
 
 static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
                                        Value *RHS, const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *X;
@@ -2831,6 +2984,9 @@ static Value *simplifyICmpWithConstant(C
 static Value *simplifyICmpWithBinOpOnLHS(
     CmpInst::Predicate Pred, BinaryOperator *LBO, Value *RHS,
     const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *Y = nullptr;
@@ -2975,6 +3131,9 @@ static bool trySimplifyICmpWithAdds(CmpI
 static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   BinaryOperator *LBO = dyn_cast<BinaryOperator>(LHS);
   BinaryOperator *RBO = dyn_cast<BinaryOperator>(RHS);
   if (MaxRecurse && (LBO || RBO)) {
@@ -3159,6 +3318,9 @@ static Value *simplifyICmpWithBinOp(CmpI
 static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
                                      Value *RHS, const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Value *A, *B;
   CmpInst::Predicate P = CmpInst::BAD_ICMP_PREDICATE;
@@ -3344,6 +3506,9 @@ static Value *simplifyICmpWithMinMax(Cmp
 static Value *simplifyICmpWithDominatingAssume(CmpInst::Predicate Predicate,
                                                Value *LHS, Value *RHS,
                                                const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Gracefully handle instructions that have not been inserted yet.
   if (!Q.AC || !Q.CxtI || !Q.CxtI->getParent())
     return nullptr;
@@ -3382,6 +3547,9 @@ static Value *SimplifyICmpInst(unsigned
   }
   assert(!isa<UndefValue>(LHS) && "Unexpected icmp undef,%X");
 
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
 
   // icmp poison, X -> poison
@@ -3696,11 +3864,17 @@ static Value *SimplifyFCmpInst(unsigned
     if (Constant *CRHS = dyn_cast<Constant>(RHS))
       return ConstantFoldCompareInstOperands(Pred, CLHS, CRHS, Q.DL, Q.TLI);
 
+    if (DisablePeepholes)
+      return nullptr;
+
     // If we have a constant, make sure it is on the RHS.
     std::swap(LHS, RHS);
     Pred = CmpInst::getSwappedPredicate(Pred);
   }
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Fold trivial predicates.
   Type *RetTy = GetCompareTy(LHS);
   if (Pred == FCmpInst::FCMP_FALSE)
@@ -3897,6 +4071,9 @@ static Value *simplifyWithOpReplaced(Val
                                      const SimplifyQuery &Q,
                                      bool AllowRefinement,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(!Op->getType()->isVectorTy() && "This is not safe for vectors");
 
   // Trivial replacement.
@@ -4019,6 +4196,9 @@ Value *llvm::simplifyWithOpReplaced(Valu
 /// integer comparison where one operand of the compare is a constant.
 static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
                                     const APInt *Y, bool TrueWhenUnset) {
+  if (DisablePeepholes)
+    return nullptr;
+
   const APInt *C;
 
   // (X & Y) == 0 ? X & ~Y : X  --> X
@@ -4055,6 +4235,9 @@ static Value *simplifySelectBitTest(Valu
 static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
                                            ICmpInst::Predicate Pred,
                                            Value *TrueVal, Value *FalseVal) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   APInt Mask;
   if (!decomposeBitTestICmp(CmpLHS, CmpRHS, Pred, X, Mask))
@@ -4069,6 +4252,9 @@ static Value *simplifySelectWithFakeICmp
 static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
                                          Value *FalseVal, const SimplifyQuery &Q,
                                          unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *CmpLHS, *CmpRHS;
   if (!match(CondVal, m_ICmp(Pred, m_Value(CmpLHS), m_Value(CmpRHS))))
@@ -4172,6 +4358,9 @@ static Value *simplifySelectWithICmpCond
 /// floating-point comparison.
 static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
                                      const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   FCmpInst::Predicate Pred;
   if (!match(Cond, m_FCmp(Pred, m_Specific(T), m_Specific(F))) &&
       !match(Cond, m_FCmp(Pred, m_Specific(F), m_Specific(T))))
@@ -4203,6 +4392,9 @@ static Value *simplifySelectWithFCmp(Val
 /// If not, this returns null.
 static Value *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
                                  const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CondC = dyn_cast<Constant>(Cond)) {
     if (auto *TrueC = dyn_cast<Constant>(TrueVal))
       if (auto *FalseC = dyn_cast<Constant>(FalseVal))
@@ -4313,6 +4505,9 @@ Value *llvm::SimplifySelectInst(Value *C
 /// If not, this returns null.
 static Value *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
                               const SimplifyQuery &Q, unsigned) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // The type of the GEP pointer operand.
   unsigned AS =
       cast<PointerType>(Ops[0]->getType()->getScalarType())->getAddressSpace();
@@ -4445,6 +4640,9 @@ Value *llvm::SimplifyGEPInst(Type *SrcTy
 static Value *SimplifyInsertValueInst(Value *Agg, Value *Val,
                                       ArrayRef<unsigned> Idxs, const SimplifyQuery &Q,
                                       unsigned) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *CAgg = dyn_cast<Constant>(Agg))
     if (Constant *CVal = dyn_cast<Constant>(Val))
       return ConstantFoldInsertValueInstruction(CAgg, CVal, Idxs);
@@ -4484,6 +4682,9 @@ Value *llvm::SimplifyInsertElementInst(V
   if (VecC && ValC && IdxC)
     return ConstantExpr::getInsertElement(VecC, ValC, IdxC);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // For fixed-length vector, fold into poison if index is out of bounds.
   if (auto *CI = dyn_cast<ConstantInt>(Idx)) {
     if (isa<FixedVectorType>(Vec->getType()) &&
@@ -4517,6 +4718,9 @@ static Value *SimplifyExtractValueInst(V
   if (auto *CAgg = dyn_cast<Constant>(Agg))
     return ConstantFoldExtractValueInstruction(CAgg, Idxs);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // extractvalue x, (insertvalue y, elt, n), n -> elt
   unsigned NumIdxs = Idxs.size();
   for (auto *IVI = dyn_cast<InsertValueInst>(Agg); IVI != nullptr;
@@ -4549,6 +4753,9 @@ static Value *SimplifyExtractElementInst
     if (auto *CIdx = dyn_cast<Constant>(Idx))
       return ConstantExpr::getExtractElement(CVec, CIdx);
 
+    if (DisablePeepholes)
+      return nullptr;
+
     if (Q.isUndefValue(Vec))
       return UndefValue::get(VecVTy->getElementType());
   }
@@ -4558,6 +4765,9 @@ static Value *SimplifyExtractElementInst
   if (Q.isUndefValue(Idx))
     return PoisonValue::get(VecVTy->getElementType());
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // If extracting a specified index from the vector, see if we can recursively
   // find a previously computed scalar that was inserted into the vector.
   if (auto *IdxC = dyn_cast<ConstantInt>(Idx)) {
@@ -4587,6 +4797,8 @@ Value *llvm::SimplifyExtractElementInst(
 /// See if we can fold the given phi. If not, returns null.
 static Value *SimplifyPHINode(PHINode *PN, ArrayRef<Value *> IncomingValues,
                               const SimplifyQuery &Q) {
+  // JDR: can't disable this w/o breaking the compiler
+
   // WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE
   //          here, because the PHI we may succeed simplifying to was not
   //          def-reachable from the original PHI!
@@ -4627,6 +4839,9 @@ static Value *SimplifyCastInst(unsigned
   if (auto *C = dyn_cast<Constant>(Op))
     return ConstantFoldCastOperand(CastOpc, C, Ty, Q.DL);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CI = dyn_cast<CastInst>(Op)) {
     auto *Src = CI->getOperand(0);
     Type *SrcTy = Src->getType();
@@ -4667,6 +4882,9 @@ Value *llvm::SimplifyCastInst(unsigned C
 static Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,
                                    int MaskVal, Value *RootVec,
                                    unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!MaxRecurse--)
     return nullptr;
 
@@ -4716,6 +4934,9 @@ static Value *SimplifyShuffleVectorInst(
                                         ArrayRef<int> Mask, Type *RetTy,
                                         const SimplifyQuery &Q,
                                         unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (all_of(Mask, [](int Elem) { return Elem == UndefMaskElem; }))
     return UndefValue::get(RetTy);
 
@@ -4848,6 +5069,9 @@ static Value *simplifyFNegInst(Value *Op
   if (Constant *C = foldConstant(Instruction::FNeg, Op, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   // fneg (fneg X) ==> X
   if (match(Op, m_FNeg(m_Value(X))))
@@ -4862,6 +5086,9 @@ Value *llvm::SimplifyFNegInst(Value *Op,
 }
 
 static Constant *propagateNaN(Constant *In) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the input is a vector with undef elements, just return a default NaN.
   if (!In->isNaN())
     return ConstantFP::getNaN(In->getType());
@@ -4878,6 +5105,9 @@ static Constant *simplifyFPOp(ArrayRef<V
                               const SimplifyQuery &Q,
                               fp::ExceptionBehavior ExBehavior,
                               RoundingMode Rounding) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Poison is independent of anything else. It always propagates from an
   // operand to a math result.
   if (any_of(Ops, [](Value *V) { return match(V, m_Poison()); }))
@@ -4918,6 +5148,9 @@ SimplifyFAddInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FAdd, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -4972,6 +5205,9 @@ SimplifyFSubInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FSub, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5019,6 +5255,9 @@ static Value *SimplifyFMAFMul(Value *Op0
                               const SimplifyQuery &Q, unsigned MaxRecurse,
                               fp::ExceptionBehavior ExBehavior,
                               RoundingMode Rounding) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5063,6 +5302,9 @@ SimplifyFMulInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FMul, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Now apply simplifications that do not require rounding.
   return SimplifyFMAFMul(Op0, Op1, FMF, Q, MaxRecurse, ExBehavior, Rounding);
 }
@@ -5108,6 +5350,9 @@ SimplifyFDivInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FDiv, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5163,6 +5408,9 @@ SimplifyFRemInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FRem, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5198,6 +5446,9 @@ Value *llvm::SimplifyFRemInst(Value *Op0
 /// If not, this returns null.
 static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
                            unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FastMathFlags(), Q, MaxRecurse);
@@ -5212,6 +5463,9 @@ static Value *simplifyUnOp(unsigned Opco
 static Value *simplifyFPUnOp(unsigned Opcode, Value *Op,
                              const FastMathFlags &FMF,
                              const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FMF, Q, MaxRecurse);
@@ -5338,6 +5592,9 @@ static bool IsIdempotent(Intrinsic::ID I
 
 static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
                                    const DataLayout &DL) {
+  if (DisablePeepholes)
+    return nullptr;
+
   GlobalValue *PtrSym;
   APInt PtrOffset;
   if (!IsConstantOffsetFromGlobal(Ptr, PtrSym, PtrOffset, DL))
@@ -5394,6 +5651,9 @@ static Value *SimplifyRelativeLoad(Const
 
 static Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,
                                      const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Idempotent functions return the same result when called repeatedly.
   Intrinsic::ID IID = F->getIntrinsicID();
   if (IsIdempotent(IID))
@@ -5505,6 +5765,9 @@ static ICmpInst::Predicate getMaxMinPred
 /// operand that is another min/max intrinsic with shared operand(s). The caller
 /// is expected to swap the operand arguments to handle commutation.
 static Value *foldMinMaxSharedOp(Intrinsic::ID IID, Value *Op0, Value *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X, *Y;
   if (!match(Op0, m_MaxOrMin(m_Value(X), m_Value(Y))))
     return nullptr;
@@ -5528,6 +5791,9 @@ static Value *foldMinMaxSharedOp(Intrins
 
 static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
                                       const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Intrinsic::ID IID = F->getIntrinsicID();
   Type *ReturnType = F->getReturnType();
   unsigned BitWidth = ReturnType->getScalarSizeInBits();
@@ -5788,6 +6054,9 @@ static Value *simplifyBinaryIntrinsic(Fu
 
 static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Intrinsics with no operands have some kind of side effect. Don't simplify.
   unsigned NumOperands = Call->getNumArgOperands();
   if (!NumOperands)
@@ -5950,6 +6219,9 @@ static Value *simplifyIntrinsic(CallBase
 }
 
 static Value *tryConstantFoldCall(CallBase *Call, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+  
   auto *F = dyn_cast<Function>(Call->getCalledOperand());
   if (!F || !canConstantFoldCallTo(Call, F))
     return nullptr;
@@ -5995,6 +6267,9 @@ Value *llvm::SimplifyCall(CallBase *Call
 
 /// Given operands for a Freeze, see if we can fold the result.
 static Value *SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Use a utility function defined in ValueTracking.
   if (llvm::isGuaranteedNotToBeUndefOrPoison(Op0, Q.AC, Q.CxtI, Q.DT))
     return Op0;
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp work/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
--- work.orig/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp	2022-02-09 07:27:18.096122029 -0800
@@ -35,6 +35,8 @@
 using namespace llvm;
 using namespace PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "aggressive-instcombine"
 
 STATISTIC(NumAnyOrAllBitsSet, "Number of any/all-bits-set patterns folded");
@@ -415,6 +417,9 @@ void AggressiveInstCombinerLegacyPass::g
 }
 
 bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);
   auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
   return runImpl(F, TLI, DT);
@@ -422,6 +427,9 @@ bool AggressiveInstCombinerLegacyPass::r
 
 PreservedAnalyses AggressiveInstCombinePass::run(Function &F,
                                                  FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   if (!runImpl(F, TLI, DT)) {
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp work/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
--- work.orig/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp	2022-02-09 07:40:17.521187601 -0800
@@ -43,6 +43,8 @@
 #include <cassert>
 #include <utility>
 
+extern bool DisableWrongOptimizations;
+
 using namespace llvm;
 using namespace PatternMatch;
 
@@ -2660,6 +2662,7 @@ Instruction *InstCombinerImpl::visitSele
   // Avoid potential infinite loops by checking for non-constant condition.
   // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?
   //       Scalar select must have simplified?
+  if (!DisableWrongOptimizations) {
   if (SelType->isIntOrIntVectorTy(1) && !isa<Constant>(CondVal) &&
       TrueVal->getType() == CondVal->getType()) {
     // Folding select to and/or i1 isn't poison safe in general. impliesPoison
@@ -2836,6 +2839,7 @@ Instruction *InstCombinerImpl::visitSele
       return new SExtInst(NotCond, SelType);
     }
   }
+  } // fi !DisableWrongOptimizations
 
   if (auto *FCmp = dyn_cast<FCmpInst>(CondVal)) {
     Value *Cmp0 = FCmp->getOperand(0), *Cmp1 = FCmp->getOperand(1);
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp work/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
--- work.orig/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp	2022-02-09 07:27:18.121123049 -0800
@@ -112,6 +112,8 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "instcombine"
 
 STATISTIC(NumWorklistIterations,
@@ -4185,6 +4187,9 @@ InstCombinePass::InstCombinePass(unsigne
 
 PreservedAnalyses InstCombinePass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
@@ -4228,6 +4233,9 @@ void InstructionCombiningPass::getAnalys
 }
 
 bool InstructionCombiningPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   if (skipFunction(F))
     return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/DCE.cpp work/llvm/lib/Transforms/Scalar/DCE.cpp
--- work.orig/llvm/lib/Transforms/Scalar/DCE.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/Scalar/DCE.cpp	2022-02-09 07:32:52.522494884 -0800
@@ -18,7 +18,6 @@
 #include "llvm/Transforms/Scalar/DCE.h"
 #include "llvm/ADT/SetVector.h"
 #include "llvm/ADT/Statistic.h"
-#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/InstIterator.h"
 #include "llvm/IR/Instruction.h"
 #include "llvm/InitializePasses.h"
@@ -119,26 +118,6 @@ static bool DCEInstruction(Instruction *
   return false;
 }
 
-static bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
-  bool MadeChange = false;
-  SmallSetVector<Instruction *, 16> WorkList;
-  // Iterate over the original function, only adding insts to the worklist
-  // if they actually need to be revisited. This avoids having to pre-init
-  // the worklist with the entire function's worth of instructions.
-  for (Instruction &I : llvm::make_early_inc_range(instructions(F))) {
-    // We're visiting this instruction now, so make sure it's not in the
-    // worklist from an earlier visit.
-    if (!WorkList.count(&I))
-      MadeChange |= DCEInstruction(&I, WorkList, TLI);
-  }
-
-  while (!WorkList.empty()) {
-    Instruction *I = WorkList.pop_back_val();
-    MadeChange |= DCEInstruction(I, WorkList, TLI);
-  }
-  return MadeChange;
-}
-
 PreservedAnalyses DCEPass::run(Function &F, FunctionAnalysisManager &AM) {
   if (!eliminateDeadCode(F, &AM.getResult<TargetLibraryAnalysis>(F)))
     return PreservedAnalyses::all();
@@ -178,3 +157,23 @@ INITIALIZE_PASS(DCELegacyPass, "dce", "D
 FunctionPass *llvm::createDeadCodeEliminationPass() {
   return new DCELegacyPass();
 }
+
+bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
+  bool MadeChange = false;
+  SmallSetVector<Instruction *, 16> WorkList;
+  // Iterate over the original function, only adding insts to the worklist
+  // if they actually need to be revisited. This avoids having to pre-init
+  // the worklist with the entire function's worth of instructions.
+  for (Instruction &I : llvm::make_early_inc_range(instructions(F))) {
+    // We're visiting this instruction now, so make sure it's not in the
+    // worklist from an earlier visit.
+    if (!WorkList.count(&I))
+      MadeChange |= DCEInstruction(&I, WorkList, TLI);
+  }
+
+  while (!WorkList.empty()) {
+    Instruction *I = WorkList.pop_back_val();
+    MadeChange |= DCEInstruction(I, WorkList, TLI);
+  }
+  return MadeChange;
+}
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/NaryReassociate.cpp work/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
--- work.orig/llvm/lib/Transforms/Scalar/NaryReassociate.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/Scalar/NaryReassociate.cpp	2022-02-09 07:27:18.136123661 -0800
@@ -116,6 +116,8 @@ using namespace PatternMatch;
 
 #define DEBUG_TYPE "nary-reassociate"
 
+extern bool DisablePeepholes;
+
 namespace {
 
 class NaryReassociateLegacyPass : public FunctionPass {
@@ -167,6 +169,9 @@ FunctionPass *llvm::createNaryReassociat
 }
 
 bool NaryReassociateLegacyPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   if (skipFunction(F))
     return false;
 
@@ -181,6 +186,9 @@ bool NaryReassociateLegacyPass::runOnFun
 
 PreservedAnalyses NaryReassociatePass::run(Function &F,
                                            FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto *AC = &AM.getResult<AssumptionAnalysis>(F);
   auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   auto *SE = &AM.getResult<ScalarEvolutionAnalysis>(F);
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/Reassociate.cpp work/llvm/lib/Transforms/Scalar/Reassociate.cpp
--- work.orig/llvm/lib/Transforms/Scalar/Reassociate.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/Scalar/Reassociate.cpp	2022-02-09 07:27:18.141123865 -0800
@@ -86,6 +86,8 @@ static void PrintOps(Instruction *I, con
 }
 #endif
 
+extern bool DisablePeepholes;
+
 /// Utility class representing a non-constant Xor-operand. We classify
 /// non-constant Xor-Operands into two categories:
 ///  C1) The operand is in the form "X & C", where C is a constant and C != ~0
@@ -2497,6 +2499,9 @@ ReassociatePass::BuildPairMap(ReversePos
 }
 
 PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   // Get the functions basic blocks in Reverse Post Order. This order is used by
   // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic
   // blocks (it has been seen that the analysis in this pass could hang when
@@ -2587,6 +2592,9 @@ namespace {
     }
 
     bool runOnFunction(Function &F) override {
+      if (DisablePeepholes)
+        return false;
+
       if (skipFunction(F))
         return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp work/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
--- work.orig/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp	2022-02-09 07:27:18.145124029 -0800
@@ -61,6 +61,8 @@
 #include <numeric>
 #include <utility>
 
+extern bool DisableWrongOptimizations;
+
 #define DEBUG_TYPE "simple-loop-unswitch"
 
 using namespace llvm;
@@ -3055,6 +3057,11 @@ unswitchLoop(Loop &L, DominatorTree &DT,
 PreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &U) {
+  if (DisableWrongOptimizations) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
+
   Function &F = *L.getHeader()->getParent();
   (void)F;
 
@@ -3151,6 +3158,9 @@ public:
 } // end anonymous namespace
 
 bool SimpleLoopUnswitchLegacyPass::runOnLoop(Loop *L, LPPassManager &LPM) {
+  if (DisableWrongOptimizations)
+    return false;
+
   if (skipLoop(L))
     return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp work/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
--- work.orig/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp	2022-02-09 07:27:18.146124069 -0800
@@ -51,6 +51,8 @@ using namespace llvm;
 
 #define DEBUG_TYPE "simplifycfg"
 
+extern bool DisablePeepholes;
+
 static cl::opt<unsigned> UserBonusInstThreshold(
     "bonus-inst-threshold", cl::Hidden, cl::init(1),
     cl::desc("Control the number of bonus instructions (default = 1)"));
@@ -321,6 +323,11 @@ SimplifyCFGPass::SimplifyCFGPass(const S
 
 PreservedAnalyses SimplifyCFGPass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisablePeepholes) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
+
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   Options.AC = &AM.getResult<AssumptionAnalysis>(F);
   DominatorTree *DT = nullptr;
@@ -356,6 +363,9 @@ struct CFGSimplifyPass : public Function
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePeepholes)
+      return false;
+
     if (skipFunction(F) || (PredicateFtor && !PredicateFtor(F)))
       return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Vectorize/VectorCombine.cpp work/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
--- work.orig/llvm/lib/Transforms/Vectorize/VectorCombine.cpp	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/lib/Transforms/Vectorize/VectorCombine.cpp	2022-02-09 07:27:18.158124559 -0800
@@ -31,6 +31,8 @@
 #include "llvm/Transforms/Utils/Local.h"
 #include "llvm/Transforms/Vectorize.h"
 
+extern bool DisablePeepholes;
+
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
@@ -1008,6 +1010,9 @@ public:
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePeepholes)
+      return false;
+
     if (skipFunction(F))
       return false;
     auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll work/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll
--- work.orig/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll	2021-09-24 09:18:10.000000000 -0700
+++ work/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll	2022-02-09 07:27:18.159124600 -0800
@@ -1,4 +1,3 @@
-; XFAIL: *
 ; Needs some fixed in the pipeliner.
 ; RUN: llc -march=hexagon < %s -pipeliner-experimental-cg=true | FileCheck %s
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/souper-scripts/default.cfg work/souper-scripts/default.cfg
--- work.orig/souper-scripts/default.cfg	1969-12-31 16:00:00.000000000 -0800
+++ work/souper-scripts/default.cfg	2022-02-09 07:27:19.885195030 -0800
@@ -0,0 +1,570 @@
+#------------------------------------------------------------------------------
+# SPEC CPU2017 config file for: gcc / g++ / gfortran on Linux x86
+#------------------------------------------------------------------------------
+# 
+# Usage: (1) Copy this to a new name
+#             cd $SPEC/config
+#             cp Example-x.cfg myname.cfg
+#        (2) Change items that are marked 'EDIT' (search for it)
+# 
+# SPEC tested this config file with:
+#    Compiler version(s):    4.4.7, 4.9.2, 5.2.0, 6.3.0
+#    Operating system(s):    Oracle Linux Server 6.5 and 7.2 / 
+#                            Red Hat Enterprise Linux Server 6.5 and 7.2
+#    Hardware:               Xeon 
+#
+# If your system differs, this config file might not work.
+# You might find a better config file at http://www.spec.org/cpu2017/results
+#
+# Known Limitations with GCC 4 
+#
+#   (1) Possible problem: compile time messages
+#                             error: unrecognized command line option '...'
+#      Recommendation:    Use a newer version of the compiler.
+#                         If that is not possible, remove the unrecognized 
+#                         option from this config file.
+#
+#   (2) Possible problem: run time errors messages 
+#           527.cam4_r or 627.cam4_s    *** Miscompare of cam4_validate.txt    
+#      Recommendation: Use a newer version of the compiler.
+#                      If that is not possible, try reducing the optimization.
+#
+# Compiler issues: Contact your compiler vendor, not SPEC.
+# For SPEC help:   http://www.spec.org/cpu2017/Docs/techsupport.html
+#------------------------------------------------------------------------------
+
+
+#--------- Label --------------------------------------------------------------
+# Arbitrary string to tag binaries 
+#                  Two Suggestions: # (1) EDIT this label as you try new ideas.
+%define label mytest                # (2)      Use a label meaningful to *you*.
+
+
+#--------- Preprocessor -------------------------------------------------------
+%   define  bits        64     #      you can set it on the command line using:
+
+%ifndef %{build_ncpus}         # EDIT to adjust number of simultaneous compiles.
+%   define  build_ncpus 20      #      Or, you can set it on the command line: 
+%endif                         #      'runcpu --define build_ncpus=nn'
+
+# Don't change this part.
+%define    os           LINUX
+
+%   define model        -m64
+
+
+#--------- Global Settings ----------------------------------------------------
+# For info, see:
+#            https://www.spec.org/cpu2017/Docs/config.html#fieldname   
+#   Example: https://www.spec.org/cpu2017/Docs/config.html#tune        
+
+command_add_redirect = 1
+flagsurl             = $[top]/config/flags/gcc.xml
+iterations           = 1
+label                = %{label}-m%{bits}
+line_width           = 1020
+log_line_width       = 1020
+makeflags            = --jobs=%{build_ncpus} 
+mean_anyway          = 1
+output_format        = txt,html,cfg,pdf,csv
+preenv               = 1
+reportable           = 0
+tune                 = base
+
+
+#--------- How Many CPUs? -----------------------------------------------------
+# Both SPECrate and SPECspeed can test multiple chips / cores / hw threads
+#    - For SPECrate,  you set the number of copies.
+#    - For SPECspeed, you set the number of threads. 
+# See: https://www.spec.org/cpu2017/Docs/system-requirements.html#MultipleCPUs
+#
+#    q. How many should I set?  
+#    a. Unknown, you will have to try it and see!
+#
+# To get you started, some suggestions:
+#
+#     copies - This config file defaults to testing only 1 copy.   You might
+#              try changing it to match the number of cores on your system, 
+#              or perhaps the number of virtual CPUs as reported by:
+#                     grep -c processor /proc/cpuinfo
+#              Be sure you have enough memory.  See:
+#              https://www.spec.org/cpu2017/Docs/system-requirements.html#memory
+#
+#     threads - This config file sets a starting point.  You could try raising 
+#               it.  A higher thread count is much more likely to be useful for
+#               fpspeed than for intspeed.
+#
+intrate,fprate:
+   copies           = 1   # EDIT to change number of copies (see above)
+intspeed,fpspeed:
+   threads          = 1   # EDIT to change number of OpenMP threads (see above)
+
+
+#------- Compilers ------------------------------------------------------------
+default:
+#                    EDIT: the directory where your compiler is installed
+%ifndef %{gcc_dir}
+%   define  gcc_dir        /SW/compilers/GCC/Linux/x86_64/gcc-6.3.0
+%endif
+
+%define LLVM LLVMDIR
+
+# EDIT if needed: the preENV line adds library directories to the runtime
+#      path.  You can adjust it, or add lines for other environment variables. 
+#      See: https://www.spec.org/cpu2017/Docs/config.html#preenv
+#      and: https://gcc.gnu.org/onlinedocs/gcc/Environment-Variables.html
+   preENV_LD_LIBRARY_PATH  = %{LLVM}/lib
+  #preENV_LD_LIBRARY_PATH  = %{gcc_dir}/lib64/:%{gcc_dir}/lib/:/lib64:%{ENV_LD_LIBRARY_PATH}
+   SPECLANG                = /usr/bin/
+   LLVMBIN = %{LLVM}/bin
+   CC                      = $(LLVMBIN)/clang     -std=c99   %{model}
+   CXX                     = $(LLVMBIN)/clang++                %{model}
+   FC                      = $(SPECLANG)gfortran           %{model}
+   # How to say "Show me your version, please"
+   CC_VERSION_OPTION       = -v
+   CXX_VERSION_OPTION      = -v
+   FC_VERSION_OPTION       = -v
+
+default:
+%if %{bits} == 64
+   sw_base_ptrsize = 64-bit
+   sw_peak_ptrsize = 64-bit
+%else
+   sw_base_ptrsize = 32-bit
+   sw_peak_ptrsize = 32-bit
+%endif
+
+
+#--------- Portability --------------------------------------------------------
+default:               # data model applies to all benchmarks
+%if %{bits} == 32
+    # Strongly recommended because at run-time, operations using modern file 
+    # systems may fail spectacularly and frequently (or, worse, quietly and 
+    # randomly) if a program does not accommodate 64-bit metadata.
+    EXTRA_PORTABILITY = -D_FILE_OFFSET_BITS=64
+%else
+    EXTRA_PORTABILITY = -DSPEC_LP64
+%endif
+
+# Benchmark-specific portability (ordered by last 2 digits of bmark number)
+
+500.perlbench_r,600.perlbench_s:  #lang='C'
+%if %{bits} == 32
+%   define suffix IA32
+%else
+%   define suffix X64
+%endif
+   PORTABILITY    = -DSPEC_%{os}_%{suffix}
+
+521.wrf_r,621.wrf_s:  #lang='F,C'
+   CPORTABILITY  = -DSPEC_CASE_FLAG 
+   FPORTABILITY  = -fconvert=big-endian
+
+523.xalancbmk_r,623.xalancbmk_s:  #lang='CXX'
+   PORTABILITY   = -DSPEC_%{os}
+
+526.blender_r:  #lang='CXX,C'
+   PORTABILITY   = -funsigned-char -DSPEC_LINUX
+
+527.cam4_r,627.cam4_s:  #lang='F,C'
+   PORTABILITY   = -DSPEC_CASE_FLAG
+
+628.pop2_s:  #lang='F,C'
+   CPORTABILITY    = -DSPEC_CASE_FLAG
+   FPORTABILITY    = -fconvert=big-endian
+
+
+#-------- Tuning Flags common to Base and Peak --------------------------------
+
+#
+# Speed (OpenMP and Autopar allowed)
+#
+%if %{bits} == 32
+   intspeed,fpspeed:
+   #
+   # Many of the speed benchmarks (6nn.benchmark_s) do not fit in 32 bits
+   # If you wish to run SPECint2017_speed or SPECfp2017_speed, please use
+   #
+   #     runcpu --define bits=64
+   #
+   fail_build = 1
+%else
+   intspeed,fpspeed:
+      EXTRA_OPTIMIZE =
+   fpspeed:
+      #
+      # 627.cam4 needs a big stack; the preENV will apply it to all 
+      # benchmarks in the set, as required by the rules.  
+      #
+      preENV_OMP_STACKSIZE = 120M
+%endif
+
+
+#--------  Baseline Tuning Flags ----------------------------------------------
+#
+# EDIT if needed -- Older GCC might not support some of the optimization
+#                   switches here.  See also 'About the -fno switches' below.
+#
+default=base:         # flags for all base 
+   OPTIMIZE       = -g -O3 -march=native -fno-unsafe-math-optimizations
+
+intrate,intspeed=base: # flags for integer base
+%if %{bits} == 32                    
+    EXTRA_COPTIMIZE = -fgnu89-inline -fno-strict-aliasing 
+%else                                
+    EXTRA_COPTIMIZE = -fno-strict-aliasing 
+    LDCFLAGS        = -z muldefs     
+%endif                               
+# Notes about the above
+#  - 500.perlbench_r/600.perlbench_s needs -fno-strict-aliasing.
+#  - 502.gcc_r/602.gcc_s             needs -fgnu89-inline or -z muldefs
+#  - For 'base', all benchmarks in a set must use the same options.   
+#  - Therefore, all base benchmarks get the above.  See:
+#       www.spec.org/cpu2017/Docs/runrules.html#BaseFlags  
+#       www.spec.org/cpu2017/Docs/benchmarks/500.perlbench_r.html
+#       www.spec.org/cpu2017/Docs/benchmarks/502.gcc_r.html
+
+
+#--------  Peak Tuning Flags ----------------------------------------------
+default=peak:
+   basepeak = yes  # if you develop some peak tuning, remove this line.
+   #
+   # -----------------------
+   # About the -fno switches
+   # -----------------------
+   #
+   # For 'base', this config file (conservatively) disables some optimizations.
+   # You might want to try turning some of them back on, by creating a 'peak' 
+   # section here, with individualized benchmark options:
+   #
+   #        500.perlbench_r=peak:
+   #           OPTIMIZE = this
+   #        502.gcc_r=peak:
+   #           OPTIMIZE = that 
+   #        503.bwaves_r=peak:
+   #           OPTIMIZE = other   .....(and so forth)
+   #
+   # If you try it:
+   #   - You must remove the 'basepeak' option, above.
+   #   - You will need time and patience, to diagnose and avoid any errors.
+   #   - perlbench is unlikely to work with strict aliasing 
+   #   - Some floating point benchmarks may get wrong answers, depending on:
+   #         the particular chip 
+   #         the version of GCC 
+   #         other optimizations enabled
+   #         -m32 vs. -m64
+   #   - See: http://www.spec.org/cpu2017/Docs/config.html
+   #   - and: http://www.spec.org/cpu2017/Docs/runrules.html
+
+
+#------------------------------------------------------------------------------
+# Tester and System Descriptions - EDIT all sections below this point              
+#------------------------------------------------------------------------------
+#   For info about any field, see
+#             https://www.spec.org/cpu2017/Docs/config.html#fieldname 
+#   Example:  https://www.spec.org/cpu2017/Docs/config.html#hw_memory  
+#-------------------------------------------------------------------------------
+
+#--------- EDIT to match your version -----------------------------------------
+default:
+   sw_compiler001   = C/C++/Fortran: Version 6.2.0 of GCC, the
+   sw_compiler002   = GNU Compiler Collection
+
+#--------- EDIT info about you ------------------------------------------------
+# To understand the difference between hw_vendor/sponsor/tester, see:
+#     https://www.spec.org/cpu2017/Docs/config.html#test_sponsor
+intrate,intspeed,fprate,fpspeed: # Important: keep this line
+   hw_vendor          = My Corporation
+   tester             = My Corporation
+   test_sponsor       = My Corporation
+   license_num        = nnn (Your SPEC license number) 
+#  prepared_by        = # Ima Pseudonym                       # Whatever you like: is never output
+
+
+#--------- EDIT system availability dates -------------------------------------
+intrate,intspeed,fprate,fpspeed: # Important: keep this line
+                        # Example                             # Brief info about field
+   hw_avail           = # Nov-2099                            # Date of LAST hardware component to ship
+   sw_avail           = # Nov-2099                            # Date of LAST software component to ship
+
+#--------- EDIT system information --------------------------------------------
+intrate,intspeed,fprate,fpspeed: # Important: keep this line
+                        # Example                             # Brief info about field
+#  hw_cpu_name        = # Intel Xeon E9-9999 v9               # chip name
+   hw_cpu_nominal_mhz = # 9999                                # Nominal chip frequency, in MHz
+   hw_cpu_max_mhz     = # 9999                                # Max chip frequency, in MHz
+#  hw_disk            = # 9 x 9 TB SATA III 9999 RPM          # Size, type, other perf-relevant info
+   hw_model           = # TurboBlaster 3000                   # system model name
+#  hw_nchips          = # 99                                  # number chips enabled
+   hw_ncores          = # 9999                                # number cores enabled
+   hw_ncpuorder       = # 1-9 chips                           # Ordering options
+   hw_nthreadspercore = # 9                                   # number threads enabled per core
+   hw_other           = # TurboNUMA Router 10 Gb              # Other perf-relevant hw, or "None"
+
+#  hw_memory001       = # 999 GB (99 x 9 GB 2Rx4 PC4-2133P-R, # The 'PCn-etc' is from the JEDEC 
+#  hw_memory002       = # running at 1600 MHz)                # label on the DIMM.
+
+   hw_pcache          = # 99 KB I + 99 KB D on chip per core  # Primary cache size, type, location
+   hw_scache          = # 99 KB I+D on chip per 9 cores       # Second cache or "None"
+   hw_tcache          = # 9 MB I+D on chip per chip           # Third  cache or "None"
+   hw_ocache          = # 9 GB I+D off chip per system board  # Other cache or "None"
+
+   fw_bios            = # American Megatrends 39030100 02/29/2016 # Firmware information
+#  sw_file            = # ext99                               # File system
+#  sw_os001           = # Linux Sailboat                      # Operating system
+#  sw_os002           = # Distribution 7.2 SP1                # and version
+   sw_other           = # TurboHeap Library V8.1              # Other perf-relevant sw, or "None"
+#  sw_state           = # Run level 99                        # Software state.
+
+# Note: Some commented-out fields above are automatically set to preliminary 
+# values by sysinfo
+#       https://www.spec.org/cpu2017/Docs/config.html#sysinfo
+# Uncomment lines for which you already know a better answer than sysinfo 
+
+__HASH__
+648.exchange2_s=base=mytest-m64:
+# Last updated 2020-05-19 10:13:21
+opthash=db22c3632ab36100655456be45ecf60b0f22c9463246851c114e017ac2d6fe81
+baggage=
+compiler_version=\
+@eNp9VE1v2zAMvftX+NYNteK26ZIigA9Z6hQDsqZI3e0YyBLtqJUlTx+Js8N++2THib202MWC+Cjy\
+kXy0P5+tf8Sr52/Lx/XyKXHHxHvRTOR+ahk3iAlfl0D0wJstF4t4lqwfZrMotFqFKRNhnkllFBYn\
+dJEs1z9X06eneHXw4iwNc0LC6m60Ht0izoStUC5sOA65kWincFmC8pbz+WI5vV8n09VDnKwfp9/j\
+50hsS1MhIQWc4/fxfPqySKJrL8EqBzPxz+N7MykyllsF1N8xs5n4g0GoFQnJ0e6jrY9QjaHyLd+C\
+0kyK6OIltcJYfzz4MrhCQ9vcrv9c3w2ubi+O/ql1AXiUMQ6TMGzq1BusIKSS1NWicbiKp/ff48FX\
+m2v3CgROOSCORW5xDjoiAaY4IJeXQS6DVLE8oEHby0Cmr6T+IAe7t6WCjFVNN4/56xQFfpUKtbSR\
+FHzf+Mpc4QJpm9Vv0Lhna+OcNwp19JoaaI8uE2+gUK0EilgNuGlCBYQydZpuy0naWiyEWwoUuYkY\
+qEwXyWwUYKqjUmpWHeKcxWgdBe+1K5XSaNeSsjMRLgnmEDnifZ6pNpRUFaLgRvMRYFgB0R70sYMU\
+MmydvjsPnLJIwK57XPfGCvbLAnLDAFKXQ5lusK05HKBYtv8nX1FW3b3kNncbdLofs5YMjkT0Xhso\
+0O+uk8g0kj5D2gi1Ntz4I2yN7KyFC8qwIpsexR0oJU+KqUE0vInY6G50srmKi9Ht8doEcclcFdpE\
+xfAmcGBQVMObs0R9qla4WYBwfSA9klnGJaZtIbq3xz2xEEsxooq5HvbGuwHy5v4+kQIOWNf+jfre\
+qdYBG+lofmA/ZH2HeEmjQb+QFPjEb5TouUXy2xU6bLz/6T/7/9n3/gIWLsdL
+compile_options=\
+@eNq9kV1vgjAUhu/5FU3vi1v2kUjERBENG0KjmGy7MYhFu422acFs/voVFEYWk+ku1pue5rw95z3P\
+CThDWfxGUvpOABc55UxZhsolTfKlLNiayuWOSJp+2vAaGjpUWmLDK7N7dQcNY4yxBaASJBECoNEc\
+u46+gpE7XEyO72WI3WCK65eP729BT/FCJqQPEG9iMxWC7snaTLsf0NBlHbwY+4PJ3IY/CkMjtID7\
+FM0GunbkTb0Xt9Ycm1X/DwoczqLB0PO96LkRlR6g4YTT0nynULKzoqyzSbnMZczA90GZNouS0uYR\
+jskB2gAU3uhcLJOtzeKc7ghAKeOoYCpOiU7kW1TqM7qPq186zQVhmWim1e0tMHbsX9sfhOHwQY+q\
+B2h7OYNSi8/lrk9zrie5HLjvBY/nAD9Ef6BcFzlpEYAeX72SJFd90O7Y4ASgYu2PzlnKv7KtXIWL\
+cv+t5X8Bpw4cAg==
+exehash=755215fc6b305a0c3fe7c1fcac5b4cdb200e55afc30087cccb0da00163d223de
+
+998.specrand_is=base=mytest-m64:
+# Last updated 2020-05-19 12:57:38
+opthash=cb17f0c4a7a88a21b142b5ffc3a57bdd32f2bc1cc98f0a9242264d2aab7d74fd
+baggage=
+compiler_version=\
+@eNqlkDtvwyAUhXf/CsZ2MMSPEOIukdyHsjRVE3WNMFzZtBgsDKl/flEbNUOytBEChnPud8+9qK73\
+bw+v2/Xmeb952cWvSoTmpkUHcKOyBmUZnuEZummVX8XbhQYL21cOWugc0frQp4Oz7yA8jjLKS8gY\
+CMqabMk4z1lTzMsiHikXmShyJpeU8rm8TXbcteArNDG6p2UazIexnybVyoQpbU1Idp0DLlFvJegK\
+DXZUU7I2o+dag7xXrkKksz2QC1GI+vGlA8AwkkaZ5NEGI5HgRirJPaCnukZHF/dx0EgLY6SohrRC\
+EEUZPWUh7K/1x6lOhMX1BDzHs6spLNmCjisC+c8A9W/rPmivortC+G7V0/KiVORRK/KL2vQtxveU\
+6Yz5BW4y4iE=
+compile_options=\
+@eNrNklFP2zAUhd/zK678bgICTWpFkFo3Y2FpHEErbXuJjOu0HrEd2Wml8etxXAqB7QWtD/gllu65\
+J/cef4XRWLEHUctGgGk7abQbR66zkneV3eqVtNVOWFn/SdAZivzVeUmCTk9Gp+coigidl2NA8cYo\
+EVuxFhsbN81O4daa34J3sdSuY02DWyFaF99LHfOG6TX0B7tulfDRqL+qLxeAOWBzmOLEAJ7dlSnx\
+n2KWTpfXgDPXCm6ZXmFulDLa960B03PfzizfJJp1cicA19rgrXasFr7QbXBvqeQjC8bwenBtWqFV\
++/ynipZpMS/3/fsMMGskczIM/CzKSz8qXDqztVxcoYiMgZDkOBHs3ej0hpaLBL3JA0U+aFIuv+aT\
+6ztfe5tNqE7TgnyrDoL3YaGIjsH7ZvPsV+rrH08uOKQ/FreTauDzzwwHUjLU/h1smHyvLOntYjLN\
+8mzx87BgSBtFeVZ8PxpmgB9BbZuVqAML/4HQR/i5NPf9pO4KhgC+PC9AePt8djSSaO9GDjS8rPxp\
+MQjb02XP/QD6J8tAc9E=
+exehash=0dd6b7947a61dd2a9a3198a701cd4f5d81066b3cd0866f27303a6769b979d14a
+
+657.xz_s=base=mytest-m64:
+# Last updated 2020-06-25 22:08:15
+opthash=aca1bbdc7135c7d394d0e6181d2b5e24583855c8ab8a22b88b9ab8309c185903
+baggage=
+compiler_version=\
+@eNqljk1PwzAMhu/5Fb6jNPuoqlIuSGWgXRhiFdcqTaw2WuqgNBn9+UQbGhLsBLJkH177eQx13b5t\
+Xvfb3XO7e2nSqJiykno4op+MI1guslTAGul7DBXMZdEWOY90IPdB3BqKM+8psmbwKDWMTqOt4N1N\
+ZmZbmoK0FvWD8RWIwY0oPPY4eHGy3Fh7HPlZwb/IFyKPXaQQ+bLMFrnoDLFHF0mDkqSNlgHhqa7B\
+nBUypGeTIk5eWNOJXinxEyjKfxNu2R4tqoD6D6f1RTtGG0zarCC7ux+L/Gq0XqVsvbqazacw9e9/\
+fjE/AfWcnt4=
+compile_options=\
+@eNrlVF1v2jAUfc+vsPI6mY+WMUBNJQgpZIU4omFq+2IZ4xCvsR3lAzF+/ZxQaFD3Uk1IleoosW98\
+fB2fe048JaEgLyzkMQMqybmS2cDI8pTTHKeFXPMUb1nKwz+W2TYNPcw0xDJbjX6raxqGjeb+AJjN\
+SAnWTNmGRWmTxkRuvsXxVsB2q6EvuOt1cbcDYy6LHdzIAharQuYFbPcarU5zxeVhDSgbzPK1Rfv9\
+cii6HQApgOr4aQ0F4PjBd2zdeWNntJy8xni4DBAePQUOWoydhdXata+uO9+7P3oaMB3+crCNvDt3\
+gqdW+7hk7syxi47R4zOAbkPfWcIoFkxgrsooIvBK91QJoaQexHwV7wVpkoTXovJRC9+hacToSy3O\
+uEg0428v1izOyVnCWpBqchhVa5ZqUjYAomvNDUlpZEmS863OE0oFC5mRkOmJPIIlX4LvScUaeGsw\
+VAmTIjmeGvmON/cP6w9VhyTmJONVNV5BM1/XAdxkqkgpuzUNewBs27pg0Q9boNFP5AeWeaYA09B6\
+s/3l3Ww4edBz52qoZkeOZ0/xGeCryMM00ABo0ty5++zow39cK1UG5zFYDHEtzz9VU4Padex7KVVl\
+OSB9tAiGI3fmBk+n4pT6Mo2Z691f9lcC4B6IIl6zsLLEfzjpIza6UavfjObZLaj78CRoACq1z8aX\
+NRQqt7CPpjjx8GkFU1GClqX9a97/C581FVs=
+exehash=831ba8adc1fa08446508f40baa067a6ab08d84d7ca6f4c41b3c815f76844b3ec
+
+600.perlbench_s=base=mytest-m64:
+# Last updated 2020-06-25 22:09:45
+opthash=907b0cc45c96e8c82841c3fdf8e5ad9f953d17059f668d61583d8acba5b7ba87
+baggage=
+compiler_version=\
+@eNqljk1PwzAMhu/5Fb6jNPuoqlIuSGWgXRhiFdcqTaw2WuqgNBn9+UQbGhLsBLJkH177eQx13b5t\
+Xvfb3XO7e2nSqJiykno4op+MI1guslTAGul7DBXMZdEWOY90IPdB3BqKM+8psmbwKDWMTqOt4N1N\
+ZmZbmoK0FvWD8RWIwY0oPPY4eHGy3Fh7HPlZwb/IFyKPXaQQ+bLMFrnoDLFHF0mDkqSNlgHhqa7B\
+nBUypGeTIk5eWNOJXinxEyjKfxNu2R4tqoD6D6f1RTtGG0zarCC7ux+L/Gq0XqVsvbqazacw9e9/\
+fjE/AfWcnt4=
+compile_options=\
+@eNrVVFuPmkAUfudXTHhtRjQ1ZjXLJoCj0qJDuCS2LxPEUaeFwXAx7v76noHVuum+tI0PCyGcmXP5\
+5juXWRUS58lPvhMZR8WxFoWsJlpVlyKtWdnIrSjZiZdi92zqA10DsQITU+/3xv2RrmkOXfoTpBuH\
+IudGyff8UBpplsj9pyw75XjQ78GLzw8jNhriTMjmjPeywc2mkXWDBw+9/tDYCNn5IPXgqt6a6Xis\
+xHw0RDhFuLgcrVcgPA194sBvNSV2PAfBJ4HHHBoQhN0efFtR1YZLQUqPiTQikXO8EAGvLjuLaOlh\
+PykrXsIWP9dwchCqI0/LRG4h5JTGtkdY6FnhgoRMIbqWZ/ZBxTwrmBM2cz0SXpdqxUIaBw5Re+2S\
+zmYhiZjtRqEJPBDeI0w/A6mkTA+mTGpxAtSdLHAjq2THQVEfsCKai5ekpYten44z89xVvGZrFQwc\
+iyOX+fGioz5ZLf0uXlc+nGQiqUSb1ksAX/k+VkVTpvxJ15wJchzzjtXrIKj9hfqRqb8ppa5B4zh+\
+PPOseQi6t2VttTZZOQt2NfgQddY1OkHA1l263wmc+u+L3lL3aRBZtuu50bdLbn6Xv8Ug6yiw2A3S\
+uw1xY+rc2v7ZJS1sZ/kuuK9w4Qhf7zvuCL+gvMm2fNd2/78OzX9OzGOx+cHTunpSflmOroN4bV+E\
+2t72pvcdH6ognMsIXFPzgbsMkra0ogXg2IpSlr/mkcbqhri5Hn4BqSr+bQ==
+exehash=1ee7e30760e0713c443ffed500f5c499e47ec1798060286a93dce3e5f0f3d14d
+
+602.gcc_s=base=mytest-m64:
+# Last updated 2020-06-25 22:10:32
+opthash=14f1196589cb9b1dd88642f41aec44e5db7becf08349215dede2ee1803515245
+baggage=
+compiler_version=\
+@eNqljk1PwzAMhu/5Fb6jNPuoqlIuSGWgXRhiFdcqTaw2WuqgNBn9+UQbGhLsBLJkH177eQx13b5t\
+Xvfb3XO7e2nSqJiykno4op+MI1guslTAGul7DBXMZdEWOY90IPdB3BqKM+8psmbwKDWMTqOt4N1N\
+ZmZbmoK0FvWD8RWIwY0oPPY4eHGy3Fh7HPlZwb/IFyKPXaQQ+bLMFrnoDLFHF0mDkqSNlgHhqa7B\
+nBUypGeTIk5eWNOJXinxEyjKfxNu2R4tqoD6D6f1RTtGG0zarCC7ux+L/Gq0XqVsvbqazacw9e9/\
+fjE/AfWcnt4=
+compile_options=\
+@eNrNU11vmzAUfedXWLxOBrJlUROVSuDQhI1g1JJp24tFiEm8GTvDEHX99TMQ2lTbS1VFmhHyle65\
+X+cex1LAMvtJC8YpkIeaSaFmhqorltekasSWVeRIK1b8ds2RaWhTaYhrOtbU+WgaBsKrZAZMey9L\
+ald0R/eVnfNM7N5xfizhyLH0Bx+uJmQyhpyJ5gHuRAObTSPqBo6uLGdsb5joY0B7oKq3bj6dtmY5\
+GQOYAyiH1iwJ4Pw+CZC+4nngrxcAhlb720zkvNnSzlYHmpNfSlb1CU4mzntthjFZoDZ26X0JCMLx\
+bbggS11oByD+oOtlVb53RVazo05UCAkbobKCake9h20PJXvMuk7A84GFPFBRHoZaOAniVdLH90zC\
+jLNMsW7CEyhK9GzgWsmmyumNaaAZQMi9IJF9Cex/wknqmi9YNQ29Q5SsbyNvca99LxnuvH4QoyUZ\
+AG+m3DTwDOhGwlX4PdAJX89/lyH4mt555CzPPzdxBkXn2L/X043aIxN8l3p+GIXpt4GRbmemEYXx\
+58tKHsBHUDZ8S4tOZm9Q52ukeS03P2heq5s2jpfP8n7SCQCdiKL5ZXWK2xJo0NoTFf+tZjQlKy9d\
+kij024Z5eWIJr9uHdvbK/gBv0qVM
+exehash=0654b3abce3760d642c090c666702a69a4c0c9112b22110d275ca022933ede0c
+
+605.mcf_s=base=mytest-m64:
+# Last updated 2020-06-25 22:10:34
+opthash=1e68d6f40376a933c48dd1d3feb70318f9d13d20dda7acf6ff62347aaffbd80d
+baggage=
+compiler_version=\
+@eNqljk1PwzAMhu/5Fb6jNPuoqlIuSGWgXRhiFdcqTaw2WuqgNBn9+UQbGhLsBLJkH177eQx13b5t\
+Xvfb3XO7e2nSqJiykno4op+MI1guslTAGul7DBXMZdEWOY90IPdB3BqKM+8psmbwKDWMTqOt4N1N\
+ZmZbmoK0FvWD8RWIwY0oPPY4eHGy3Fh7HPlZwb/IFyKPXaQQ+bLMFrnoDLFHF0mDkqSNlgHhqa7B\
+nBUypGeTIk5eWNOJXinxEyjKfxNu2R4tqoD6D6f1RTtGG0zarCC7ux+L/Gq0XqVsvbqazacw9e9/\
+fjE/AfWcnt4=
+compile_options=\
+@eNrNU11vmzAUfedXWH6dnA8ti5qoVALCWjaCrQDStheLEJN4AzvDJmr762dISFNtD6umSLMfbOme\
+e4/vuceRFKjKfrCClwzIveZSqLmldM1zTetGbHhND6zmxZMNx9AyV2UgNhwNZqMP0LI8vCRzAIc7\
+WbFhzbZsVw/zMhPbd2V5qNB4NDAbPd5M6XSCSi6aR7QVDWrWjdANGt8MRpPhmotjDmgXUnpj57NZ\
+e62mE4BygGT/tIEEaBET3zNHtPDd9N6gArVnOf2pZK1PUeqkCaZxSsjKj2OKiR8tCUBbgPB7UzWr\
+850tMs0PDKBCSNQIlRXMBPQOtUwVf846PvCyUCH3TFT7nqIv2uYf9UJZyTPFuz5OoJCYDsCtkk2d\
+sztoeXPgefYV5TpSYPcTJokNX2kHLTMpj6QfQ+c+NrHXOnZR14+8B+r1iL8UFlp4DgxfsAy++Sbt\
+7TJ3FfwvycqhF3X+KPgF1LvE/j6FrqMjkuBV4rhBGCRf+8a70UArDKLP1/UvQM+gasoNKzo3/YMJ\
+3+LAW7n+znKt7tq8snpx8dkOAHReCRfXtSNuKc6OOkvx33rGSLJ0kgcaBm774LI6qYTT9j9dfKZf\
+nnCZew==
+exehash=74301dbb564b8ee971cd477f84b57b7a0755bde3b525851ffd1f07b2538a2619
+
+620.omnetpp_s=base=mytest-m64:
+# Last updated 2020-06-25 22:10:47
+opthash=ac82ef050b5d602e5ea409917b179e4c825ee611121ec9d5bfc75bc7d43856cf
+baggage=
+compiler_version=\
+@eNqljk1rwzAMhu/+FboPx/0IIcsug+yDXtaxhtFbcGyRmDnycOwuP3+mHR1sPW0IpMMrPY+g3u/r\
+9vX+ZbfZPrXb5yaNiikrqYcD+sk4guUiSwWskb7HUMFcFm2R80hv5D6IW0Nx5j1F1gwepYbRabQV\
+vLvJzGxDU5DWor4zvgIxuBGFxx4HL46WK2sPIz8p+Bf5TOSxixQiX5bZIhedIfbgImlQkrTRMiA8\
+1jWYk0KG9GxSxMkLazrRKyV+AkX5b8I126FFFVD/4bQ+a8dog0mbFWQ3t2ORX4zWq5StVxez+Rim\
+/v3PL+YnPWqfjg==
+compile_options=\
+@eNq9UtFugjAUfecrmr6aimbOOCMmgkzZEIhi5vZCEIt2g5YUaty+fhVl0WV7mIkrD7303t57es5x\
+GEVp+IZjkmDAsoIwmneVvOAkKgIu6IrwYIs5id812ISKDHNZosFG/a5xCxXFcCdeF0B1w1KscrzG\
+G65GSUjXtSTZpqjZqMsP7TrtoN1CCaFih9ZUILEUtBCo2ak3WuqS0OOdGvi2UNpuARQBxCpwdQbQ\
+cOaZhtycoanPRwBZOUlFEhaMq5ncVjg7PZNxylY4kReeLH8cOKavzy17aE5l/zVA7o0cE/Joo9Gw\
+IFsMUEwZEjQPYywTxQbtR6fkIywBVMhilmGaZkc0geuZzsQD1a/tSeCglzPBI9yHitEFxmKhXZWo\
+aoqrP7ier8Ez3qAidTK8+b09GM1k7pzDMqubjjEOqoJLSYWK2wVyvjWxXkzZ5+8Mlx3MhT8dBCd9\
+fuS7xH0o9dypP9At2/Kfq+eVKkDFtpzHa3v0EF3spl/t1GPLVxwVef9s4peqAJSi28NrO+tfNS1f\
+5M73Fj7x7ydUcWbI
+exehash=88de3f578825ea272fbfaf5b6014c6d9dc0d161584c69a1fdcf399e08a8e958c
+
+623.xalancbmk_s=base=mytest-m64:
+# Last updated 2020-06-25 22:13:30
+opthash=e157e2d78ed014f146dcf4f980554a1bbc61340376242e383ba7104fc05ee8b3
+baggage=
+compiler_version=\
+@eNqljk1rwzAMhu/+FboPx/0IIcsug+yDXtaxhtFbcGyRmDnycOwuP3+mHR1sPW0IpMMrPY+g3u/r\
+9vX+ZbfZPrXb5yaNiikrqYcD+sk4guUiSwWskb7HUMFcFm2R80hv5D6IW0Nx5j1F1gwepYbRabQV\
+vLvJzGxDU5DWor4zvgIxuBGFxx4HL46WK2sPIz8p+Bf5TOSxixQiX5bZIhedIfbgImlQkrTRMiA8\
+1jWYk0KG9GxSxMkLazrRKyV+AkX5b8I126FFFVD/4bQ+a8dog0mbFWQ3t2ORX4zWq5StVxez+Rim\
+/v3PL+YnPWqfjg==
+compile_options=\
+@eNrtVFtvmzAUfudXWLxWDsmWRV3UVHKApXSALS4T24tFiJN4AzviEqX79TNkpEnVh61SpD0MhDg3\
+Hx+f7zv2pYBF+oOtec6A3NVcimqqVXXJs5qWjVjxku5ZyddPM32ka0qsVMhMHw4+Dj/ommZij0yB\
+bmxlwYySbdi2NLI8FZubPN8XcDQcqBcebid0MoY5F80BbkQDm2Uj6gaObgfDsbHk4veaG/DigcVk\
+DGAGoOyLG0gArZDYpvr5lj2PFyrKQoRQH9PoIbCRFSpDglzkU8f3bI964YK6GFl2AKAzUN+BlRmr\
+smfJWMniUjN4scvPTFV6ONOamueGV21cma5URwxHeKyQ5dPLkKhMRZXJY0wmxb4NSNVRM4OLLG9W\
+TJVKAvxIE88lKAjbEk+GOHLcXj06w14NUTI2z5R3vWxhrxe/INexUIS7VSodjUO774gdhmhh903Z\
+AIjfq16nZbadibTme1XXWkjYiCpdM+Wot7Dtf8F/ph0KHTYdDNR1/Dhp1bXcMVHsejsmtu+R5zCi\
+kAR3lWxUf+51zZwCM0lmV2VOvwueP2ISzfQLIumaIq5J4k8uWoTKd0mqzju3ffOBqgSnmP88ezvP\
+dA1PgcLB8Zxvtmrm37OuA4XgIEJzx3Wirz1qRw52+e0kChA92+VVVnaJjqGvpiMtd1TSz9e+2o7S\
+2+bvTwfwTi6/s6yu7i92P80BAN2YuNa1Z/EfQr87L47bK+HsPvgFP4cjFg==
+exehash=46100421a58a2fce0b5e2e77a8ac0a49ee11501c95be0c9a6fec64849d6c3c24
+
+625.x264_s=base=mytest-m64:
+# Last updated 2020-06-25 22:13:39
+opthash=4e249d09be8d3df6af70cc6ed4c18c6713211c2bda4e20b62a940f3be8c64b6e
+baggage=
+compiler_version=\
+@eNqljk1PwzAMhu/5Fb6jNPuoqlIuSGWgXRhiFdcqTaw2WuqgNBn9+UQbGhLsBLJkH177eQx13b5t\
+Xvfb3XO7e2nSqJiykno4op+MI1guslTAGul7DBXMZdEWOY90IPdB3BqKM+8psmbwKDWMTqOt4N1N\
+ZmZbmoK0FvWD8RWIwY0oPPY4eHGy3Fh7HPlZwb/IFyKPXaQQ+bLMFrnoDLFHF0mDkqSNlgHhqa7B\
+nBUypGeTIk5eWNOJXinxEyjKfxNu2R4tqoD6D6f1RTtGG0zarCC7ux+L/Gq0XqVsvbqazacw9e9/\
+fjE/AfWcnt4=
+compile_options=\
+@eNrtVF1vmzAUfedXWLxODqSlLIlKJSCsZSMYpURa94IIMYk3bEd8RKy/fgZCS7W9VFOkTcI8YPC1\
+7/U55x6fM0jjHzglGQb8WBLOioVUlDlJyiiv2I7k0QnnJP1pyFNZEtNChBiyOpmrN7Ik2WgVLICs\
+HDjFSo73+JArSRaz/YcsO1E4VSfigfVMj3QNZoRVNdyzClbbipUVnM4mqqZsCev2gGbAotwZyXze\
+TKmuAZgAyPvSJhzA5WPg2OLlLx1rcw+gm+1wwndRkScKYSLara90rfkcTBVcl3lcDP8knFLOzudF\
+5iZEkfUUOmi9dNaGWk+vrrUb/eNMlLEHEF2LauI8ORgsLskJA5gyDitWxCkWC+UBNhVS8hy3dYLX\
+AVN+xIwe+0QocPxV0O3vcIZxRuKCtPc/B3mBuDm4LXiVJ/hOluwFsG3jgjB3KZD1GQWhIb/BXJYE\
+w3aw+eSZ949i7S3+7arl+PZD1AdcmBBZQgsgynRX7jdHpHs/O+0JztdwbUaDc/7I0yDUHsb+Tl4L\
+RBcZoHVoWq7nhk89Xi2jsuS5/pfLtguAz4BWgoG0FeFfaPc9wr3l2+84KYu7Zl9GX8X/oiIAWol5\
+y8uqGDUp7F6JL1D8s5oRkKzM8CHyXKspOKNnlNCmacNBD45OOzrt6LSj045OOzrt6LSj045OOzrt\
+/+60vwD2jQdA
+exehash=febddc7bbd4725640e41c696768cb2b935f16a40a8cfb974f6a8b3e415e91e24
+
+631.deepsjeng_s=base=mytest-m64:
+# Last updated 2020-06-25 22:13:42
+opthash=5da7ed2900e822c354523d8b71fc01a2b542353da3cb9b2cd67111d8ee5a9227
+baggage=
+compiler_version=\
+@eNqljk1rwzAMhu/+FboPx/0IIcsug+yDXtaxhtFbcGyRmDnycOwuP3+mHR1sPW0IpMMrPY+g3u/r\
+9vX+ZbfZPrXb5yaNiikrqYcD+sk4guUiSwWskb7HUMFcFm2R80hv5D6IW0Nx5j1F1gwepYbRabQV\
+vLvJzGxDU5DWor4zvgIxuBGFxx4HL46WK2sPIz8p+Bf5TOSxixQiX5bZIhedIfbgImlQkrTRMiA8\
+1jWYk0KG9GxSxMkLazrRKyV+AkX5b8I126FFFVD/4bQ+a8dog0mbFWQ3t2ORX4zWq5StVxez+Rim\
+/v3PL+YnPWqfjg==
+compile_options=\
+@eNq9Ut9PwjAQft9f0fSVdIOIRBdGwsbE6bY2/EjAl2XMDqpbS/aDoH+9ZTAEow+aYPvQa+7uu7vv\
+Pl9wlIavNGYJBWJdMMFzXcmLjEVFkJX8mWXBhmYsfjNgCyrSzGWIAZvqbfMaKoqFPaIDqK1ESrWM\
+Lukq06Ik5MtGkmxS1Gqq8qLtTSfotFHCeLlFS16iclHyokStG7XZ1haMH3Ia4MtBaacNUASQqJtT\
+BUCDMbEt+fgD25wOpWE6w8CzPTyay5QlQPhKZoZZtDJ4WLANBSjmApU8D2MqHcUK7dBS9h5WmHWx\
+WKwpT9eHAgEmtu8RUH9dInsB3VyUWUR7ULF0YM1mxkVnr6tg8wGTiQHPqICKpN4i0zu3PxxL3zkt\
+lde0fes+OAZ88gQVrAMJ6XjOky1dvyetQrBnk1E/OMH5lsKqlX0owaNJ33RcZzKvO66IhYrr+I+X\
+VtLe+rNAflRIVyxeaFTkvbOKx0UBUO3RHVxaLP+602oiPN2p8kSSH3DKRnI=
+exehash=fe58038d418ab5a96dcea993f4e1f5fa71235a4cc92cd8f702f5e01a7908e4f2
+
+641.leela_s=base=mytest-m64:
+# Last updated 2020-06-25 22:13:45
+opthash=211129e285d3881be653ebcba5d4ff7057a8e12dd91adf1e053e7a1b1f70fbaa
+baggage=
+compiler_version=\
+@eNqljk1rwzAMhu/+FboPx/0IIcsug+yDXtaxhtFbcGyRmDnycOwuP3+mHR1sPW0IpMMrPY+g3u/r\
+9vX+ZbfZPrXb5yaNiikrqYcD+sk4guUiSwWskb7HUMFcFm2R80hv5D6IW0Nx5j1F1gwepYbRabQV\
+vLvJzGxDU5DWor4zvgIxuBGFxx4HL46WK2sPIz8p+Bf5TOSxixQiX5bZIhedIfbgImlQkrTRMiA8\
+1jWYk0KG9GxSxMkLazrRKyV+AkX5b8I126FFFVD/4bQ+a8dog0mbFWQ3t2ORX4zWq5StVxez+Rim\
+/v3PL+YnPWqfjg==
+compile_options=\
+@eNq9Ut9vgjAQfuevaPpqCpg544iYCDLHhtAoJm4vBFmBbtAafhi3v34VZdFle9gS1z702rv77vrd\
+53KG8vCVxDQjgG8qylmpSWVV0KgKipo90yLYkoLGbzrsQkmYpQjRoSrfqNdQkkxvhjUAlZTnRClI\
+QtJCibKQJZ0s2+aoq8pio92gH/R7KKOs3qGE1ahe16yqUXcgqz1lTdkxpwO+LJT3ewBFAPG2OZkD\
+NFlgyxSHO7GM5RQgWxaRCUDelUgIiyjVWVjRLQEoZhzVrAxjIhxVivYgOX0PG6i2Rsw3hOWbI27g\
+YcudYdBeHSxaAMOS10VERlAyNWCuVvpFv9xW8Yx7D/s6PGMASoJxEy9vnfF0IXznbDRew3LNu6AN\
+sGUoeRoQSPbMfrLEy++5ahCslT8fByc43zLXdHAIxd7cHxu2Y/uPbaMNn1BybPfh0ro5WH/WxY/C\
+GPL1C4mqcnRW8XM+ADTjcyaX1si/zrT5kbfci/FEiR+VsUDE
+exehash=2b341b860afcb4fb72dbdc2bab75ba57c448767e2deca2c36f2d40694ccc433a
+
diff -x '*.orig' -x '*.rej' -urpN work.orig/souper-scripts/README.txt work/souper-scripts/README.txt
--- work.orig/souper-scripts/README.txt	1969-12-31 16:00:00.000000000 -0800
+++ work/souper-scripts/README.txt	2022-02-09 07:27:19.884194989 -0800
@@ -0,0 +1,21 @@
+This directory contains scripts used to qualify a hacked LLVM before
+it is used by Souper.
+
+The LLVM is hacked to disable some unsound optimizations (that
+increase the amount of undefined behavior) and also to disable
+peephole optimizations that Souper competes with, in order to answer
+the research question "can Souper replace InstCombine and some of its
+friends."
+
+The strategy is to build three LLVMs:
+1. all peepholes and unsound optimizations enabled by default
+2. only unsound disabled by default
+3. both peepholes and unsound disabled by default
+
+Then to make sure that each of these can build a working LLVM that
+passes all of its tests, and to make sure that each can build
+benchmarks from SPEC CPU 2017, and those pass all their test.
+
+TODO
+- also test debug builds?
+
diff -x '*.orig' -x '*.rej' -urpN work.orig/souper-scripts/test-disable-peepholes.sh work/souper-scripts/test-disable-peepholes.sh
--- work.orig/souper-scripts/test-disable-peepholes.sh	1969-12-31 16:00:00.000000000 -0800
+++ work/souper-scripts/test-disable-peepholes.sh	2022-02-09 07:27:19.885195030 -0800
@@ -0,0 +1,102 @@
+set -e -x
+
+CLANGBIN=$HOME/clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/bin
+
+DIR=$HOME/llvm-project
+CMAKE='cmake -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON ../llvm -DLLVM_ENABLE_PROJECTS="llvm;clang;compiler-rt"'
+
+rm -rf $DIR/build-*
+rm -rf $DIR/install-*
+
+function is_bin_in_path {
+  builtin type -P "$1" &> /dev/null
+}
+
+if is_bin_in_path clang; then
+    echo "oops, please make sure clang is not in PATH";
+    exit -1;
+fi
+
+if is_bin_in_path clang++; then
+    echo "oops, please make sure clang++ is not in PATH";
+    exit -1;
+fi
+
+# this LLVM should behave identically to its twin on the main branch
+(
+set -e
+export PATH=$CLANGBIN:$PATH
+mkdir $DIR/build-default
+cd $DIR/build-default
+$CMAKE -DCMAKE_INSTALL_PREFIX=$DIR/install-default -DCMAKE_CXX_FLAGS='-DDISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE=false -DDISABLE_PEEPHOLES_DEFAULT_VALUE=false' > cmake.out 2>&1
+ninja > build.out 2>&1
+ninja check > check.out 2>&1 || true
+ninja install
+)
+
+# this makes sure the default LLVM we just built can build a working LLVM
+(
+set -e
+export PATH=$DIR/install-default/bin:$PATH
+mkdir $DIR/build-default2
+cd $DIR/build-default2
+$CMAKE -DCMAKE_INSTALL_PREFIX=$DIR/install-default2 -DCMAKE_CXX_FLAGS='-DDISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE=false -DDISABLE_PEEPHOLES_DEFAULT_VALUE=false' > cmake.out 2>&1
+ninja > build.out 2>&1
+ninja check > check.out 2>&1 || true
+ninja install
+)
+
+# this LLVM avoids optimizations that introduce UB, it will fail tests that look for those optimizations
+(
+set -e
+export PATH=$CLANGBIN:$PATH
+mkdir $DIR/build-no-ub
+cd $DIR/build-no-ub
+$CMAKE -DCMAKE_INSTALL_PREFIX=$DIR/install-no-ub -DCMAKE_CXX_FLAGS='-DDISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE=true -DDISABLE_PEEPHOLES_DEFAULT_VALUE=false' > cmake.out 2>&1
+ninja > build.out 2>&1
+ninja check > check.out 2>&1 || true
+ninja install
+)
+
+# this makes sure the no-UB LLVM we just built can build a working LLVM
+(
+set -e
+export PATH=$DIR/install-no-ub/bin:$PATH
+mkdir $DIR/build-no-ub2
+cd $DIR/build-no-ub2
+$CMAKE -DCMAKE_INSTALL_PREFIX=$DIR/install-no-ub2 -DCMAKE_CXX_FLAGS='-DDISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE=false -DDISABLE_PEEPHOLES_DEFAULT_VALUE=false' > cmake.out 2>&1
+ninja > build.out 2>&1
+ninja check > check.out 2>&1 || true
+ninja install
+)
+
+# this LLVM avoids optimizations that do peephole-like things and that
+# introduce UB, it will fail tests that look for those optimizations
+(
+set -e
+export PATH=$CLANGBIN:$PATH
+mkdir $DIR/build-no-ub-no-peeps
+cd $DIR/build-no-ub-no-peeps
+$CMAKE -DCMAKE_INSTALL_PREFIX=$DIR/install-no-ub-no-peeps -DCMAKE_CXX_FLAGS='-DDISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE=true -DDISABLE_PEEPHOLES_DEFAULT_VALUE=true' > cmake.out 2>&1
+ninja > build.out 2>&1
+ninja check > check.out 2>&1 || true
+ninja install
+)
+
+# this makes sure the no-UB, no-peephole LLVM we just built can build a working LLVM
+(
+set -e
+export PATH=$DIR/install-no-ub-no-peeps/bin:$PATH
+mkdir $DIR/build-no-ub-no-peeps2
+cd $DIR/build-no-ub-no-peeps2
+$CMAKE -DCMAKE_INSTALL_PREFIX=$DIR/install-no-ub-no-peeps2 -DCMAKE_CXX_FLAGS='-DDISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE=false -DDISABLE_PEEPHOLES_DEFAULT_VALUE=false' > cmake.out 2>&1
+ninja > build.out 2>&1
+ninja check > check.out 2>&1 || true
+ninja install
+)
+
+size $DIR/install-default2/bin/clang-12 $DIR/install-no-ub2/bin/clang-12 $DIR/install-no-ub-no-peeps2/bin/clang-12
+
+grep 'Failed Tests' build-default2/check.out build-no-ub2/check.out build-no-ub-no-peeps2/check.out
+
+exit 0
diff -x '*.orig' -x '*.rej' -urpN work.orig/souper-scripts/test-spec.sh work/souper-scripts/test-spec.sh
--- work.orig/souper-scripts/test-spec.sh	1969-12-31 16:00:00.000000000 -0800
+++ work/souper-scripts/test-spec.sh	2022-02-09 07:27:19.885195030 -0800
@@ -0,0 +1,26 @@
+set -e
+
+#INPUT=test
+INPUT=ref
+
+SPEC=$HOME/cpu2017
+DIR=$HOME/llvm-project
+ARGS="--rebuild --input $INPUT 600.perlbench_s 602.gcc_s 605.mcf_s 620.omnetpp_s 623.xalancbmk_s 625.x264_s 631.deepsjeng_s 641.leela_s 657.xz_s"
+
+cd $SPEC
+. ./shrc
+
+sed -e 's/LLVMDIR/\/home\/regehr\/llvm-project\/install-default2/g' < $DIR/souper-scripts/default.cfg > $SPEC/config/default.cfg
+runcpu $ARGS
+
+sed -e 's/LLVMDIR/\/home\/regehr\/llvm-project\/install-no-ub2/g' < $DIR/souper-scripts/default.cfg > $SPEC/config/default.cfg
+runcpu $ARGS
+
+sed -e 's/LLVMDIR/\/home\/regehr\/llvm-project\/install-no-ub-no-peeps2/g' < $DIR/souper-scripts/default.cfg > $SPEC/config/default.cfg
+runcpu $ARGS
+
+echo
+echo =======
+echo SUCCESS
+echo =======
+echo
