Patch status:  Testing

Mostly the same as disable-peepholes-v07.diff but forward ported to 13.x.

The header license of many of these files:

// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

The original .diff patch can be obtained from:
https://github.com/regehr/llvm-project/compare/072c90a863aac1334a4950b3da262a025516dea0...disable-peepholes-v07.diff

For commit history details see:
https://github.com/regehr/llvm-project/compare/072c90a863aac1334a4950b3da262a025516dea0...disable-peepholes-v07


Additional notes and oteodoro changes:

Some hunks were dropped related to omitCheck* in work/llvm/lib/Analysis/InstructionSimplify.cpp.
The testing scripts is not updated to be version and dev environment agnostic.

There was a misplaced hunk in the without fuzz placed in the wrong relative location with InstCombineSelect.cpp, but corrected.

The eliminateDeadCode function in the patch was replaced with the same 13.x version but without static keyword.

New Poison sections were encountered.  The placement for these DisablePeepholes points should be peer reviewed or unit tested,
but as for now they are treated as part of the problem in that particular peephole function implementation.

The diff patch was used to drop extraneous patches/hunks in the generated .patch version.
This is to avoid possible duplicate hunks.

The test patch files have been moved to disable-peepholes-v07-tests.diff.

No new peephole functions if any have been checked.

----

diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/include/llvm/Transforms/Scalar/DCE.h work/llvm/include/llvm/Transforms/Scalar/DCE.h
--- work.orig/llvm/include/llvm/Transforms/Scalar/DCE.h	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/include/llvm/Transforms/Scalar/DCE.h	2022-02-13 14:29:34.895416283 -0800
@@ -13,9 +13,12 @@
 #ifndef LLVM_TRANSFORMS_SCALAR_DCE_H
 #define LLVM_TRANSFORMS_SCALAR_DCE_H
 
+#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/PassManager.h"
 
+bool eliminateDeadCode(llvm::Function &F, llvm::TargetLibraryInfo *TLI);
+
 namespace llvm {
 
 /// Basic Dead Code Elimination pass.
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Analysis/InstructionSimplify.cpp work/llvm/lib/Analysis/InstructionSimplify.cpp
--- work.orig/llvm/lib/Analysis/InstructionSimplify.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Analysis/InstructionSimplify.cpp	2022-02-13 14:36:05.463708921 -0800
@@ -42,11 +42,26 @@
 #include "llvm/IR/Operator.h"
 #include "llvm/IR/PatternMatch.h"
 #include "llvm/IR/ValueHandle.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/KnownBits.h"
 #include <algorithm>
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+bool DisablePeepholes = DISABLE_PEEPHOLES_DEFAULT_VALUE;
+bool DisableWrongOptimizations = DISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE;
+
+// "true" for 2nd template argument means use external storage
+static cl::opt<bool, true>
+DisablePeepholesOption("disable-all-peepholes",
+                       cl::desc("Don't perform peephole optimizations"),
+                       cl::location(DisablePeepholes));
+
+static cl::opt<bool, true>
+DisableWrongOptsOption("disable-wrongs-opts",
+                       cl::desc("Disable optimizations that may increase the amount of undefined behavior"),
+                       cl::location(DisableWrongOptimizations));
+
 #define DEBUG_TYPE "instsimplify"
 
 enum { RecursionLimit = 3 };
@@ -77,6 +92,9 @@ static Value *SimplifySelectInst(Value *
 
 static Value *foldSelectWithBinaryOp(Value *Cond, Value *TrueVal,
                                      Value *FalseVal) {
+  if (DisablePeepholes)
+    return nullptr;
+
   BinaryOperator::BinaryOps BinOpCode;
   if (auto *BO = dyn_cast<BinaryOperator>(Cond))
     BinOpCode = BO->getOpcode();
@@ -132,6 +150,9 @@ static Constant *getTrue(Type *Ty) {
 /// isSameCompare - Is V equivalent to the comparison "LHS Pred RHS"?
 static bool isSameCompare(Value *V, CmpInst::Predicate Pred, Value *LHS,
                           Value *RHS) {
+  if (DisablePeepholes)
+    return false;
+
   CmpInst *Cmp = dyn_cast<CmpInst>(V);
   if (!Cmp)
     return false;
@@ -188,6 +209,9 @@ static Value *handleOtherCmpSelSimplific
                                                Value *Cond,
                                                const SimplifyQuery &Q,
                                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the false value simplified to false, then the result of the compare
   // is equal to "Cond && TCmp".  This also catches the case when the false
   // value simplified to false and the true value to true, returning "Cond".
@@ -243,6 +267,9 @@ static bool valueDominatesPHI(Value *V,
 static Value *expandBinOp(Instruction::BinaryOps Opcode, Value *V,
                           Value *OtherOp, Instruction::BinaryOps OpcodeToExpand,
                           const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   auto *B = dyn_cast<BinaryOperator>(V);
   if (!B || B->getOpcode() != OpcodeToExpand)
     return nullptr;
@@ -279,6 +306,9 @@ static Value *expandCommutativeBinOp(Ins
                                      Instruction::BinaryOps OpcodeToExpand,
                                      const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -296,6 +326,9 @@ static Value *SimplifyAssociativeBinOp(I
                                        Value *LHS, Value *RHS,
                                        const SimplifyQuery &Q,
                                        unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(Instruction::isAssociative(Opcode) && "Not an associative operation!");
 
   // Recursion is always used, so bail out at once if we already hit the limit.
@@ -395,6 +428,9 @@ static Value *SimplifyAssociativeBinOp(I
 static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -473,6 +509,9 @@ static Value *ThreadBinOpOverSelect(Inst
 static Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q,
                                   unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -519,6 +558,9 @@ static Value *ThreadCmpOverSelect(CmpIns
 static Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,
                                  Value *RHS, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -561,6 +603,9 @@ static Value *ThreadBinOpOverPHI(Instruc
 /// otherwise returns null.
 static Value *ThreadCmpOverPHI(CmpInst::Predicate Pred, Value *LHS, Value *RHS,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -620,6 +665,9 @@ static Value *SimplifyAddInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Add, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X + undef -> undef
   if (Q.isUndefValue(Op1))
     return Op1;
@@ -717,6 +765,9 @@ static Constant *stripAndComputeConstant
 /// If the difference is not a constant, returns zero.
 static Constant *computePointerDifference(const DataLayout &DL, Value *LHS,
                                           Value *RHS) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Constant *LHSOffset = stripAndComputeConstantOffsets(DL, LHS);
   Constant *RHSOffset = stripAndComputeConstantOffsets(DL, RHS);
 
@@ -739,6 +790,9 @@ static Value *SimplifySubInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Sub, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X - poison -> poison
   // poison - X -> poison
   if (isa<PoisonValue>(Op0) || isa<PoisonValue>(Op1))
@@ -879,6 +933,9 @@ static Value *SimplifyMulInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Mul, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X * poison -> poison
   if (isa<PoisonValue>(Op1))
     return Op1;
@@ -940,6 +997,9 @@ Value *llvm::SimplifyMulInst(Value *Op0,
 /// This applies to all 4 opcodes (sdiv/udiv/srem/urem).
 static Value *simplifyDivRem(Instruction::BinaryOps Opcode, Value *Op0,
                              Value *Op1, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   bool IsDiv = (Opcode == Instruction::SDiv || Opcode == Instruction::UDiv);
   bool IsSigned = (Opcode == Instruction::SDiv || Opcode == Instruction::SRem);
 
@@ -1031,6 +1091,9 @@ static bool isICmpTrue(ICmpInst::Predica
 /// to simplify X % Y to X.
 static bool isDivZero(Value *X, Value *Y, const SimplifyQuery &Q,
                       unsigned MaxRecurse, bool IsSigned) {
+  if (DisablePeepholes)
+    return false;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return false;
@@ -1085,6 +1148,9 @@ static Value *simplifyDiv(Instruction::B
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Opcode, Op0, Op1, Q))
     return V;
 
@@ -1129,6 +1195,9 @@ static Value *simplifyRem(Instruction::B
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Opcode, Op0, Op1, Q))
     return V;
 
@@ -1170,6 +1239,9 @@ static Value *simplifyRem(Instruction::B
 /// If not, this returns null.
 static Value *SimplifySDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If two operands are negated and no signed overflow, return -1.
   if (isKnownNegation(Op0, Op1, /*NeedNSW=*/true))
     return Constant::getAllOnesValue(Op0->getType());
@@ -1196,6 +1268,9 @@ Value *llvm::SimplifyUDivInst(Value *Op0
 /// If not, this returns null.
 static Value *SimplifySRemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the divisor is 0, the result is undefined, so assume the divisor is -1.
   // srem Op0, (sext i1 X) --> srem Op0, -1 --> 0
   Value *X;
@@ -1260,6 +1335,9 @@ static Value *SimplifyShift(Instruction:
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // poison shift by X -> poison
   if (isa<PoisonValue>(Op0))
     return Op0;
@@ -1327,6 +1405,9 @@ static Value *SimplifyShift(Instruction:
 static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
                                  Value *Op1, bool isExact, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V =
           SimplifyShift(Opcode, Op0, Op1, /*IsNSW*/ false, Q, MaxRecurse))
     return V;
@@ -1354,6 +1435,9 @@ static Value *SimplifyRightShift(Instruc
 /// If not, this returns null.
 static Value *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V =
           SimplifyShift(Instruction::Shl, Op0, Op1, isNSW, Q, MaxRecurse))
     return V;
@@ -1387,6 +1471,9 @@ Value *llvm::SimplifyShlInst(Value *Op0,
 /// If not, this returns null.
 static Value *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::LShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
       return V;
@@ -1425,6 +1512,9 @@ Value *llvm::SimplifyLShrInst(Value *Op0
 /// If not, this returns null.
 static Value *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::AShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
     return V;
@@ -1457,6 +1547,9 @@ Value *llvm::SimplifyAShrInst(Value *Op0
 static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
                                          ICmpInst *UnsignedICmp, bool IsAnd,
                                          const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X, *Y;
 
   ICmpInst::Predicate EqPred;
@@ -1565,6 +1658,9 @@ static Value *simplifyUnsignedRangeCheck
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1590,6 +1686,9 @@ static Value *simplifyAndOfICmpsWithSame
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1618,6 +1717,9 @@ static Value *simplifyOrOfICmpsWithSameO
 /// the other.
 static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                 bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look for this pattern: {and/or} (icmp X, C0), (icmp X, C1)).
   if (Cmp0->getOperand(0) != Cmp1->getOperand(0))
     return nullptr;
@@ -1655,6 +1757,9 @@ static Value *simplifyAndOrOfICmpsWithCo
 
 static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                            bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate P0 = Cmp0->getPredicate(), P1 = Cmp1->getPredicate();
   if (!match(Cmp0->getOperand(1), m_Zero()) ||
       !match(Cmp1->getOperand(1), m_Zero()) || P0 != P1)
@@ -1692,6 +1797,9 @@ static Value *simplifyAndOrOfICmpsWithZe
 
 static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                         const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) & (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1740,6 +1848,9 @@ static Value *simplifyAndOfICmpsWithAdd(
 /// Try to eliminate compares with signed or unsigned min/max constants.
 static Value *simplifyAndOrOfICmpsWithLimitConst(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                  bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Canonicalize an equality compare as Cmp0.
   if (Cmp1->isEquality())
     std::swap(Cmp0, Cmp1);
@@ -1799,6 +1910,9 @@ static Value *simplifyAndOrOfICmpsWithLi
 
 static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                  const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/true, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/true, Q))
@@ -1828,6 +1942,9 @@ static Value *simplifyAndOfICmps(ICmpIns
 
 static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                        const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) | (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1875,6 +1992,9 @@ static Value *simplifyOrOfICmpsWithAdd(I
 
 static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                 const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/false, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/false, Q))
@@ -1904,6 +2024,9 @@ static Value *simplifyOrOfICmps(ICmpInst
 
 static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
                                    FCmpInst *LHS, FCmpInst *RHS, bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);
   Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);
   if (LHS0->getType() != RHS0->getType())
@@ -1942,6 +2065,9 @@ static Value *simplifyAndOrOfFCmps(const
 
 static Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,
                                   Value *Op0, Value *Op1, bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look through casts of the 'and' operands to find compares.
   auto *Cast0 = dyn_cast<CastInst>(Op0);
   auto *Cast1 = dyn_cast<CastInst>(Op1);
@@ -1980,6 +2106,9 @@ static Value *simplifyAndOrOfCmps(const
 /// source value and inverted constant (identity: C - X -> ~(X + ~C)).
 static Value *simplifyLogicOfAddSub(Value *Op0, Value *Op1,
                                     Instruction::BinaryOps Opcode) {
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(Op0->getType() == Op1->getType() && "Mismatched binop types");
   assert(BinaryOperator::isBitwiseLogicOp(Opcode) && "Expected logic op");
   Value *X;
@@ -2007,6 +2136,9 @@ static Value *SimplifyAndInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::And, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X & poison -> poison
   if (isa<PoisonValue>(Op1))
     return Op1;
@@ -2179,6 +2311,9 @@ static Value *SimplifyOrInst(Value *Op0,
   if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X | poison -> poison
   if (isa<PoisonValue>(Op1))
     return Op1;
@@ -2359,6 +2494,9 @@ static Value *SimplifyXorInst(Value *Op0
   if (Constant *C = foldOrCommuteConstant(Instruction::Xor, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // A ^ undef -> undef
   if (Q.isUndefValue(Op1))
     return Op1;
@@ -2410,6 +2548,9 @@ static Type *GetCompareTy(Value *Op) {
 /// Helper function for analyzing max/min idioms.
 static Value *ExtractEquivalentCondition(Value *V, CmpInst::Predicate Pred,
                                          Value *LHS, Value *RHS) {
+  if (DisablePeepholes)
+    return nullptr;
+
   SelectInst *SI = dyn_cast<SelectInst>(V);
   if (!SI)
     return nullptr;
@@ -2456,6 +2597,9 @@ static Value *ExtractEquivalentCondition
 static Constant *
 computePointerICmp(CmpInst::Predicate Pred, Value *LHS, Value *RHS,
                    const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   const DataLayout &DL = Q.DL;
   const TargetLibraryInfo *TLI = Q.TLI;
   const DominatorTree *DT = Q.DT;
@@ -2646,6 +2790,9 @@ computePointerICmp(CmpInst::Predicate Pr
 /// Fold an icmp when its operands have i1 scalar type.
 static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Type *OpTy = LHS->getType();   // The operand type.
   if (!OpTy->isIntOrIntVectorTy(1))
@@ -2720,6 +2867,9 @@ static Value *simplifyICmpOfBools(CmpIns
 /// Try hard to fold icmp with zero RHS because this is a common case.
 static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
                                    Value *RHS, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!match(RHS, m_Zero()))
     return nullptr;
 
@@ -2782,6 +2932,9 @@ static Value *simplifyICmpWithZero(CmpIn
 
 static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
                                        Value *RHS, const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *X;
@@ -2831,6 +2984,9 @@ static Value *simplifyICmpWithConstant(C
 static Value *simplifyICmpWithBinOpOnLHS(
     CmpInst::Predicate Pred, BinaryOperator *LBO, Value *RHS,
     const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *Y = nullptr;
@@ -2975,6 +3131,9 @@ static bool trySimplifyICmpWithAdds(CmpI
 static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   BinaryOperator *LBO = dyn_cast<BinaryOperator>(LHS);
   BinaryOperator *RBO = dyn_cast<BinaryOperator>(RHS);
   if (MaxRecurse && (LBO || RBO)) {
@@ -3159,6 +3318,9 @@ static Value *simplifyICmpWithBinOp(CmpI
 static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
                                      Value *RHS, const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Value *A, *B;
   CmpInst::Predicate P = CmpInst::BAD_ICMP_PREDICATE;
@@ -3344,6 +3506,9 @@ static Value *simplifyICmpWithMinMax(Cmp
 static Value *simplifyICmpWithDominatingAssume(CmpInst::Predicate Predicate,
                                                Value *LHS, Value *RHS,
                                                const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Gracefully handle instructions that have not been inserted yet.
   if (!Q.AC || !Q.CxtI || !Q.CxtI->getParent())
     return nullptr;
@@ -3382,6 +3547,9 @@ static Value *SimplifyICmpInst(unsigned
   }
   assert(!isa<UndefValue>(LHS) && "Unexpected icmp undef,%X");
 
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
 
   // icmp poison, X -> poison
@@ -3696,11 +3864,17 @@ static Value *SimplifyFCmpInst(unsigned
     if (Constant *CRHS = dyn_cast<Constant>(RHS))
       return ConstantFoldCompareInstOperands(Pred, CLHS, CRHS, Q.DL, Q.TLI);
 
+    if (DisablePeepholes)
+      return nullptr;
+
     // If we have a constant, make sure it is on the RHS.
     std::swap(LHS, RHS);
     Pred = CmpInst::getSwappedPredicate(Pred);
   }
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Fold trivial predicates.
   Type *RetTy = GetCompareTy(LHS);
   if (Pred == FCmpInst::FCMP_FALSE)
@@ -3899,6 +4073,9 @@ static Value *simplifyWithOpReplaced(Val
                                      unsigned MaxRecurse) {
   assert(!Op->getType()->isVectorTy() && "This is not safe for vectors");
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Trivial replacement.
   if (V == Op)
     return RepOp;
@@ -4019,6 +4196,9 @@ Value *llvm::simplifyWithOpReplaced(Valu
 /// integer comparison where one operand of the compare is a constant.
 static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
                                     const APInt *Y, bool TrueWhenUnset) {
+  if (DisablePeepholes)
+    return nullptr;
+
   const APInt *C;
 
   // (X & Y) == 0 ? X & ~Y : X  --> X
@@ -4055,6 +4235,9 @@ static Value *simplifySelectBitTest(Valu
 static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
                                            ICmpInst::Predicate Pred,
                                            Value *TrueVal, Value *FalseVal) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   APInt Mask;
   if (!decomposeBitTestICmp(CmpLHS, CmpRHS, Pred, X, Mask))
@@ -4069,6 +4252,9 @@ static Value *simplifySelectWithFakeICmp
 static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
                                          Value *FalseVal, const SimplifyQuery &Q,
                                          unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *CmpLHS, *CmpRHS;
   if (!match(CondVal, m_ICmp(Pred, m_Value(CmpLHS), m_Value(CmpRHS))))
@@ -4172,6 +4358,9 @@ static Value *simplifySelectWithICmpCond
 /// floating-point comparison.
 static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
                                      const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   FCmpInst::Predicate Pred;
   if (!match(Cond, m_FCmp(Pred, m_Specific(T), m_Specific(F))) &&
       !match(Cond, m_FCmp(Pred, m_Specific(F), m_Specific(T))))
@@ -4203,6 +4392,9 @@ static Value *simplifySelectWithFCmp(Val
 /// If not, this returns null.
 static Value *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
                                  const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CondC = dyn_cast<Constant>(Cond)) {
     if (auto *TrueC = dyn_cast<Constant>(TrueVal))
       if (auto *FalseC = dyn_cast<Constant>(FalseVal))
@@ -4313,6 +4505,9 @@ Value *llvm::SimplifySelectInst(Value *C
 /// If not, this returns null.
 static Value *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
                               const SimplifyQuery &Q, unsigned) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // The type of the GEP pointer operand.
   unsigned AS =
       cast<PointerType>(Ops[0]->getType()->getScalarType())->getAddressSpace();
@@ -4445,6 +4640,9 @@ Value *llvm::SimplifyGEPInst(Type *SrcTy
 static Value *SimplifyInsertValueInst(Value *Agg, Value *Val,
                                       ArrayRef<unsigned> Idxs, const SimplifyQuery &Q,
                                       unsigned) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *CAgg = dyn_cast<Constant>(Agg))
     if (Constant *CVal = dyn_cast<Constant>(Val))
       return ConstantFoldInsertValueInstruction(CAgg, CVal, Idxs);
@@ -4484,6 +4682,9 @@ Value *llvm::SimplifyInsertElementInst(V
   if (VecC && ValC && IdxC)
     return ConstantExpr::getInsertElement(VecC, ValC, IdxC);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // For fixed-length vector, fold into poison if index is out of bounds.
   if (auto *CI = dyn_cast<ConstantInt>(Idx)) {
     if (isa<FixedVectorType>(Vec->getType()) &&
@@ -4517,6 +4718,9 @@ static Value *SimplifyExtractValueInst(V
   if (auto *CAgg = dyn_cast<Constant>(Agg))
     return ConstantFoldExtractValueInstruction(CAgg, Idxs);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // extractvalue x, (insertvalue y, elt, n), n -> elt
   unsigned NumIdxs = Idxs.size();
   for (auto *IVI = dyn_cast<InsertValueInst>(Agg); IVI != nullptr;
@@ -4549,10 +4753,16 @@ static Value *SimplifyExtractElementInst
     if (auto *CIdx = dyn_cast<Constant>(Idx))
       return ConstantExpr::getExtractElement(CVec, CIdx);
 
+    if (DisablePeepholes)
+      return nullptr;
+
     if (Q.isUndefValue(Vec))
       return UndefValue::get(VecVTy->getElementType());
   }
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // An undef extract index can be arbitrarily chosen to be an out-of-range
   // index value, which would result in the instruction being poison.
   if (Q.isUndefValue(Idx))
@@ -4587,6 +4797,8 @@ Value *llvm::SimplifyExtractElementInst(
 /// See if we can fold the given phi. If not, returns null.
 static Value *SimplifyPHINode(PHINode *PN, ArrayRef<Value *> IncomingValues,
                               const SimplifyQuery &Q) {
+  // JDR: can't disable this w/o breaking the compiler
+
   // WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE
   //          here, because the PHI we may succeed simplifying to was not
   //          def-reachable from the original PHI!
@@ -4627,6 +4839,9 @@ static Value *SimplifyCastInst(unsigned
   if (auto *C = dyn_cast<Constant>(Op))
     return ConstantFoldCastOperand(CastOpc, C, Ty, Q.DL);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CI = dyn_cast<CastInst>(Op)) {
     auto *Src = CI->getOperand(0);
     Type *SrcTy = Src->getType();
@@ -4667,6 +4882,9 @@ Value *llvm::SimplifyCastInst(unsigned C
 static Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,
                                    int MaskVal, Value *RootVec,
                                    unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!MaxRecurse--)
     return nullptr;
 
@@ -4716,6 +4934,9 @@ static Value *SimplifyShuffleVectorInst(
                                         ArrayRef<int> Mask, Type *RetTy,
                                         const SimplifyQuery &Q,
                                         unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (all_of(Mask, [](int Elem) { return Elem == UndefMaskElem; }))
     return UndefValue::get(RetTy);
 
@@ -4848,6 +5069,9 @@ static Value *simplifyFNegInst(Value *Op
   if (Constant *C = foldConstant(Instruction::FNeg, Op, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   // fneg (fneg X) ==> X
   if (match(Op, m_FNeg(m_Value(X))))
@@ -4862,6 +5086,9 @@ Value *llvm::SimplifyFNegInst(Value *Op,
 }
 
 static Constant *propagateNaN(Constant *In) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the input is a vector with undef elements, just return a default NaN.
   if (!In->isNaN())
     return ConstantFP::getNaN(In->getType());
@@ -4878,6 +5105,9 @@ static Constant *simplifyFPOp(ArrayRef<V
                               const SimplifyQuery &Q,
                               fp::ExceptionBehavior ExBehavior,
                               RoundingMode Rounding) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Poison is independent of anything else. It always propagates from an
   // operand to a math result.
   if (any_of(Ops, [](Value *V) { return match(V, m_Poison()); }))
@@ -4918,6 +5148,9 @@ SimplifyFAddInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FAdd, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -4972,6 +5205,9 @@ SimplifyFSubInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FSub, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5019,6 +5255,9 @@ static Value *SimplifyFMAFMul(Value *Op0
                               const SimplifyQuery &Q, unsigned MaxRecurse,
                               fp::ExceptionBehavior ExBehavior,
                               RoundingMode Rounding) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5063,6 +5302,9 @@ SimplifyFMulInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FMul, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Now apply simplifications that do not require rounding.
   return SimplifyFMAFMul(Op0, Op1, FMF, Q, MaxRecurse, ExBehavior, Rounding);
 }
@@ -5108,6 +5350,9 @@ SimplifyFDivInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FDiv, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5163,6 +5408,9 @@ SimplifyFRemInst(Value *Op0, Value *Op1,
     if (Constant *C = foldOrCommuteConstant(Instruction::FRem, Op0, Op1, Q))
       return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q, ExBehavior, Rounding))
     return C;
 
@@ -5198,6 +5446,9 @@ Value *llvm::SimplifyFRemInst(Value *Op0
 /// If not, this returns null.
 static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
                            unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FastMathFlags(), Q, MaxRecurse);
@@ -5212,6 +5463,9 @@ static Value *simplifyUnOp(unsigned Opco
 static Value *simplifyFPUnOp(unsigned Opcode, Value *Op,
                              const FastMathFlags &FMF,
                              const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FMF, Q, MaxRecurse);
@@ -5338,6 +5592,9 @@ static bool IsIdempotent(Intrinsic::ID I
 
 static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
                                    const DataLayout &DL) {
+  if (DisablePeepholes)
+    return nullptr;
+
   GlobalValue *PtrSym;
   APInt PtrOffset;
   if (!IsConstantOffsetFromGlobal(Ptr, PtrSym, PtrOffset, DL))
@@ -5394,6 +5651,9 @@ static Value *SimplifyRelativeLoad(Const
 
 static Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,
                                      const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Idempotent functions return the same result when called repeatedly.
   Intrinsic::ID IID = F->getIntrinsicID();
   if (IsIdempotent(IID))
@@ -5505,6 +5765,9 @@ static ICmpInst::Predicate getMaxMinPred
 /// operand that is another min/max intrinsic with shared operand(s). The caller
 /// is expected to swap the operand arguments to handle commutation.
 static Value *foldMinMaxSharedOp(Intrinsic::ID IID, Value *Op0, Value *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X, *Y;
   if (!match(Op0, m_MaxOrMin(m_Value(X), m_Value(Y))))
     return nullptr;
@@ -5528,6 +5791,9 @@ static Value *foldMinMaxSharedOp(Intrins
 
 static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
                                       const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Intrinsic::ID IID = F->getIntrinsicID();
   Type *ReturnType = F->getReturnType();
   unsigned BitWidth = ReturnType->getScalarSizeInBits();
@@ -5788,6 +6054,9 @@ static Value *simplifyBinaryIntrinsic(Fu
 
 static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Intrinsics with no operands have some kind of side effect. Don't simplify.
   unsigned NumOperands = Call->getNumArgOperands();
   if (!NumOperands)
@@ -5950,6 +6219,9 @@ static Value *simplifyIntrinsic(CallBase
 }
 
 static Value *tryConstantFoldCall(CallBase *Call, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+  
   auto *F = dyn_cast<Function>(Call->getCalledOperand());
   if (!F || !canConstantFoldCallTo(Call, F))
     return nullptr;
@@ -5995,6 +6267,9 @@ Value *llvm::SimplifyCall(CallBase *Call
 
 /// Given operands for a Freeze, see if we can fold the result.
 static Value *SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Use a utility function defined in ValueTracking.
   if (llvm::isGuaranteedNotToBeUndefOrPoison(Op0, Q.AC, Q.CxtI, Q.DT))
     return Op0;
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp work/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
--- work.orig/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp	2022-02-13 14:29:35.002420472 -0800
@@ -35,6 +35,8 @@
 using namespace llvm;
 using namespace PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "aggressive-instcombine"
 
 STATISTIC(NumAnyOrAllBitsSet, "Number of any/all-bits-set patterns folded");
@@ -415,6 +417,9 @@ void AggressiveInstCombinerLegacyPass::g
 }
 
 bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);
   auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
   return runImpl(F, TLI, DT);
@@ -422,6 +427,9 @@ bool AggressiveInstCombinerLegacyPass::r
 
 PreservedAnalyses AggressiveInstCombinePass::run(Function &F,
                                                  FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   if (!runImpl(F, TLI, DT)) {
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp work/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
--- work.orig/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp	2022-02-13 14:29:35.029421528 -0800
@@ -43,6 +43,8 @@
 #include <cassert>
 #include <utility>
 
+extern bool DisableWrongOptimizations;
+
 using namespace llvm;
 using namespace PatternMatch;
 
@@ -2660,6 +2662,7 @@ Instruction *InstCombinerImpl::visitSele
   // Avoid potential infinite loops by checking for non-constant condition.
   // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?
   //       Scalar select must have simplified?
+  if (!DisableWrongOptimizations) {
   if (SelType->isIntOrIntVectorTy(1) && !isa<Constant>(CondVal) &&
       TrueVal->getType() == CondVal->getType()) {
     // Folding select to and/or i1 isn't poison safe in general. impliesPoison
@@ -2836,6 +2839,7 @@ Instruction *InstCombinerImpl::visitSele
       return new SExtInst(NotCond, SelType);
     }
   }
+  } // fi !DisableWrongOptimizations
 
   if (auto *FCmp = dyn_cast<FCmpInst>(CondVal)) {
     Value *Cmp0 = FCmp->getOperand(0), *Cmp1 = FCmp->getOperand(1);
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp work/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
--- work.orig/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp	2022-02-13 14:29:35.049422312 -0800
@@ -112,6 +112,8 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "instcombine"
 
 STATISTIC(NumWorklistIterations,
@@ -4205,6 +4207,9 @@ InstCombinePass::InstCombinePass(unsigne
 
 PreservedAnalyses InstCombinePass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
@@ -4248,6 +4253,9 @@ void InstructionCombiningPass::getAnalys
 }
 
 bool InstructionCombiningPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   if (skipFunction(F))
     return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/DCE.cpp work/llvm/lib/Transforms/Scalar/DCE.cpp
--- work.orig/llvm/lib/Transforms/Scalar/DCE.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/Scalar/DCE.cpp	2022-02-13 14:29:35.086423760 -0800
@@ -18,7 +18,6 @@
 #include "llvm/Transforms/Scalar/DCE.h"
 #include "llvm/ADT/SetVector.h"
 #include "llvm/ADT/Statistic.h"
-#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/InstIterator.h"
 #include "llvm/IR/Instruction.h"
 #include "llvm/InitializePasses.h"
@@ -119,7 +118,7 @@ static bool DCEInstruction(Instruction *
   return false;
 }
 
-static bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
+bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
   bool MadeChange = false;
   SmallSetVector<Instruction *, 16> WorkList;
   // Iterate over the original function, only adding insts to the worklist
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/NaryReassociate.cpp work/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
--- work.orig/llvm/lib/Transforms/Scalar/NaryReassociate.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/Scalar/NaryReassociate.cpp	2022-02-13 14:29:35.104424464 -0800
@@ -116,6 +116,8 @@ using namespace PatternMatch;
 
 #define DEBUG_TYPE "nary-reassociate"
 
+extern bool DisablePeepholes;
+
 namespace {
 
 class NaryReassociateLegacyPass : public FunctionPass {
@@ -167,6 +169,9 @@ FunctionPass *llvm::createNaryReassociat
 }
 
 bool NaryReassociateLegacyPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   if (skipFunction(F))
     return false;
 
@@ -181,6 +186,9 @@ bool NaryReassociateLegacyPass::runOnFun
 
 PreservedAnalyses NaryReassociatePass::run(Function &F,
                                            FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto *AC = &AM.getResult<AssumptionAnalysis>(F);
   auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   auto *SE = &AM.getResult<ScalarEvolutionAnalysis>(F);
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/Reassociate.cpp work/llvm/lib/Transforms/Scalar/Reassociate.cpp
--- work.orig/llvm/lib/Transforms/Scalar/Reassociate.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/Scalar/Reassociate.cpp	2022-02-13 14:29:35.118425013 -0800
@@ -86,6 +86,8 @@ static void PrintOps(Instruction *I, con
 }
 #endif
 
+extern bool DisablePeepholes;
+
 /// Utility class representing a non-constant Xor-operand. We classify
 /// non-constant Xor-Operands into two categories:
 ///  C1) The operand is in the form "X & C", where C is a constant and C != ~0
@@ -2497,6 +2499,9 @@ ReassociatePass::BuildPairMap(ReversePos
 }
 
 PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   // Get the functions basic blocks in Reverse Post Order. This order is used by
   // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic
   // blocks (it has been seen that the analysis in this pass could hang when
@@ -2587,6 +2592,9 @@ namespace {
     }
 
     bool runOnFunction(Function &F) override {
+      if (DisablePeepholes)
+        return false;
+
       if (skipFunction(F))
         return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp work/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
--- work.orig/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp	2022-02-13 14:29:35.134425639 -0800
@@ -61,6 +61,8 @@
 #include <numeric>
 #include <utility>
 
+extern bool DisableWrongOptimizations;
+
 #define DEBUG_TYPE "simple-loop-unswitch"
 
 using namespace llvm;
@@ -3055,6 +3057,11 @@ unswitchLoop(Loop &L, DominatorTree &DT,
 PreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &U) {
+  if (DisableWrongOptimizations) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
+
   Function &F = *L.getHeader()->getParent();
   (void)F;
 
@@ -3151,6 +3158,9 @@ public:
 } // end anonymous namespace
 
 bool SimpleLoopUnswitchLegacyPass::runOnLoop(Loop *L, LPPassManager &LPM) {
+  if (DisableWrongOptimizations)
+    return false;
+
   if (skipLoop(L))
     return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp work/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
--- work.orig/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp	2022-02-13 14:29:35.148426187 -0800
@@ -51,6 +51,8 @@ using namespace llvm;
 
 #define DEBUG_TYPE "simplifycfg"
 
+extern bool DisablePeepholes;
+
 static cl::opt<unsigned> UserBonusInstThreshold(
     "bonus-inst-threshold", cl::Hidden, cl::init(1),
     cl::desc("Control the number of bonus instructions (default = 1)"));
@@ -321,6 +323,11 @@ SimplifyCFGPass::SimplifyCFGPass(const S
 
 PreservedAnalyses SimplifyCFGPass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisablePeepholes) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
+
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   Options.AC = &AM.getResult<AssumptionAnalysis>(F);
   DominatorTree *DT = nullptr;
@@ -356,6 +363,9 @@ struct CFGSimplifyPass : public Function
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePeepholes)
+      return false;
+
     if (skipFunction(F) || (PredicateFtor && !PredicateFtor(F)))
       return false;
 
diff -x '*.orig' -x '*.rej' -urpN work.orig/llvm/lib/Transforms/Vectorize/VectorCombine.cpp work/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
--- work.orig/llvm/lib/Transforms/Vectorize/VectorCombine.cpp	2022-01-20 13:31:59.000000000 -0800
+++ work/llvm/lib/Transforms/Vectorize/VectorCombine.cpp	2022-02-13 14:29:35.156426500 -0800
@@ -31,6 +31,8 @@
 #include "llvm/Transforms/Utils/Local.h"
 #include "llvm/Transforms/Vectorize.h"
 
+extern bool DisablePeepholes;
+
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
@@ -1008,6 +1010,9 @@ public:
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePeepholes)
+      return false;
+
     if (skipFunction(F))
       return false;
     auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);
