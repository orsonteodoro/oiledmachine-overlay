The header license of many of these files:

// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

Obtained from:
https://github.com/regehr/llvm-project/compare/b5769a777f1c146e5457200fe52fa2041e182da4...disable-peepholes-v03.diff

Commit history:
https://github.com/regehr/llvm-project/compare/b5769a777f1c146e5457200fe52fa2041e182da4...disable-peepholes-v03

oteodoro notes:
Patch for LLVM 11
Removed benchmark script test-spec.sh and default.cfg
Removed test-disable-peepholes.sh

From 1a22c90bb997d1b706da3f08c3e6d62fd62a2111 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:05:57 -0700
Subject: [PATCH 01/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp             | 11 +++++++++++
 .../Transforms/InstCombine/InstructionCombining.cpp   |  2 ++
 2 files changed, 13 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 7942cb09e84c9..6bd4b8bc1b1b2 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -71,6 +71,8 @@ static Value *SimplifyGEPInst(Type *, ArrayRef<Value *>, const SimplifyQuery &,
 
 static Value *foldSelectWithBinaryOp(Value *Cond, Value *TrueVal,
                                      Value *FalseVal) {
+  return nullptr;
+  
   BinaryOperator::BinaryOps BinOpCode;
   if (auto *BO = dyn_cast<BinaryOperator>(Cond))
     BinOpCode = BO->getOpcode();
@@ -126,6 +128,7 @@ static Constant *getTrue(Type *Ty) {
 /// isSameCompare - Is V equivalent to the comparison "LHS Pred RHS"?
 static bool isSameCompare(Value *V, CmpInst::Predicate Pred, Value *LHS,
                           Value *RHS) {
+  return false;
   CmpInst *Cmp = dyn_cast<CmpInst>(V);
   if (!Cmp)
     return false;
@@ -139,6 +142,7 @@ static bool isSameCompare(Value *V, CmpInst::Predicate Pred, Value *LHS,
 
 /// Does the given value dominate the specified phi node?
 static bool valueDominatesPHI(Value *V, PHINode *P, const DominatorTree *DT) {
+  return false;
   Instruction *I = dyn_cast<Instruction>(V);
   if (!I)
     // Arguments and constants dominate all instructions.
@@ -171,6 +175,7 @@ static bool valueDominatesPHI(Value *V, PHINode *P, const DominatorTree *DT) {
 static Value *ExpandBinOp(Instruction::BinaryOps Opcode, Value *LHS, Value *RHS,
                           Instruction::BinaryOps OpcodeToExpand,
                           const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -230,6 +235,7 @@ static Value *SimplifyAssociativeBinOp(Instruction::BinaryOps Opcode,
                                        Value *LHS, Value *RHS,
                                        const SimplifyQuery &Q,
                                        unsigned MaxRecurse) {
+  return nullptr;
   assert(Instruction::isAssociative(Opcode) && "Not an associative operation!");
 
   // Recursion is always used, so bail out at once if we already hit the limit.
@@ -329,6 +335,7 @@ static Value *SimplifyAssociativeBinOp(Instruction::BinaryOps Opcode,
 static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  return nullptr;
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -401,6 +408,7 @@ static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
 static Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q,
                                   unsigned MaxRecurse) {
+  return nullptr;
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -525,6 +533,7 @@ static Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,
 /// otherwise returns null.
 static Value *ThreadCmpOverPHI(CmpInst::Predicate Pred, Value *LHS, Value *RHS,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -564,6 +573,7 @@ static Constant *foldOrCommuteConstant(Instruction::BinaryOps Opcode,
     if (auto *CRHS = dyn_cast<Constant>(Op1))
       return ConstantFoldBinaryOpOperands(Opcode, CLHS, CRHS, Q.DL);
 
+    return nullptr;
     // Canonicalize the constant to the RHS if this is a commutative operation.
     if (Instruction::isCommutative(Opcode))
       std::swap(Op0, Op1);
@@ -575,6 +585,7 @@ static Constant *foldOrCommuteConstant(Instruction::BinaryOps Opcode,
 /// If not, this returns null.
 static Value *SimplifyAddInst(Value *Op0, Value *Op1, bool IsNSW, bool IsNUW,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
   if (Constant *C = foldOrCommuteConstant(Instruction::Add, Op0, Op1, Q))
     return C;
 
diff --git a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
index 5383da8fd869d..0da10abac82e3 100644
--- a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
@@ -3626,6 +3626,8 @@ void InstructionCombiningPass::getAnalysisUsage(AnalysisUsage &AU) const {
 }
 
 bool InstructionCombiningPass::runOnFunction(Function &F) {
+  return false;
+
   if (skipFunction(F))
     return false;
 

From ea624fb0036f687206cb2e2a7e224d79193e7f15 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:11:27 -0700
Subject: [PATCH 02/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 6bd4b8bc1b1b2..af387777be39f 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -687,6 +687,7 @@ static Constant *stripAndComputeConstantOffsets(const DataLayout &DL, Value *&V,
 /// If the difference is not a constant, returns zero.
 static Constant *computePointerDifference(const DataLayout &DL, Value *LHS,
                                           Value *RHS) {
+  return nullptr;
   Constant *LHSOffset = stripAndComputeConstantOffsets(DL, LHS);
   Constant *RHSOffset = stripAndComputeConstantOffsets(DL, RHS);
 
@@ -709,6 +710,8 @@ static Value *SimplifySubInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
   if (Constant *C = foldOrCommuteConstant(Instruction::Sub, Op0, Op1, Q))
     return C;
 
+  return nullptr;
+  
   // X - undef -> undef
   // undef - X -> undef
   if (match(Op0, m_Undef()) || match(Op1, m_Undef()))
@@ -844,6 +847,8 @@ static Value *SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::Mul, Op0, Op1, Q))
     return C;
 
+  return nullptr;
+  
   // X * undef -> 0
   // X * 0 -> 0
   if (match(Op1, m_CombineOr(m_Undef(), m_Zero())))
@@ -900,6 +905,8 @@ Value *llvm::SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// Check for common or similar folds of integer division or integer remainder.
 /// This applies to all 4 opcodes (sdiv/udiv/srem/urem).
 static Value *simplifyDivRem(Value *Op0, Value *Op1, bool IsDiv) {
+  return nullptr;
+  
   Type *Ty = Op0->getType();
 
   // X / undef -> undef
@@ -967,6 +974,8 @@ static bool isICmpTrue(ICmpInst::Predicate Pred, Value *LHS, Value *RHS,
 /// to simplify X % Y to X.
 static bool isDivZero(Value *X, Value *Y, const SimplifyQuery &Q,
                       unsigned MaxRecurse, bool IsSigned) {
+  return false;
+  
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return false;

From 620ab7f30116bd0613c15211db1477cf163791d0 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:31:41 -0700
Subject: [PATCH 03/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 29 +++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index af387777be39f..a55a614ef5ab7 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -1030,6 +1030,8 @@ static Value *simplifyDiv(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  return nullptr;
+  
   if (Value *V = simplifyDivRem(Op0, Op1, true))
     return V;
 
@@ -1088,6 +1090,8 @@ static Value *simplifyRem(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  return nullptr;
+  
   if (Value *V = simplifyDivRem(Op0, Op1, false))
     return V;
 
@@ -1129,6 +1133,7 @@ static Value *simplifyRem(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
 /// If not, this returns null.
 static Value *SimplifySDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  return nullptr;
   // If two operands are negated and no signed overflow, return -1.
   if (isKnownNegation(Op0, Op1, /*NeedNSW=*/true))
     return Constant::getAllOnesValue(Op0->getType());
@@ -1155,6 +1160,7 @@ Value *llvm::SimplifyUDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// If not, this returns null.
 static Value *SimplifySRemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  return nullptr;
   // If the divisor is 0, the result is undefined, so assume the divisor is -1.
   // srem Op0, (sext i1 X) --> srem Op0, -1 --> 0
   Value *X;
@@ -1217,6 +1223,8 @@ static Value *SimplifyShift(Instruction::BinaryOps Opcode, Value *Op0,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  return nullptr;
+  
   // 0 shift by X -> 0
   if (match(Op0, m_Zero()))
     return Constant::getNullValue(Op0->getType());
@@ -1265,6 +1273,8 @@ static Value *SimplifyShift(Instruction::BinaryOps Opcode, Value *Op0,
 static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
                                  Value *Op1, bool isExact, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  return nullptr;
+  
   if (Value *V = SimplifyShift(Opcode, Op0, Op1, Q, MaxRecurse))
     return V;
 
@@ -1291,6 +1301,8 @@ static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
 /// If not, this returns null.
 static Value *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
+  
   if (Value *V = SimplifyShift(Instruction::Shl, Op0, Op1, Q, MaxRecurse))
     return V;
 
@@ -1323,6 +1335,8 @@ Value *llvm::SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
 /// If not, this returns null.
 static Value *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
+  
   if (Value *V = SimplifyRightShift(Instruction::LShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
       return V;
@@ -1361,6 +1375,8 @@ Value *llvm::SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
 /// If not, this returns null.
 static Value *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
+  
   if (Value *V = SimplifyRightShift(Instruction::AShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
     return V;
@@ -1393,6 +1409,8 @@ Value *llvm::SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
 static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
                                          ICmpInst *UnsignedICmp, bool IsAnd,
                                          const SimplifyQuery &Q) {
+  return nullptr;
+  
   Value *X, *Y;
 
   ICmpInst::Predicate EqPred;
@@ -1502,6 +1520,7 @@ static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  return nullptr;
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1527,6 +1546,7 @@ static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  return nullptr;
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1555,6 +1575,7 @@ static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
 /// the other.
 static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                 bool IsAnd) {
+  return nullptr;
   // Look for this pattern: {and/or} (icmp X, C0), (icmp X, C1)).
   if (Cmp0->getOperand(0) != Cmp1->getOperand(0))
     return nullptr;
@@ -1592,6 +1613,7 @@ static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
 
 static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                            bool IsAnd) {
+  return nullptr;
   ICmpInst::Predicate P0 = Cmp0->getPredicate(), P1 = Cmp1->getPredicate();
   if (!match(Cmp0->getOperand(1), m_Zero()) ||
       !match(Cmp1->getOperand(1), m_Zero()) || P0 != P1)
@@ -1629,6 +1651,7 @@ static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
 
 static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                         const InstrInfoQuery &IIQ) {
+  return nullptr;
   // (icmp (add V, C0), C1) & (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1676,6 +1699,7 @@ static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                  const SimplifyQuery &Q) {
+  return nullptr;
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/true, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/true, Q))
@@ -1702,6 +1726,7 @@ static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                        const InstrInfoQuery &IIQ) {
+  return nullptr;
   // (icmp (add V, C0), C1) | (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1749,6 +1774,7 @@ static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                 const SimplifyQuery &Q) {
+  return nullptr;
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/false, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/false, Q))
@@ -1775,6 +1801,7 @@ static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
                                    FCmpInst *LHS, FCmpInst *RHS, bool IsAnd) {
+  return nullptr;
   Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);
   Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);
   if (LHS0->getType() != RHS0->getType())
@@ -1813,6 +1840,7 @@ static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
 
 static Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,
                                   Value *Op0, Value *Op1, bool IsAnd) {
+  return nullptr;
   // Look through casts of the 'and' operands to find compares.
   auto *Cast0 = dyn_cast<CastInst>(Op0);
   auto *Cast1 = dyn_cast<CastInst>(Op1);
@@ -1852,6 +1880,7 @@ static Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,
 ///   %Op1 = extractvalue { i4, i1 } %Agg, 1
 static bool omitCheckForZeroBeforeMulWithOverflowInternal(Value *Op1,
                                                           Value *X) {
+  return false;
   auto *Extract = dyn_cast<ExtractValueInst>(Op1);
   // We should only be extracting the overflow bit.
   if (!Extract || !Extract->getIndices().equals(1))

From e055cfd1690155dd5f72a6c790fd52b100db8ef7 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:34:48 -0700
Subject: [PATCH 04/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index a55a614ef5ab7..9ba4185df97e2 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -1907,6 +1907,7 @@ static bool omitCheckForZeroBeforeMulWithOverflowInternal(Value *Op1,
 ///   %??? = and i1 %Op0, %Op1
 /// We can just return  %Op1
 static Value *omitCheckForZeroBeforeMulWithOverflow(Value *Op0, Value *Op1) {
+  return nullptr;
   ICmpInst::Predicate Pred;
   Value *X;
   if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||
@@ -1931,6 +1932,7 @@ static Value *omitCheckForZeroBeforeMulWithOverflow(Value *Op0, Value *Op1) {
 /// We can just return  %NotOp1
 static Value *omitCheckForZeroBeforeInvertedMulWithOverflow(Value *Op0,
                                                             Value *NotOp1) {
+  return nullptr;
   ICmpInst::Predicate Pred;
   Value *X;
   if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||
@@ -1954,6 +1956,8 @@ static Value *SimplifyAndInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::And, Op0, Op1, Q))
     return C;
 
+  return nullptr;
+  
   // X & undef -> 0
   if (match(Op1, m_Undef()))
     return Constant::getNullValue(Op0->getType());
@@ -2110,6 +2114,8 @@ static Value *SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))
     return C;
 
+  return nullptr;
+  
   // X | undef -> -1
   // X | -1 = -1
   // Do not return Op1 because it may contain undef elements if it's a vector.
@@ -2251,6 +2257,7 @@ Value *llvm::SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// If not, this returns null.
 static Value *SimplifyXorInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                               unsigned MaxRecurse) {
+  return nullptr;
   if (Constant *C = foldOrCommuteConstant(Instruction::Xor, Op0, Op1, Q))
     return C;
 
@@ -2302,6 +2309,7 @@ static Type *GetCompareTy(Value *Op) {
 /// Helper function for analyzing max/min idioms.
 static Value *ExtractEquivalentCondition(Value *V, CmpInst::Predicate Pred,
                                          Value *LHS, Value *RHS) {
+  return nullptr;
   SelectInst *SI = dyn_cast<SelectInst>(V);
   if (!SI)
     return nullptr;
@@ -2350,6 +2358,7 @@ computePointerICmp(const DataLayout &DL, const TargetLibraryInfo *TLI,
                    const DominatorTree *DT, CmpInst::Predicate Pred,
                    AssumptionCache *AC, const Instruction *CxtI,
                    const InstrInfoQuery &IIQ, Value *LHS, Value *RHS) {
+  return nullptr;
   // First, skip past any trivial no-ops.
   LHS = LHS->stripPointerCasts();
   RHS = RHS->stripPointerCasts();
@@ -2535,6 +2544,7 @@ computePointerICmp(const DataLayout &DL, const TargetLibraryInfo *TLI,
 /// Fold an icmp when its operands have i1 scalar type.
 static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q) {
+  return nullptr;
   Type *ITy = GetCompareTy(LHS); // The return type.
   Type *OpTy = LHS->getType();   // The operand type.
   if (!OpTy->isIntOrIntVectorTy(1))
@@ -2609,6 +2619,7 @@ static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
 /// Try hard to fold icmp with zero RHS because this is a common case.
 static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
                                    Value *RHS, const SimplifyQuery &Q) {
+  return nullptr;
   if (!match(RHS, m_Zero()))
     return nullptr;
 
@@ -2671,6 +2682,7 @@ static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
 
 static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
                                        Value *RHS, const InstrInfoQuery &IIQ) {
+  return nullptr;
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *X;
@@ -2713,6 +2725,7 @@ static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  return nullptr;
   Type *ITy = GetCompareTy(LHS); // The return type.
 
   BinaryOperator *LBO = dyn_cast<BinaryOperator>(LHS);

From 5335ccb0b3a675c483d21f640751102d0f68e11d Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:37:42 -0700
Subject: [PATCH 05/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 9ba4185df97e2..745c5e6f89564 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -3040,6 +3040,7 @@ static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
                                      Value *RHS, const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
+  return nullptr;
   Type *ITy = GetCompareTy(LHS); // The return type.
   Value *A, *B;
   CmpInst::Predicate P = CmpInst::BAD_ICMP_PREDICATE;
@@ -3243,6 +3244,7 @@ static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
 /// If not, this returns null.
 static Value *SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
   CmpInst::Predicate Pred = (CmpInst::Predicate)Predicate;
   assert(CmpInst::isIntPredicate(Pred) && "Not an integer compare!");
 
@@ -3545,11 +3547,13 @@ static Value *SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,
     if (Constant *CRHS = dyn_cast<Constant>(RHS))
       return ConstantFoldCompareInstOperands(Pred, CLHS, CRHS, Q.DL, Q.TLI);
 
+  return nullptr;
     // If we have a constant, make sure it is on the RHS.
     std::swap(LHS, RHS);
     Pred = CmpInst::getSwappedPredicate(Pred);
   }
 
+  return nullptr;
   // Fold trivial predicates.
   Type *RetTy = GetCompareTy(LHS);
   if (Pred == FCmpInst::FCMP_FALSE)
@@ -3726,6 +3730,7 @@ Value *llvm::SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,
 static const Value *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,
                                            const SimplifyQuery &Q,
                                            unsigned MaxRecurse) {
+  return nullptr;
   // Trivial replacement.
   if (V == Op)
     return RepOp;
@@ -3825,6 +3830,7 @@ static const Value *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,
 /// integer comparison where one operand of the compare is a constant.
 static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
                                     const APInt *Y, bool TrueWhenUnset) {
+  return nullptr;
   const APInt *C;
 
   // (X & Y) == 0 ? X & ~Y : X  --> X
@@ -3861,6 +3867,7 @@ static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
 static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
                                            ICmpInst::Predicate Pred,
                                            Value *TrueVal, Value *FalseVal) {
+  return nullptr;
   Value *X;
   APInt Mask;
   if (!decomposeBitTestICmp(CmpLHS, CmpRHS, Pred, X, Mask))
@@ -3875,6 +3882,7 @@ static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
 static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
                                          Value *FalseVal, const SimplifyQuery &Q,
                                          unsigned MaxRecurse) {
+  return nullptr;
   ICmpInst::Predicate Pred;
   Value *CmpLHS, *CmpRHS;
   if (!match(CondVal, m_ICmp(Pred, m_Value(CmpLHS), m_Value(CmpRHS))))
@@ -3967,6 +3975,7 @@ static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
 /// floating-point comparison.
 static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
                                      const SimplifyQuery &Q) {
+  return nullptr;
   FCmpInst::Predicate Pred;
   if (!match(Cond, m_FCmp(Pred, m_Specific(T), m_Specific(F))) &&
       !match(Cond, m_FCmp(Pred, m_Specific(F), m_Specific(T))))
@@ -3998,6 +4007,7 @@ static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
 /// If not, this returns null.
 static Value *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
                                  const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
   if (auto *CondC = dyn_cast<Constant>(Cond)) {
     if (auto *TrueC = dyn_cast<Constant>(TrueVal))
       if (auto *FalseC = dyn_cast<Constant>(FalseVal))
@@ -4052,6 +4062,7 @@ Value *llvm::SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
 /// If not, this returns null.
 static Value *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
                               const SimplifyQuery &Q, unsigned) {
+  return nullptr;
   // The type of the GEP pointer operand.
   unsigned AS =
       cast<PointerType>(Ops[0]->getType()->getScalarType())->getAddressSpace();
@@ -4172,6 +4183,7 @@ Value *llvm::SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
 static Value *SimplifyInsertValueInst(Value *Agg, Value *Val,
                                       ArrayRef<unsigned> Idxs, const SimplifyQuery &Q,
                                       unsigned) {
+  return nullptr;
   if (Constant *CAgg = dyn_cast<Constant>(Agg))
     if (Constant *CVal = dyn_cast<Constant>(Val))
       return ConstantFoldInsertValueInstruction(CAgg, CVal, Idxs);
@@ -4211,6 +4223,8 @@ Value *llvm::SimplifyInsertElementInst(Value *Vec, Value *Val, Value *Idx,
   if (VecC && ValC && IdxC)
     return ConstantFoldInsertElementInstruction(VecC, ValC, IdxC);
 
+  return nullptr;
+
   // Fold into undef if index is out of bounds.
   if (auto *CI = dyn_cast<ConstantInt>(Idx)) {
     uint64_t NumElements = cast<VectorType>(Vec->getType())->getNumElements();
@@ -4243,6 +4257,7 @@ static Value *SimplifyExtractValueInst(Value *Agg, ArrayRef<unsigned> Idxs,
   if (auto *CAgg = dyn_cast<Constant>(Agg))
     return ConstantFoldExtractValueInstruction(CAgg, Idxs);
 
+  return nullptr;
   // extractvalue x, (insertvalue y, elt, n), n -> elt
   unsigned NumIdxs = Idxs.size();
   for (auto *IVI = dyn_cast<InsertValueInst>(Agg); IVI != nullptr;
@@ -4274,6 +4289,7 @@ static Value *SimplifyExtractElementInst(Value *Vec, Value *Idx, const SimplifyQ
     if (auto *CIdx = dyn_cast<Constant>(Idx))
       return ConstantFoldExtractElementInstruction(CVec, CIdx);
 
+    return nullptr;
     // The index is not relevant if our vector is a splat.
     if (auto *Splat = CVec->getSplatValue())
       return Splat;
@@ -4282,6 +4298,7 @@ static Value *SimplifyExtractElementInst(Value *Vec, Value *Idx, const SimplifyQ
       return UndefValue::get(Vec->getType()->getVectorElementType());
   }
 
+  return nullptr;
   // If extracting a specified index from the vector, see if we can recursively
   // find a previously computed scalar that was inserted into the vector.
   if (auto *IdxC = dyn_cast<ConstantInt>(Idx)) {

From 27a53cf2abaf35ae2040406efafa8cbe67b749c9 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:47:44 -0700
Subject: [PATCH 06/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 745c5e6f89564..f56b397fd9e08 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -4360,6 +4360,7 @@ static Value *SimplifyCastInst(unsigned CastOpc, Value *Op,
   if (auto *C = dyn_cast<Constant>(Op))
     return ConstantFoldCastOperand(CastOpc, C, Ty, Q.DL);
 
+  return nullptr;
   if (auto *CI = dyn_cast<CastInst>(Op)) {
     auto *Src = CI->getOperand(0);
     Type *SrcTy = Src->getType();
@@ -4400,6 +4401,7 @@ Value *llvm::SimplifyCastInst(unsigned CastOpc, Value *Op, Type *Ty,
 static Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,
                                    int MaskVal, Value *RootVec,
                                    unsigned MaxRecurse) {
+  return nullptr;
   if (!MaxRecurse--)
     return nullptr;
 
@@ -4448,6 +4450,7 @@ static Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,
 static Value *SimplifyShuffleVectorInst(Value *Op0, Value *Op1, Constant *Mask,
                                         Type *RetTy, const SimplifyQuery &Q,
                                         unsigned MaxRecurse) {
+  return nullptr;
   if (isa<UndefValue>(Mask))
     return UndefValue::get(RetTy);
 
@@ -4541,6 +4544,7 @@ static Value *simplifyFNegInst(Value *Op, FastMathFlags FMF,
   if (Constant *C = foldConstant(Instruction::FNeg, Op, Q))
     return C;
 
+  return nullptr;
   Value *X;
   // fneg (fneg X) ==> X
   if (match(Op, m_FNeg(m_Value(X))))
@@ -4556,6 +4560,7 @@ Value *llvm::SimplifyFNegInst(Value *Op, FastMathFlags FMF,
 
 static Constant *propagateNaN(Constant *In) {
   // If the input is a vector with undef elements, just return a default NaN.
+  return nullptr;
   if (!In->isNaN())
     return ConstantFP::getNaN(In->getType());
 
@@ -4568,6 +4573,7 @@ static Constant *propagateNaN(Constant *In) {
 /// transforms based on undef/NaN because the operation itself makes no
 /// difference to the result.
 static Constant *simplifyFPOp(ArrayRef<Value *> Ops) {
+  return nullptr;
   if (any_of(Ops, [](Value *V) { return isa<UndefValue>(V); }))
     return ConstantFP::getNaN(Ops[0]->getType());
 
@@ -4585,6 +4591,7 @@ static Value *SimplifyFAddInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FAdd, Op0, Op1, Q))
     return C;
 
+  return nullptr;
   if (Constant *C = simplifyFPOp({Op0, Op1}))
     return C;
 

From 6486aefa0d9a29254417b41412cbd8e5004ce385 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:50:09 -0700
Subject: [PATCH 07/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index f56b397fd9e08..ca82bee69aab5 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -4639,6 +4639,7 @@ static Value *SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FSub, Op0, Op1, Q))
     return C;
 
+  return nullptr;
   if (Constant *C = simplifyFPOp({Op0, Op1}))
     return C;
 
@@ -4681,6 +4682,7 @@ static Value *SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,
 
 static Value *SimplifyFMAFMul(Value *Op0, Value *Op1, FastMathFlags FMF,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
   if (Constant *C = simplifyFPOp({Op0, Op1}))
     return C;
 
@@ -4717,6 +4719,7 @@ static Value *SimplifyFMulInst(Value *Op0, Value *Op1, FastMathFlags FMF,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
   if (Constant *C = foldOrCommuteConstant(Instruction::FMul, Op0, Op1, Q))
     return C;
+  return nullptr;
 
   // Now apply simplifications that do not require rounding.
   return SimplifyFMAFMul(Op0, Op1, FMF, Q, MaxRecurse);
@@ -4748,6 +4751,7 @@ static Value *SimplifyFDivInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FDiv, Op0, Op1, Q))
     return C;
 
+  return nullptr;
   if (Constant *C = simplifyFPOp({Op0, Op1}))
     return C;
 
@@ -4793,6 +4797,7 @@ static Value *SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FRem, Op0, Op1, Q))
     return C;
 
+  return nullptr;
   if (Constant *C = simplifyFPOp({Op0, Op1}))
     return C;
 
@@ -4822,6 +4827,7 @@ Value *llvm::SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,
 /// If not, this returns null.
 static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
                            unsigned MaxRecurse) {
+  return nullptr;
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FastMathFlags(), Q, MaxRecurse);
@@ -4836,6 +4842,7 @@ static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
 static Value *simplifyFPUnOp(unsigned Opcode, Value *Op,
                              const FastMathFlags &FMF,
                              const SimplifyQuery &Q, unsigned MaxRecurse) {
+  return nullptr;
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FMF, Q, MaxRecurse);

From 5b433ea657f43534d8a88de54d7ec4a13522867e Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 5 Dec 2019 21:52:37 -0700
Subject: [PATCH 08/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index ca82bee69aab5..85766399b324e 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -4324,6 +4324,9 @@ Value *llvm::SimplifyExtractElementInst(Value *Vec, Value *Idx,
 
 /// See if we can fold the given phi. If not, returns null.
 static Value *SimplifyPHINode(PHINode *PN, const SimplifyQuery &Q) {
+
+  // JDR: can't disable this w/o breaking the compiler
+  
   // If all of the PHI's incoming values are the same then replace the PHI node
   // with the common value.
   Value *CommonValue = nullptr;
@@ -4968,6 +4971,7 @@ static bool IsIdempotent(Intrinsic::ID ID) {
 
 static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
                                    const DataLayout &DL) {
+  return nullptr;
   GlobalValue *PtrSym;
   APInt PtrOffset;
   if (!IsConstantOffsetFromGlobal(Ptr, PtrSym, PtrOffset, DL))
@@ -5024,6 +5028,7 @@ static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
 
 static Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,
                                      const SimplifyQuery &Q) {
+  return nullptr;
   // Idempotent functions return the same result when called repeatedly.
   Intrinsic::ID IID = F->getIntrinsicID();
   if (IsIdempotent(IID))
@@ -5097,6 +5102,7 @@ static Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,
 
 static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
                                       const SimplifyQuery &Q) {
+  return nullptr;
   Intrinsic::ID IID = F->getIntrinsicID();
   Type *ReturnType = F->getReturnType();
   switch (IID) {
@@ -5240,6 +5246,7 @@ static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
 
 static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 
+  return nullptr;
   // Intrinsics with no operands have some kind of side effect. Don't simplify.
   unsigned NumOperands = Call->getNumArgOperands();
   if (!NumOperands)
@@ -5302,6 +5309,7 @@ static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 }
 
 Value *llvm::SimplifyCall(CallBase *Call, const SimplifyQuery &Q) {
+  return nullptr;
   Value *Callee = Call->getCalledValue();
 
   // call undef -> undef
@@ -5335,6 +5343,7 @@ Value *llvm::SimplifyCall(CallBase *Call, const SimplifyQuery &Q) {
 
 /// Given operands for a Freeze, see if we can fold the result.
 static Value *SimplifyFreezeInst(Value *Op0) {
+  return nullptr;
   // Use a utility function defined in ValueTracking.
   if (llvm::isGuaranteedNotToBeUndefOrPoison(Op0))
     return Op0;

From 46700449d12b33a266a575afd2253fda045fc78e Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Tue, 21 Jan 2020 13:00:45 -0700
Subject: [PATCH 09/48] foo

---
 .../Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp  | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
index 59b94567a9c24..c025fc331d688 100644
--- a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
+++ b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
@@ -370,6 +370,7 @@ void AggressiveInstCombinerLegacyPass::getAnalysisUsage(
 }
 
 bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
+  return false;
   auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);
   auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
   return runImpl(F, TLI, DT);
@@ -377,6 +378,7 @@ bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
 
 PreservedAnalyses AggressiveInstCombinePass::run(Function &F,
                                                  FunctionAnalysisManager &AM) {
+  return PreservedAnalyses::all();
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   if (!runImpl(F, TLI, DT)) {

From da34384f27ac01bee147a3f779b65f60fa716d1e Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 27 Feb 2020 19:25:23 -0700
Subject: [PATCH 10/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp       | 4 ++++
 llvm/lib/Transforms/Vectorize/VectorCombine.cpp | 4 ++++
 2 files changed, 8 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 725cf96a11262..7261c9959dcee 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -43,6 +43,10 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+cl::opt<bool> DisablePeepholes(
+    "disable-peepholes", cl::init(false),
+    cl::desc("Don't run peephole passes."));
+
 #define DEBUG_TYPE "instsimplify"
 
 enum { RecursionLimit = 3 };
diff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
index 76c63dd238509..555d030632abd 100644
--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
@@ -27,6 +27,8 @@
 #include "llvm/Transforms/Vectorize.h"
 #include "llvm/Transforms/Utils/Local.h"
 
+extern bool DisablePeepholes;
+
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
@@ -225,6 +227,8 @@ class VectorCombineLegacyPass : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePeepholes)
+      return false;
     if (skipFunction(F))
       return false;
     auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);

From b6459f2c848e80e61802fd723391ca3bea9df462 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 2 Mar 2020 16:21:08 -0700
Subject: [PATCH 11/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 7261c9959dcee..55882fb59a353 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -75,8 +75,9 @@ static Value *SimplifyGEPInst(Type *, ArrayRef<Value *>, const SimplifyQuery &,
 
 static Value *foldSelectWithBinaryOp(Value *Cond, Value *TrueVal,
                                      Value *FalseVal) {
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   BinaryOperator::BinaryOps BinOpCode;
   if (auto *BO = dyn_cast<BinaryOperator>(Cond))
     BinOpCode = BO->getOpcode();

From 396af395c64e1c1f2e43cdd32076cd149cfb53fa Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 23 Mar 2020 15:38:18 -0600
Subject: [PATCH 12/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 145 ++++++++++++++++------
 1 file changed, 109 insertions(+), 36 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 63ae64fb0a056..40717be65d1c2 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -133,7 +133,9 @@ static Constant *getTrue(Type *Ty) {
 /// isSameCompare - Is V equivalent to the comparison "LHS Pred RHS"?
 static bool isSameCompare(Value *V, CmpInst::Predicate Pred, Value *LHS,
                           Value *RHS) {
-  return false;
+  if (DisablePeepholes)
+    return false;
+
   CmpInst *Cmp = dyn_cast<CmpInst>(V);
   if (!Cmp)
     return false;
@@ -212,7 +214,9 @@ static Value *handleOtherCmpSelSimplifications(Value *TCmp, Value *FCmp,
 
 /// Does the given value dominate the specified phi node?
 static bool valueDominatesPHI(Value *V, PHINode *P, const DominatorTree *DT) {
-  return false;
+  if (DisablePeepholes)
+    return false;
+
   Instruction *I = dyn_cast<Instruction>(V);
   if (!I)
     // Arguments and constants dominate all instructions.
@@ -3282,7 +3286,9 @@ static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
 /// If not, this returns null.
 static Value *SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   CmpInst::Predicate Pred = (CmpInst::Predicate)Predicate;
   assert(CmpInst::isIntPredicate(Pred) && "Not an integer compare!");
 
@@ -3592,7 +3598,9 @@ static Value *SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,
     Pred = CmpInst::getSwappedPredicate(Pred);
   }
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Fold trivial predicates.
   Type *RetTy = GetCompareTy(LHS);
   if (Pred == FCmpInst::FCMP_FALSE)
@@ -3769,7 +3777,9 @@ Value *llvm::SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,
 static const Value *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,
                                            const SimplifyQuery &Q,
                                            unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Trivial replacement.
   if (V == Op)
     return RepOp;
@@ -3869,7 +3879,9 @@ static const Value *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,
 /// integer comparison where one operand of the compare is a constant.
 static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
                                     const APInt *Y, bool TrueWhenUnset) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   const APInt *C;
 
   // (X & Y) == 0 ? X & ~Y : X  --> X
@@ -3906,7 +3918,9 @@ static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
 static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
                                            ICmpInst::Predicate Pred,
                                            Value *TrueVal, Value *FalseVal) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   APInt Mask;
   if (!decomposeBitTestICmp(CmpLHS, CmpRHS, Pred, X, Mask))
@@ -3921,7 +3935,9 @@ static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
 static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
                                          Value *FalseVal, const SimplifyQuery &Q,
                                          unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *CmpLHS, *CmpRHS;
   if (!match(CondVal, m_ICmp(Pred, m_Value(CmpLHS), m_Value(CmpRHS))))
@@ -4014,7 +4030,9 @@ static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
 /// floating-point comparison.
 static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
                                      const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   FCmpInst::Predicate Pred;
   if (!match(Cond, m_FCmp(Pred, m_Specific(T), m_Specific(F))) &&
       !match(Cond, m_FCmp(Pred, m_Specific(F), m_Specific(T))))
@@ -4046,7 +4064,9 @@ static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
 /// If not, this returns null.
 static Value *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
                                  const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CondC = dyn_cast<Constant>(Cond)) {
     if (auto *TrueC = dyn_cast<Constant>(TrueVal))
       if (auto *FalseC = dyn_cast<Constant>(FalseVal))
@@ -4138,7 +4158,9 @@ Value *llvm::SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
 /// If not, this returns null.
 static Value *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
                               const SimplifyQuery &Q, unsigned) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // The type of the GEP pointer operand.
   unsigned AS =
       cast<PointerType>(Ops[0]->getType()->getScalarType())->getAddressSpace();
@@ -4260,7 +4282,9 @@ Value *llvm::SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
 static Value *SimplifyInsertValueInst(Value *Agg, Value *Val,
                                       ArrayRef<unsigned> Idxs, const SimplifyQuery &Q,
                                       unsigned) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *CAgg = dyn_cast<Constant>(Agg))
     if (Constant *CVal = dyn_cast<Constant>(Val))
       return ConstantFoldInsertValueInstruction(CAgg, CVal, Idxs);
@@ -4300,7 +4324,8 @@ Value *llvm::SimplifyInsertElementInst(Value *Vec, Value *Val, Value *Idx,
   if (VecC && ValC && IdxC)
     return ConstantFoldInsertElementInstruction(VecC, ValC, IdxC);
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
 
   // For fixed-length vector, fold into undef if index is out of bounds.
   if (auto *CI = dyn_cast<ConstantInt>(Idx)) {
@@ -4334,7 +4359,9 @@ static Value *SimplifyExtractValueInst(Value *Agg, ArrayRef<unsigned> Idxs,
   if (auto *CAgg = dyn_cast<Constant>(Agg))
     return ConstantFoldExtractValueInstruction(CAgg, Idxs);
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // extractvalue x, (insertvalue y, elt, n), n -> elt
   unsigned NumIdxs = Idxs.size();
   for (auto *IVI = dyn_cast<InsertValueInst>(Agg); IVI != nullptr;
@@ -4366,7 +4393,9 @@ static Value *SimplifyExtractElementInst(Value *Vec, Value *Idx, const SimplifyQ
     if (auto *CIdx = dyn_cast<Constant>(Idx))
       return ConstantFoldExtractElementInstruction(CVec, CIdx);
 
-    return nullptr;
+    if (DisablePeepholes)
+      return nullptr;
+
     // The index is not relevant if our vector is a splat.
     if (auto *Splat = CVec->getSplatValue())
       return Splat;
@@ -4375,7 +4404,9 @@ static Value *SimplifyExtractElementInst(Value *Vec, Value *Idx, const SimplifyQ
       return UndefValue::get(Vec->getType()->getVectorElementType());
   }
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // If extracting a specified index from the vector, see if we can recursively
   // find a previously computed scalar that was inserted into the vector.
   if (auto *IdxC = dyn_cast<ConstantInt>(Idx)) {
@@ -4441,7 +4472,9 @@ static Value *SimplifyCastInst(unsigned CastOpc, Value *Op,
   if (auto *C = dyn_cast<Constant>(Op))
     return ConstantFoldCastOperand(CastOpc, C, Ty, Q.DL);
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CI = dyn_cast<CastInst>(Op)) {
     auto *Src = CI->getOperand(0);
     Type *SrcTy = Src->getType();
@@ -4482,7 +4515,9 @@ Value *llvm::SimplifyCastInst(unsigned CastOpc, Value *Op, Type *Ty,
 static Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,
                                    int MaskVal, Value *RootVec,
                                    unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!MaxRecurse--)
     return nullptr;
 
@@ -4531,7 +4566,9 @@ static Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,
 static Value *SimplifyShuffleVectorInst(Value *Op0, Value *Op1, Constant *Mask,
                                         Type *RetTy, const SimplifyQuery &Q,
                                         unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (isa<UndefValue>(Mask))
     return UndefValue::get(RetTy);
 
@@ -4668,7 +4705,9 @@ static Value *simplifyFNegInst(Value *Op, FastMathFlags FMF,
   if (Constant *C = foldConstant(Instruction::FNeg, Op, Q))
     return C;
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   // fneg (fneg X) ==> X
   if (match(Op, m_FNeg(m_Value(X))))
@@ -4683,8 +4722,10 @@ Value *llvm::SimplifyFNegInst(Value *Op, FastMathFlags FMF,
 }
 
 static Constant *propagateNaN(Constant *In) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the input is a vector with undef elements, just return a default NaN.
-  return nullptr;
   if (!In->isNaN())
     return ConstantFP::getNaN(In->getType());
 
@@ -4698,7 +4739,9 @@ static Constant *propagateNaN(Constant *In) {
 /// difference to the result.
 static Constant *simplifyFPOp(ArrayRef<Value *> Ops,
                               FastMathFlags FMF = FastMathFlags()) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   for (Value *V : Ops) {
     bool IsNan = match(V, m_NaN());
     bool IsInf = match(V, m_Inf());
@@ -4725,7 +4768,8 @@ static Value *SimplifyFAddInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FAdd, Op0, Op1, Q))
     return C;
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
 
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF))
     return C;
@@ -4774,7 +4818,9 @@ static Value *SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FSub, Op0, Op1, Q))
     return C;
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF))
     return C;
 
@@ -4817,7 +4863,9 @@ static Value *SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,
 
 static Value *SimplifyFMAFMul(Value *Op0, Value *Op1, FastMathFlags FMF,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF))
     return C;
 
@@ -4854,7 +4902,9 @@ static Value *SimplifyFMulInst(Value *Op0, Value *Op1, FastMathFlags FMF,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
   if (Constant *C = foldOrCommuteConstant(Instruction::FMul, Op0, Op1, Q))
     return C;
-  return nullptr;
+
+  if (DisablePeepholes)
+    return nullptr;
 
   // Now apply simplifications that do not require rounding.
   return SimplifyFMAFMul(Op0, Op1, FMF, Q, MaxRecurse);
@@ -4886,7 +4936,9 @@ static Value *SimplifyFDivInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FDiv, Op0, Op1, Q))
     return C;
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF))
     return C;
 
@@ -4932,7 +4984,9 @@ static Value *SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FRem, Op0, Op1, Q))
     return C;
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF))
     return C;
 
@@ -4962,7 +5016,9 @@ Value *llvm::SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,
 /// If not, this returns null.
 static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
                            unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FastMathFlags(), Q, MaxRecurse);
@@ -4977,7 +5033,9 @@ static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
 static Value *simplifyFPUnOp(unsigned Opcode, Value *Op,
                              const FastMathFlags &FMF,
                              const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FMF, Q, MaxRecurse);
@@ -5103,7 +5161,9 @@ static bool IsIdempotent(Intrinsic::ID ID) {
 
 static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
                                    const DataLayout &DL) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   GlobalValue *PtrSym;
   APInt PtrOffset;
   if (!IsConstantOffsetFromGlobal(Ptr, PtrSym, PtrOffset, DL))
@@ -5160,7 +5220,9 @@ static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
 
 static Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,
                                      const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Idempotent functions return the same result when called repeatedly.
   Intrinsic::ID IID = F->getIntrinsicID();
   if (IsIdempotent(IID))
@@ -5234,7 +5296,9 @@ static Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,
 
 static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
                                       const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Intrinsic::ID IID = F->getIntrinsicID();
   Type *ReturnType = F->getReturnType();
   switch (IID) {
@@ -5383,7 +5447,9 @@ static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
 
 static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Intrinsics with no operands have some kind of side effect. Don't simplify.
   unsigned NumOperands = Call->getNumArgOperands();
   if (!NumOperands)
@@ -5446,7 +5512,9 @@ static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 }
 
 Value *llvm::SimplifyCall(CallBase *Call, const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *Callee = Call->getCalledValue();
 
   // musttail calls can only be simplified if they are also DCEd.
@@ -5485,7 +5553,9 @@ Value *llvm::SimplifyCall(CallBase *Call, const SimplifyQuery &Q) {
 
 /// Given operands for a Freeze, see if we can fold the result.
 static Value *SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Use a utility function defined in ValueTracking.
   if (llvm::isGuaranteedNotToBeUndefOrPoison(Op0, Q.CxtI, Q.DT))
     return Op0;
@@ -5502,6 +5572,9 @@ Value *llvm::SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {
 
 Value *llvm::SimplifyInstruction(Instruction *I, const SimplifyQuery &SQ,
                                  OptimizationRemarkEmitter *ORE) {
+  if (DisablePeepholes)
+    return nullptr;
+
   const SimplifyQuery Q = SQ.CxtI ? SQ : SQ.getWithInstruction(I);
   Value *Result;
 

From f4c8bafdda0ee99a43938cdb4f4083258e3d9ab9 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 23 Mar 2020 15:59:12 -0600
Subject: [PATCH 13/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp     | 203 ++++++++++++------
 .../AggressiveInstCombine.cpp                 |   7 +-
 .../InstCombine/InstructionCombining.cpp      |   5 +-
 .../Transforms/Vectorize/VectorCombine.cpp    |   1 +
 4 files changed, 153 insertions(+), 63 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 40717be65d1c2..915fb397e8a24 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -249,7 +249,9 @@ static bool valueDominatesPHI(Value *V, PHINode *P, const DominatorTree *DT) {
 static Value *ExpandBinOp(Instruction::BinaryOps Opcode, Value *LHS, Value *RHS,
                           Instruction::BinaryOps OpcodeToExpand,
                           const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -309,7 +311,9 @@ static Value *SimplifyAssociativeBinOp(Instruction::BinaryOps Opcode,
                                        Value *LHS, Value *RHS,
                                        const SimplifyQuery &Q,
                                        unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(Instruction::isAssociative(Opcode) && "Not an associative operation!");
 
   // Recursion is always used, so bail out at once if we already hit the limit.
@@ -409,7 +413,9 @@ static Value *SimplifyAssociativeBinOp(Instruction::BinaryOps Opcode,
 static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -488,7 +494,9 @@ static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
 static Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q,
                                   unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -535,6 +543,9 @@ static Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,
 static Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,
                                  Value *RHS, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -577,7 +588,9 @@ static Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,
 /// otherwise returns null.
 static Value *ThreadCmpOverPHI(CmpInst::Predicate Pred, Value *LHS, Value *RHS,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -623,7 +636,9 @@ static Constant *foldOrCommuteConstant(Instruction::BinaryOps Opcode,
     if (auto *CRHS = dyn_cast<Constant>(Op1))
       return ConstantFoldBinaryOpOperands(Opcode, CLHS, CRHS, Q.DL);
 
-    return nullptr;
+    if (DisablePeepholes)
+      return nullptr;
+
     // Canonicalize the constant to the RHS if this is a commutative operation.
     if (Instruction::isCommutative(Opcode))
       std::swap(Op0, Op1);
@@ -635,10 +650,12 @@ static Constant *foldOrCommuteConstant(Instruction::BinaryOps Opcode,
 /// If not, this returns null.
 static Value *SimplifyAddInst(Value *Op0, Value *Op1, bool IsNSW, bool IsNUW,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
   if (Constant *C = foldOrCommuteConstant(Instruction::Add, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X + undef -> undef
   if (match(Op1, m_Undef()))
     return Op1;
@@ -736,7 +753,9 @@ static Constant *stripAndComputeConstantOffsets(const DataLayout &DL, Value *&V,
 /// If the difference is not a constant, returns zero.
 static Constant *computePointerDifference(const DataLayout &DL, Value *LHS,
                                           Value *RHS) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Constant *LHSOffset = stripAndComputeConstantOffsets(DL, LHS);
   Constant *RHSOffset = stripAndComputeConstantOffsets(DL, RHS);
 
@@ -759,8 +778,9 @@ static Value *SimplifySubInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
   if (Constant *C = foldOrCommuteConstant(Instruction::Sub, Op0, Op1, Q))
     return C;
 
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   // X - undef -> undef
   // undef - X -> undef
   if (match(Op0, m_Undef()) || match(Op1, m_Undef()))
@@ -896,8 +916,9 @@ static Value *SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::Mul, Op0, Op1, Q))
     return C;
 
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   // X * undef -> 0
   // X * 0 -> 0
   if (match(Op1, m_CombineOr(m_Undef(), m_Zero())))
@@ -954,8 +975,9 @@ Value *llvm::SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// Check for common or similar folds of integer division or integer remainder.
 /// This applies to all 4 opcodes (sdiv/udiv/srem/urem).
 static Value *simplifyDivRem(Value *Op0, Value *Op1, bool IsDiv) {
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *Ty = Op0->getType();
 
   // X / undef -> undef
@@ -1023,8 +1045,9 @@ static bool isICmpTrue(ICmpInst::Predicate Pred, Value *LHS, Value *RHS,
 /// to simplify X % Y to X.
 static bool isDivZero(Value *X, Value *Y, const SimplifyQuery &Q,
                       unsigned MaxRecurse, bool IsSigned) {
-  return false;
-  
+  if (DisablePeepholes)
+    return false;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return false;
@@ -1079,8 +1102,9 @@ static Value *simplifyDiv(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Op0, Op1, true))
     return V;
 
@@ -1139,8 +1163,9 @@ static Value *simplifyRem(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Op0, Op1, false))
     return V;
 
@@ -1182,7 +1207,9 @@ static Value *simplifyRem(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
 /// If not, this returns null.
 static Value *SimplifySDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // If two operands are negated and no signed overflow, return -1.
   if (isKnownNegation(Op0, Op1, /*NeedNSW=*/true))
     return Constant::getAllOnesValue(Op0->getType());
@@ -1209,7 +1236,9 @@ Value *llvm::SimplifyUDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// If not, this returns null.
 static Value *SimplifySRemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the divisor is 0, the result is undefined, so assume the divisor is -1.
   // srem Op0, (sext i1 X) --> srem Op0, -1 --> 0
   Value *X;
@@ -1272,8 +1301,9 @@ static Value *SimplifyShift(Instruction::BinaryOps Opcode, Value *Op0,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   // 0 shift by X -> 0
   if (match(Op0, m_Zero()))
     return Constant::getNullValue(Op0->getType());
@@ -1322,8 +1352,9 @@ static Value *SimplifyShift(Instruction::BinaryOps Opcode, Value *Op0,
 static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
                                  Value *Op1, bool isExact, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyShift(Opcode, Op0, Op1, Q, MaxRecurse))
     return V;
 
@@ -1350,8 +1381,9 @@ static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
 /// If not, this returns null.
 static Value *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyShift(Instruction::Shl, Op0, Op1, Q, MaxRecurse))
     return V;
 
@@ -1384,8 +1416,9 @@ Value *llvm::SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
 /// If not, this returns null.
 static Value *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::LShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
       return V;
@@ -1424,8 +1457,9 @@ Value *llvm::SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
 /// If not, this returns null.
 static Value *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::AShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
     return V;
@@ -1458,8 +1492,9 @@ Value *llvm::SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
 static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
                                          ICmpInst *UnsignedICmp, bool IsAnd,
                                          const SimplifyQuery &Q) {
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X, *Y;
 
   ICmpInst::Predicate EqPred;
@@ -1563,7 +1598,9 @@ static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1589,7 +1626,9 @@ static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1618,7 +1657,9 @@ static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
 /// the other.
 static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                 bool IsAnd) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look for this pattern: {and/or} (icmp X, C0), (icmp X, C1)).
   if (Cmp0->getOperand(0) != Cmp1->getOperand(0))
     return nullptr;
@@ -1656,7 +1697,9 @@ static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
 
 static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                            bool IsAnd) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate P0 = Cmp0->getPredicate(), P1 = Cmp1->getPredicate();
   if (!match(Cmp0->getOperand(1), m_Zero()) ||
       !match(Cmp1->getOperand(1), m_Zero()) || P0 != P1)
@@ -1694,7 +1737,9 @@ static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
 
 static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                         const InstrInfoQuery &IIQ) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) & (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1742,7 +1787,9 @@ static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                  const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/true, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/true, Q))
@@ -1769,7 +1816,9 @@ static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                        const InstrInfoQuery &IIQ) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) | (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1817,7 +1866,9 @@ static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                 const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/false, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/false, Q))
@@ -1844,7 +1895,9 @@ static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
                                    FCmpInst *LHS, FCmpInst *RHS, bool IsAnd) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);
   Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);
   if (LHS0->getType() != RHS0->getType())
@@ -1883,7 +1936,9 @@ static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
 
 static Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,
                                   Value *Op0, Value *Op1, bool IsAnd) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look through casts of the 'and' operands to find compares.
   auto *Cast0 = dyn_cast<CastInst>(Op0);
   auto *Cast1 = dyn_cast<CastInst>(Op1);
@@ -1923,7 +1978,9 @@ static Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,
 ///   %Op1 = extractvalue { i4, i1 } %Agg, 1
 static bool omitCheckForZeroBeforeMulWithOverflowInternal(Value *Op1,
                                                           Value *X) {
-  return false;
+  if (DisablePeepholes)
+    return false;
+
   auto *Extract = dyn_cast<ExtractValueInst>(Op1);
   // We should only be extracting the overflow bit.
   if (!Extract || !Extract->getIndices().equals(1))
@@ -1950,7 +2007,9 @@ static bool omitCheckForZeroBeforeMulWithOverflowInternal(Value *Op1,
 ///   %??? = and i1 %Op0, %Op1
 /// We can just return  %Op1
 static Value *omitCheckForZeroBeforeMulWithOverflow(Value *Op0, Value *Op1) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *X;
   if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||
@@ -1975,7 +2034,9 @@ static Value *omitCheckForZeroBeforeMulWithOverflow(Value *Op0, Value *Op1) {
 /// We can just return  %NotOp1
 static Value *omitCheckForZeroBeforeInvertedMulWithOverflow(Value *Op0,
                                                             Value *NotOp1) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *X;
   if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||
@@ -1999,8 +2060,9 @@ static Value *SimplifyAndInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::And, Op0, Op1, Q))
     return C;
 
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   // X & undef -> 0
   if (match(Op1, m_Undef()))
     return Constant::getNullValue(Op0->getType());
@@ -2157,8 +2219,9 @@ static Value *SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))
     return C;
 
-  return nullptr;
-  
+  if (DisablePeepholes)
+    return nullptr;
+
   // X | undef -> -1
   // X | -1 = -1
   // Do not return Op1 because it may contain undef elements if it's a vector.
@@ -2300,7 +2363,9 @@ Value *llvm::SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// If not, this returns null.
 static Value *SimplifyXorInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                               unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = foldOrCommuteConstant(Instruction::Xor, Op0, Op1, Q))
     return C;
 
@@ -2352,7 +2417,9 @@ static Type *GetCompareTy(Value *Op) {
 /// Helper function for analyzing max/min idioms.
 static Value *ExtractEquivalentCondition(Value *V, CmpInst::Predicate Pred,
                                          Value *LHS, Value *RHS) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   SelectInst *SI = dyn_cast<SelectInst>(V);
   if (!SI)
     return nullptr;
@@ -2401,7 +2468,9 @@ computePointerICmp(const DataLayout &DL, const TargetLibraryInfo *TLI,
                    const DominatorTree *DT, CmpInst::Predicate Pred,
                    AssumptionCache *AC, const Instruction *CxtI,
                    const InstrInfoQuery &IIQ, Value *LHS, Value *RHS) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   // First, skip past any trivial no-ops.
   LHS = LHS->stripPointerCasts();
   RHS = RHS->stripPointerCasts();
@@ -2586,7 +2655,9 @@ computePointerICmp(const DataLayout &DL, const TargetLibraryInfo *TLI,
 /// Fold an icmp when its operands have i1 scalar type.
 static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Type *OpTy = LHS->getType();   // The operand type.
   if (!OpTy->isIntOrIntVectorTy(1))
@@ -2661,7 +2732,9 @@ static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
 /// Try hard to fold icmp with zero RHS because this is a common case.
 static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
                                    Value *RHS, const SimplifyQuery &Q) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!match(RHS, m_Zero()))
     return nullptr;
 
@@ -2724,7 +2797,9 @@ static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
 
 static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
                                        Value *RHS, const InstrInfoQuery &IIQ) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *X;
@@ -2767,7 +2842,9 @@ static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
 
   BinaryOperator *LBO = dyn_cast<BinaryOperator>(LHS);
@@ -3082,7 +3159,9 @@ static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
                                      Value *RHS, const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
-  return nullptr;
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Value *A, *B;
   CmpInst::Predicate P = CmpInst::BAD_ICMP_PREDICATE;
@@ -3592,7 +3671,9 @@ static Value *SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,
     if (Constant *CRHS = dyn_cast<Constant>(RHS))
       return ConstantFoldCompareInstOperands(Pred, CLHS, CRHS, Q.DL, Q.TLI);
 
-  return nullptr;
+    if (DisablePeepholes)
+      return nullptr;
+
     // If we have a constant, make sure it is on the RHS.
     std::swap(LHS, RHS);
     Pred = CmpInst::getSwappedPredicate(Pred);
@@ -4435,7 +4516,7 @@ Value *llvm::SimplifyExtractElementInst(Value *Vec, Value *Idx,
 static Value *SimplifyPHINode(PHINode *PN, const SimplifyQuery &Q) {
 
   // JDR: can't disable this w/o breaking the compiler
-  
+
   // If all of the PHI's incoming values are the same then replace the PHI node
   // with the common value.
   Value *CommonValue = nullptr;
diff --git a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
index c025fc331d688..827f422d58b18 100644
--- a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
+++ b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
@@ -31,6 +31,8 @@
 using namespace llvm;
 using namespace PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "aggressive-instcombine"
 
 namespace {
@@ -370,7 +372,9 @@ void AggressiveInstCombinerLegacyPass::getAnalysisUsage(
 }
 
 bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
-  return false;
+  if (DisablePeepholes)
+    return false;
+
   auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);
   auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
   return runImpl(F, TLI, DT);
@@ -379,6 +383,7 @@ bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
 PreservedAnalyses AggressiveInstCombinePass::run(Function &F,
                                                  FunctionAnalysisManager &AM) {
   return PreservedAnalyses::all();
+
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   if (!runImpl(F, TLI, DT)) {
diff --git a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
index 40322f1057954..aa02f6dd8ebcf 100644
--- a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
@@ -111,6 +111,8 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "instcombine"
 
 STATISTIC(NumCombined , "Number of insts combined");
@@ -3846,7 +3848,8 @@ void InstructionCombiningPass::getAnalysisUsage(AnalysisUsage &AU) const {
 }
 
 bool InstructionCombiningPass::runOnFunction(Function &F) {
-  return false;
+  if (DisablePeepholes)
+    return false;
 
   if (skipFunction(F))
     return false;
diff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
index 774ca0b90f40a..d21e3ddf88851 100644
--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
@@ -297,6 +297,7 @@ class VectorCombineLegacyPass : public FunctionPass {
   bool runOnFunction(Function &F) override {
     if (DisablePeepholes)
       return false;
+
     if (skipFunction(F))
       return false;
     auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);

From f26c26961feadec1704819e6bdd042740c072442 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 23 Mar 2020 16:02:26 -0600
Subject: [PATCH 14/48] foo

---
 .../Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
index 827f422d58b18..ebdcbe57c4625 100644
--- a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
+++ b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
@@ -382,7 +382,8 @@ bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
 
 PreservedAnalyses AggressiveInstCombinePass::run(Function &F,
                                                  FunctionAnalysisManager &AM) {
-  return PreservedAnalyses::all();
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
 
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);

From d44c8a9bf0a56eb1fab4aedf5270472bc82ffc8c Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 23 Mar 2020 16:21:09 -0600
Subject: [PATCH 15/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 915fb397e8a24..c9155106894f0 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -43,9 +43,13 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+#if 0
 cl::opt<bool> DisablePeepholes(
     "disable-peepholes", cl::init(false),
     cl::desc("Don't run peephole passes."));
+#else
+bool DisablePeepholes = false;
+#endif
 
 #define DEBUG_TYPE "instsimplify"
 

From c87487ca2fd094f22b66feb29483c68123499879 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 23 Mar 2020 16:30:21 -0600
Subject: [PATCH 16/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index c9155106894f0..67be738fa0483 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -43,13 +43,12 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
-#if 0
-cl::opt<bool> DisablePeepholes(
-    "disable-peepholes", cl::init(false),
-    cl::desc("Don't run peephole passes."));
-#else
 bool DisablePeepholes = false;
-#endif
+
+static cl::opt<bool, true>
+DisablePeepholesOption("disable-all-peepholes",
+                       cl::desc("Don't perform peephole optimizations"),
+                       cl::location(DisablePeepholes));
 
 #define DEBUG_TYPE "instsimplify"
 

From 5c75a3b9ce52c07d0db63d3bf24fc184beb5923e Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 23 Mar 2020 20:33:35 -0600
Subject: [PATCH 17/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 9 ++-------
 1 file changed, 2 insertions(+), 7 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 67be738fa0483..d2cecf7acbf2b 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -43,8 +43,9 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
-bool DisablePeepholes = false;
+bool DisablePeepholes = true;
 
+// "true" for 2nd template argument means use external storage
 static cl::opt<bool, true>
 DisablePeepholesOption("disable-all-peepholes",
                        cl::desc("Don't perform peephole optimizations"),
@@ -217,9 +218,6 @@ static Value *handleOtherCmpSelSimplifications(Value *TCmp, Value *FCmp,
 
 /// Does the given value dominate the specified phi node?
 static bool valueDominatesPHI(Value *V, PHINode *P, const DominatorTree *DT) {
-  if (DisablePeepholes)
-    return false;
-
   Instruction *I = dyn_cast<Instruction>(V);
   if (!I)
     // Arguments and constants dominate all instructions.
@@ -5656,9 +5654,6 @@ Value *llvm::SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {
 
 Value *llvm::SimplifyInstruction(Instruction *I, const SimplifyQuery &SQ,
                                  OptimizationRemarkEmitter *ORE) {
-  if (DisablePeepholes)
-    return nullptr;
-
   const SimplifyQuery Q = SQ.CxtI ? SQ : SQ.getWithInstruction(I);
   Value *Result;
 

From 976c5e3308c0c0c94d097c2687d4954d986e9e82 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 23 Mar 2020 21:11:45 -0600
Subject: [PATCH 18/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index d2cecf7acbf2b..c648ffd7f833b 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -43,7 +43,7 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
-bool DisablePeepholes = true;
+bool DisablePeepholes = false;
 
 // "true" for 2nd template argument means use external storage
 static cl::opt<bool, true>

From d5b38a3149d0c97d53c76cbc7a7b125e4c3fd800 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Mon, 13 Apr 2020 21:54:55 -0600
Subject: [PATCH 19/48] oops, left a hole!

---
 llvm/lib/Transforms/InstCombine/InstructionCombining.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
index bfe49ebb3ca00..02a836a96b984 100644
--- a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
@@ -3816,6 +3816,11 @@ InstCombinePass::InstCombinePass(unsigned MaxIterations)
 
 PreservedAnalyses InstCombinePass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisablePeepholes) {
+    PreservedAnalyses PA;
+    return PA;
+  }
+
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);

From 627b2194a56fe03a60ba34004a832530b35bd84e Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Wed, 15 Apr 2020 09:36:49 -0600
Subject: [PATCH 20/48] foo

---
 llvm/lib/Transforms/InstCombine/InstructionCombining.cpp | 6 ++----
 llvm/lib/Transforms/Scalar/NaryReassociate.cpp           | 8 ++++++++
 llvm/lib/Transforms/Scalar/Reassociate.cpp               | 8 ++++++++
 3 files changed, 18 insertions(+), 4 deletions(-)

diff --git a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
index f05ea0216c7a6..15604a4de87e3 100644
--- a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
@@ -3827,10 +3827,8 @@ InstCombinePass::InstCombinePass(unsigned MaxIterations)
 
 PreservedAnalyses InstCombinePass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
-  if (DisablePeepholes) {
-    PreservedAnalyses PA;
-    return PA;
-  }
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
 
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/NaryReassociate.cpp b/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
index bba9082e31b2f..b05da5a187980 100644
--- a/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
+++ b/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
@@ -114,6 +114,8 @@ using namespace PatternMatch;
 
 #define DEBUG_TYPE "nary-reassociate"
 
+extern bool DisablePeepholes;
+
 namespace {
 
 class NaryReassociateLegacyPass : public FunctionPass {
@@ -165,6 +167,9 @@ FunctionPass *llvm::createNaryReassociatePass() {
 }
 
 bool NaryReassociateLegacyPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   if (skipFunction(F))
     return false;
 
@@ -179,6 +184,9 @@ bool NaryReassociateLegacyPass::runOnFunction(Function &F) {
 
 PreservedAnalyses NaryReassociatePass::run(Function &F,
                                            FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto *AC = &AM.getResult<AssumptionAnalysis>(F);
   auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   auto *SE = &AM.getResult<ScalarEvolutionAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/Reassociate.cpp b/llvm/lib/Transforms/Scalar/Reassociate.cpp
index 8b4e36a85132a..9d494d9f6f3ef 100644
--- a/llvm/lib/Transforms/Scalar/Reassociate.cpp
+++ b/llvm/lib/Transforms/Scalar/Reassociate.cpp
@@ -85,6 +85,8 @@ static void PrintOps(Instruction *I, const SmallVectorImpl<ValueEntry> &Ops) {
 }
 #endif
 
+extern bool DisablePeepholes;
+
 /// Utility class representing a non-constant Xor-operand. We classify
 /// non-constant Xor-Operands into two categories:
 ///  C1) The operand is in the form "X & C", where C is a constant and C != ~0
@@ -2386,6 +2388,9 @@ ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {
 }
 
 PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   // Get the functions basic blocks in Reverse Post Order. This order is used by
   // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic
   // blocks (it has been seen that the analysis in this pass could hang when
@@ -2477,6 +2482,9 @@ namespace {
     }
 
     bool runOnFunction(Function &F) override {
+      if (DisablePeepholes)
+        return false;
+
       if (skipFunction(F))
         return false;
 

From dac2005f6ae48d13c4ea5eb8a66e9eb8910e70f1 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Wed, 20 May 2020 20:59:02 -0600
Subject: [PATCH 21/48] foo

---
 llvm/include/llvm/Transforms/Scalar/DCE.h |  3 ++
 llvm/lib/Transforms/Scalar/DCE.cpp        | 48 +++++++++++------------
 2 files changed, 27 insertions(+), 24 deletions(-)

diff --git a/llvm/include/llvm/Transforms/Scalar/DCE.h b/llvm/include/llvm/Transforms/Scalar/DCE.h
index 974e4b20d152d..b72f82a2d47a3 100644
--- a/llvm/include/llvm/Transforms/Scalar/DCE.h
+++ b/llvm/include/llvm/Transforms/Scalar/DCE.h
@@ -13,9 +13,12 @@
 #ifndef LLVM_TRANSFORMS_SCALAR_DCE_H
 #define LLVM_TRANSFORMS_SCALAR_DCE_H
 
+#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/PassManager.h"
 
+bool eliminateDeadCode(llvm::Function &F, llvm::TargetLibraryInfo *TLI);
+
 namespace llvm {
 
 /// Basic Dead Code Elimination pass.
diff --git a/llvm/lib/Transforms/Scalar/DCE.cpp b/llvm/lib/Transforms/Scalar/DCE.cpp
index 28947482e3031..7ef0e66fb810d 100644
--- a/llvm/lib/Transforms/Scalar/DCE.cpp
+++ b/llvm/lib/Transforms/Scalar/DCE.cpp
@@ -18,7 +18,6 @@
 #include "llvm/Transforms/Scalar/DCE.h"
 #include "llvm/ADT/SetVector.h"
 #include "llvm/ADT/Statistic.h"
-#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/InstIterator.h"
 #include "llvm/IR/Instruction.h"
 #include "llvm/InitializePasses.h"
@@ -154,29 +153,6 @@ static bool DCEInstruction(Instruction *I,
   return false;
 }
 
-static bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
-  bool MadeChange = false;
-  SmallSetVector<Instruction *, 16> WorkList;
-  // Iterate over the original function, only adding insts to the worklist
-  // if they actually need to be revisited. This avoids having to pre-init
-  // the worklist with the entire function's worth of instructions.
-  for (inst_iterator FI = inst_begin(F), FE = inst_end(F); FI != FE;) {
-    Instruction *I = &*FI;
-    ++FI;
-
-    // We're visiting this instruction now, so make sure it's not in the
-    // worklist from an earlier visit.
-    if (!WorkList.count(I))
-      MadeChange |= DCEInstruction(I, WorkList, TLI);
-  }
-
-  while (!WorkList.empty()) {
-    Instruction *I = WorkList.pop_back_val();
-    MadeChange |= DCEInstruction(I, WorkList, TLI);
-  }
-  return MadeChange;
-}
-
 PreservedAnalyses DCEPass::run(Function &F, FunctionAnalysisManager &AM) {
   if (!eliminateDeadCode(F, AM.getCachedResult<TargetLibraryAnalysis>(F)))
     return PreservedAnalyses::all();
@@ -215,3 +191,27 @@ INITIALIZE_PASS(DCELegacyPass, "dce", "Dead Code Elimination", false, false)
 FunctionPass *llvm::createDeadCodeEliminationPass() {
   return new DCELegacyPass();
 }
+
+bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
+  bool MadeChange = false;
+  SmallSetVector<Instruction *, 16> WorkList;
+  // Iterate over the original function, only adding insts to the worklist
+  // if they actually need to be revisited. This avoids having to pre-init
+  // the worklist with the entire function's worth of instructions.
+  for (inst_iterator FI = inst_begin(F), FE = inst_end(F); FI != FE;) {
+    Instruction *I = &*FI;
+    ++FI;
+
+    // We're visiting this instruction now, so make sure it's not in the
+    // worklist from an earlier visit.
+    if (!WorkList.count(I))
+      MadeChange |= DCEInstruction(I, WorkList, TLI);
+  }
+
+  while (!WorkList.empty()) {
+    Instruction *I = WorkList.pop_back_val();
+    MadeChange |= DCEInstruction(I, WorkList, TLI);
+  }
+  return MadeChange;
+}
+

From 485ece8224b6be4353a3e3d6f1e9bedd31decd20 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 21 May 2020 23:20:37 -0600
Subject: [PATCH 22/48] foo

---
 llvm/lib/Transforms/Utils/SimplifyCFG.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
index 5bccb7d7b9df0..3f85f412cbeab 100644
--- a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
+++ b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
@@ -2801,7 +2801,9 @@ bool llvm::FoldBranchToCommonDest(BranchInst *BI, MemorySSAUpdater *MSSAU,
 
     if (BI->isConditional()) {
       Instruction *NewCond = cast<Instruction>(
-          Builder.CreateBinOp(Opc, PBI->getCondition(), CondInPred, "or.cond"));
+          Builder.CreateBinOp(Opc,
+                              Builder.CreateFreeze(PBI->getCondition()),
+                              Builder.CreateFreeze(CondInPred), "or.cond"));
       PBI->setCondition(NewCond);
 
       uint64_t PredTrueWeight, PredFalseWeight, SuccTrueWeight, SuccFalseWeight;

From 3e3168fa742a8f4682e79e43c89515fa031d59b6 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Fri, 22 May 2020 15:57:59 -0600
Subject: [PATCH 23/48] foo

---
 llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp | 5 +++++
 llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp    | 4 ++++
 2 files changed, 9 insertions(+)

diff --git a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
index 914fadc40d74f..9a150d13e309d 100644
--- a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
+++ b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
@@ -2877,6 +2877,9 @@ static bool unswitchLoop(Loop &L, DominatorTree &DT, LoopInfo &LI,
 PreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &U) {
+  PreservedAnalyses PA1;
+  return PA1;
+
   Function &F = *L.getHeader()->getParent();
   (void)F;
 
@@ -2954,6 +2957,8 @@ class SimpleLoopUnswitchLegacyPass : public LoopPass {
 } // end anonymous namespace
 
 bool SimpleLoopUnswitchLegacyPass::runOnLoop(Loop *L, LPPassManager &LPM) {
+  return false;
+
   if (skipLoop(L))
     return false;
 
diff --git a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
index ac53ff33e8362..bb75ed61e4022 100644
--- a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
+++ b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
@@ -232,6 +232,8 @@ SimplifyCFGPass::SimplifyCFGPass(const SimplifyCFGOptions &Opts) {
 
 PreservedAnalyses SimplifyCFGPass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  PreservedAnalyses PA1;
+  return PA1;
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   Options.AC = &AM.getResult<AssumptionAnalysis>(F);
   if (!simplifyFunctionCFG(F, TTI, Options))
@@ -277,6 +279,8 @@ struct CFGSimplifyPass : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
+    return false;
+
     if (skipFunction(F) || (PredicateFtor && !PredicateFtor(F)))
       return false;
 

From 4dc27da0c214c2aa30befd155bbf5dd0ae13faad Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Tue, 9 Jun 2020 14:37:53 -0600
Subject: [PATCH 25/48] foo

---
 llvm/lib/IR/LegacyPassManager.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/llvm/lib/IR/LegacyPassManager.cpp b/llvm/lib/IR/LegacyPassManager.cpp
index d5c7e2874825d..2e2db620d4a36 100644
--- a/llvm/lib/IR/LegacyPassManager.cpp
+++ b/llvm/lib/IR/LegacyPassManager.cpp
@@ -19,6 +19,7 @@
 #include "llvm/IR/LegacyPassManagers.h"
 #include "llvm/IR/LegacyPassNameParser.h"
 #include "llvm/IR/Module.h"
+#include "llvm/IR/Verifier.h"
 #include "llvm/IR/PassTimingInfo.h"
 #include "llvm/Support/Chrono.h"
 #include "llvm/Support/CommandLine.h"
@@ -84,6 +85,11 @@ static cl::opt<bool> PrintAfterAll("print-after-all",
                                    llvm::cl::desc("Print IR after each pass"),
                                    cl::init(false), cl::Hidden);
 
+static cl::opt<bool>
+VerifyAfterAll("verify-after-all",
+	       llvm::cl::desc("Verify the IR after each pass (and crash if the IR does not verify)"),
+	       cl::init(false));
+
 static cl::opt<bool>
     PrintModuleScope("print-module-scope",
                      cl::desc("When printing IR for print-[before|after]{-all} "
@@ -746,6 +752,11 @@ void PMTopLevelManager::schedulePass(Pass *P) {
         dbgs(), ("*** IR Dump After " + P->getPassName() + " ***").str());
     PP->assignPassManager(activeStack, getTopLevelPassManagerType());
   }
+
+  if (PI && !PI->isAnalysis() && VerifyAfterAll) {
+    createVerifierPass()->assignPassManager(activeStack,
+					    getTopLevelPassManagerType());
+  }
 }
 
 /// Find the pass that implements Analysis AID. Search immutable

From f430fc0b14324d08aa61a95904f9c4b41ac354e6 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Tue, 9 Jun 2020 14:47:39 -0600
Subject: [PATCH 26/48] Revert "foo"

This reverts commit 4dc27da0c214c2aa30befd155bbf5dd0ae13faad.
---
 llvm/lib/IR/LegacyPassManager.cpp | 11 -----------
 1 file changed, 11 deletions(-)

diff --git a/llvm/lib/IR/LegacyPassManager.cpp b/llvm/lib/IR/LegacyPassManager.cpp
index 2e2db620d4a36..d5c7e2874825d 100644
--- a/llvm/lib/IR/LegacyPassManager.cpp
+++ b/llvm/lib/IR/LegacyPassManager.cpp
@@ -19,7 +19,6 @@
 #include "llvm/IR/LegacyPassManagers.h"
 #include "llvm/IR/LegacyPassNameParser.h"
 #include "llvm/IR/Module.h"
-#include "llvm/IR/Verifier.h"
 #include "llvm/IR/PassTimingInfo.h"
 #include "llvm/Support/Chrono.h"
 #include "llvm/Support/CommandLine.h"
@@ -85,11 +84,6 @@ static cl::opt<bool> PrintAfterAll("print-after-all",
                                    llvm::cl::desc("Print IR after each pass"),
                                    cl::init(false), cl::Hidden);
 
-static cl::opt<bool>
-VerifyAfterAll("verify-after-all",
-	       llvm::cl::desc("Verify the IR after each pass (and crash if the IR does not verify)"),
-	       cl::init(false));
-
 static cl::opt<bool>
     PrintModuleScope("print-module-scope",
                      cl::desc("When printing IR for print-[before|after]{-all} "
@@ -752,11 +746,6 @@ void PMTopLevelManager::schedulePass(Pass *P) {
         dbgs(), ("*** IR Dump After " + P->getPassName() + " ***").str());
     PP->assignPassManager(activeStack, getTopLevelPassManagerType());
   }
-
-  if (PI && !PI->isAnalysis() && VerifyAfterAll) {
-    createVerifierPass()->assignPassManager(activeStack,
-					    getTopLevelPassManagerType());
-  }
 }
 
 /// Find the pass that implements Analysis AID. Search immutable

From c520a276c7020f9f36892d4949fd741b2ca967a8 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Tue, 9 Jun 2020 14:56:20 -0600
Subject: [PATCH 27/48] foo

---
 llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll | 1 -
 1 file changed, 1 deletion(-)

diff --git a/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll b/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll
index f57f94bf03cec..cbf87ed5ecaa7 100644
--- a/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll
+++ b/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll
@@ -1,4 +1,3 @@
-; XFAIL: *
 ; Needs some fixed in the pipeliner.
 ; RUN: llc -march=hexagon < %s -pipeliner-experimental-cg=true | FileCheck %s
 

From 4be9bdebbe09c3cbacc54eca8b1346cba7d432b1 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Tue, 9 Jun 2020 15:56:46 -0600
Subject: [PATCH 28/48] foo

---
 llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp | 9 ++++++---
 llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp    | 5 ++++-
 test-disable-peepholes.sh                         | 4 ++++
 3 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
index ec678ba69e70b..aa9ed4ddfa15b 100644
--- a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
+++ b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
@@ -2882,8 +2882,10 @@ static bool unswitchLoop(Loop &L, DominatorTree &DT, LoopInfo &LI,
 PreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &U) {
-  PreservedAnalyses PA1;
-  return PA1;
+  if (DisablePeepholes) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
 
   Function &F = *L.getHeader()->getParent();
   (void)F;
@@ -2962,7 +2964,8 @@ class SimpleLoopUnswitchLegacyPass : public LoopPass {
 } // end anonymous namespace
 
 bool SimpleLoopUnswitchLegacyPass::runOnLoop(Loop *L, LPPassManager &LPM) {
-  return false;
+  if (DisablePeepholes)
+    return false;
 
   if (skipLoop(L))
     return false;
diff --git a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
index 86e2fccfe130f..7cc54af130c87 100644
--- a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
+++ b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
@@ -45,6 +45,8 @@ using namespace llvm;
 
 #define DEBUG_TYPE "simplifycfg"
 
+extern bool DisablePeepholes;
+
 static cl::opt<unsigned> UserBonusInstThreshold(
     "bonus-inst-threshold", cl::Hidden, cl::init(1),
     cl::desc("Control the number of bonus instructions (default = 1)"));
@@ -279,7 +281,8 @@ struct CFGSimplifyPass : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
-    return false;
+    if (DisablePeepholes)
+      return false;
 
     if (skipFunction(F) || (PredicateFtor && !PredicateFtor(F)))
       return false;
From be95782f67fbb649b166069cc7757d16cf29b5b5 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Tue, 9 Jun 2020 19:50:36 -0600
Subject: [PATCH 29/48] foo

---
 llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp | 2 ++
 llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp    | 7 +++++--
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
index aa9ed4ddfa15b..e0974730feda8 100644
--- a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
+++ b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
@@ -57,6 +57,8 @@
 #include <numeric>
 #include <utility>
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "simple-loop-unswitch"
 
 using namespace llvm;
diff --git a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
index 7cc54af130c87..d37f89a6696fa 100644
--- a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
+++ b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
@@ -234,8 +234,11 @@ SimplifyCFGPass::SimplifyCFGPass(const SimplifyCFGOptions &Opts) {
 
 PreservedAnalyses SimplifyCFGPass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
-  PreservedAnalyses PA1;
-  return PA1;
+  if (DisablePeepholes) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
+
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   Options.AC = &AM.getResult<AssumptionAnalysis>(F);
   if (!simplifyFunctionCFG(F, TTI, Options))

From 38a263f097938022f49de3ad0dd87c7ddefca297 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Wed, 10 Jun 2020 15:25:22 -0600
Subject: [PATCH 30/48] foo

---
 llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
index f406eb40e16b0..007311fa393d6 100644
--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
@@ -2491,6 +2491,7 @@ Instruction *InstCombiner::visitSelectInst(SelectInst &SI) {
     return &SI;
   }
 
+  if (!DisableWrongOptimizations) {
   if (SelType->isIntOrIntVectorTy(1) &&
       TrueVal->getType() == CondVal->getType()) {
     if (match(TrueVal, m_One())) {
@@ -2555,6 +2556,7 @@ Instruction *InstCombiner::visitSelectInst(SelectInst &SI) {
       return new SExtInst(NotCond, SelType);
     }
   }
+  } // fi !DisableWrongOptimizations
 
   // See if we are selecting two values based on a comparison of the two values.
   if (FCmpInst *FCI = dyn_cast<FCmpInst>(CondVal)) {

From 8c67be1e3cb4ca6dc5fd3ade606049212aaac1ea Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Wed, 10 Jun 2020 19:10:13 -0600
Subject: [PATCH 31/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp             | 1 +
 llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index efc390f65a2b3..1d69edcb15776 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -44,6 +44,7 @@ using namespace llvm;
 using namespace llvm::PatternMatch;
 
 bool DisablePeepholes = false;
+bool DisableWrongOptimizations = false;
 
 // "true" for 2nd template argument means use external storage
 static cl::opt<bool, true>
diff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
index 007311fa393d6..2d7261e493585 100644
--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
@@ -41,6 +41,8 @@
 #include <cassert>
 #include <utility>
 
+extern bool DisableWrongOptimizations;
+
 using namespace llvm;
 using namespace PatternMatch;
 

From de3390e2466936598cb0b5bd548b129e259b2660 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Wed, 10 Jun 2020 22:16:43 -0600
Subject: [PATCH 32/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp |  2 +-
 test-disable-peepholes.sh                 | 20 ++++++--------------
 2 files changed, 7 insertions(+), 15 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 1d69edcb15776..8a599cca56984 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -43,7 +43,7 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
-bool DisablePeepholes = false;
+bool DisablePeepholes = DISABLE_PEEPHOLES_DEFAULT_VALUE;
 bool DisableWrongOptimizations = false;
 
 // "true" for 2nd template argument means use external storage
From 08fd60947fe4ba5753dc2c110f0728e50451f897 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Fri, 12 Jun 2020 14:46:41 -0600
Subject: [PATCH 33/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp |  2 +-
 test-disable-peepholes.sh                 | 14 +++++++++++++-
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 8a599cca56984..2c3809558e377 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -44,7 +44,7 @@ using namespace llvm;
 using namespace llvm::PatternMatch;
 
 bool DisablePeepholes = DISABLE_PEEPHOLES_DEFAULT_VALUE;
-bool DisableWrongOptimizations = false;
+bool DisableWrongOptimizations = DISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE;
 
 // "true" for 2nd template argument means use external storage
 static cl::opt<bool, true>
From e0f4582bf91f58087501b97e868e40068e2d8b41 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 25 Jun 2020 08:05:47 -0600
Subject: [PATCH 35/48] foo

---
 llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
index e0974730feda8..61c583e9a6373 100644
--- a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
+++ b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
@@ -57,7 +57,7 @@
 #include <numeric>
 #include <utility>
 
-extern bool DisablePeepholes;
+extern bool DisableWrongOptimizations;
 
 #define DEBUG_TYPE "simple-loop-unswitch"
 
@@ -2884,7 +2884,7 @@ static bool unswitchLoop(Loop &L, DominatorTree &DT, LoopInfo &LI,
 PreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &U) {
-  if (DisablePeepholes) {
+  if (DisableWrongOptimizations) {
     PreservedAnalyses PA1;
     return PA1;
   }
@@ -2966,7 +2966,7 @@ class SimpleLoopUnswitchLegacyPass : public LoopPass {
 } // end anonymous namespace
 
 bool SimpleLoopUnswitchLegacyPass::runOnLoop(Loop *L, LPPassManager &LPM) {
-  if (DisablePeepholes)
+  if (DisableWrongOptimizations)
     return false;
 
   if (skipLoop(L))

From b68b0b5ae2efdc26a0079a6d9b372684bdafc646 Mon Sep 17 00:00:00 2001
From: John Regehr <regehr@cs.utah.edu>
Date: Thu, 25 Jun 2020 08:31:36 -0600
Subject: [PATCH 36/48] foo

---
 llvm/lib/Analysis/InstructionSimplify.cpp | 6 ++++++
 test-disable-peepholes.sh                 | 7 +------
 2 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index 107c0a632e28b..18a58726046b4 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -38,6 +38,7 @@
 #include "llvm/IR/Operator.h"
 #include "llvm/IR/PatternMatch.h"
 #include "llvm/IR/ValueHandle.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/KnownBits.h"
 #include <algorithm>
 using namespace llvm;
@@ -52,6 +53,11 @@ DisablePeepholesOption("disable-all-peepholes",
                        cl::desc("Don't perform peephole optimizations"),
                        cl::location(DisablePeepholes));
 
+static cl::opt<bool, true>
+DisableWrongOptsOption("disable-wrongs-opts",
+                       cl::desc("Disable optimizations that may increase the amount of undefined behavior"),
+                       cl::location(DisableWrongOptimizations));
+
 #define DEBUG_TYPE "instsimplify"
 
 enum { RecursionLimit = 3 };
