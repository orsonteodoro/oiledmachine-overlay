The header license of many of these files:

// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

The original .diff patch can be obtained from:
https://github.com/regehr/llvm-project/compare/072c90a863aac1334a4950b3da262a025516dea0...disable-peepholes-v07.diff

For commit history details see:
https://github.com/regehr/llvm-project/compare/072c90a863aac1334a4950b3da262a025516dea0...disable-peepholes-v07

Additional notes:
The patch generated by the .diff URI differs from .patch URI.

oteodoro changes:
The default.cfg and test-spec.sh for benchmarking have been dropped.
The test-disable-peepholes.sh has been dropped since the tests are just running the usual test suite and grepping stderr/stdout for "Failed Tests".
Removed TM names from souper-scripts/README.txt

----

diff --git a/llvm/include/llvm/Transforms/Scalar/DCE.h b/llvm/include/llvm/Transforms/Scalar/DCE.h
index 4d83296b1d862..b02358ac5e43d 100644
--- a/llvm/include/llvm/Transforms/Scalar/DCE.h
+++ b/llvm/include/llvm/Transforms/Scalar/DCE.h
@@ -13,9 +13,12 @@
 #ifndef LLVM_TRANSFORMS_SCALAR_DCE_H
 #define LLVM_TRANSFORMS_SCALAR_DCE_H
 
+#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/PassManager.h"
 
+bool eliminateDeadCode(llvm::Function &F, llvm::TargetLibraryInfo *TLI);
+
 namespace llvm {
 
 /// Basic Dead Code Elimination pass.
diff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp
index c40e5c36cdc7c..fb20360d7639b 100644
--- a/llvm/lib/Analysis/InstructionSimplify.cpp
+++ b/llvm/lib/Analysis/InstructionSimplify.cpp
@@ -38,11 +38,26 @@
 #include "llvm/IR/Operator.h"
 #include "llvm/IR/PatternMatch.h"
 #include "llvm/IR/ValueHandle.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/KnownBits.h"
 #include <algorithm>
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+bool DisablePeepholes = DISABLE_PEEPHOLES_DEFAULT_VALUE;
+bool DisableWrongOptimizations = DISABLE_WRONG_OPTIMIZATIONS_DEFAULT_VALUE;
+
+// "true" for 2nd template argument means use external storage
+static cl::opt<bool, true>
+DisablePeepholesOption("disable-all-peepholes",
+                       cl::desc("Don't perform peephole optimizations"),
+                       cl::location(DisablePeepholes));
+
+static cl::opt<bool, true>
+DisableWrongOptsOption("disable-wrongs-opts",
+                       cl::desc("Disable optimizations that may increase the amount of undefined behavior"),
+                       cl::location(DisableWrongOptimizations));
+
 #define DEBUG_TYPE "instsimplify"
 
 enum { RecursionLimit = 3 };
@@ -71,6 +86,9 @@ static Value *SimplifyGEPInst(Type *, ArrayRef<Value *>, const SimplifyQuery &,
 
 static Value *foldSelectWithBinaryOp(Value *Cond, Value *TrueVal,
                                      Value *FalseVal) {
+  if (DisablePeepholes)
+    return nullptr;
+
   BinaryOperator::BinaryOps BinOpCode;
   if (auto *BO = dyn_cast<BinaryOperator>(Cond))
     BinOpCode = BO->getOpcode();
@@ -126,6 +144,9 @@ static Constant *getTrue(Type *Ty) {
 /// isSameCompare - Is V equivalent to the comparison "LHS Pred RHS"?
 static bool isSameCompare(Value *V, CmpInst::Predicate Pred, Value *LHS,
                           Value *RHS) {
+  if (DisablePeepholes)
+    return false;
+
   CmpInst *Cmp = dyn_cast<CmpInst>(V);
   if (!Cmp)
     return false;
@@ -182,6 +203,9 @@ static Value *handleOtherCmpSelSimplifications(Value *TCmp, Value *FCmp,
                                                Value *Cond,
                                                const SimplifyQuery &Q,
                                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the false value simplified to false, then the result of the compare
   // is equal to "Cond && TCmp".  This also catches the case when the false
   // value simplified to false and the true value to true, returning "Cond".
@@ -234,6 +258,9 @@ static bool valueDominatesPHI(Value *V, PHINode *P, const DominatorTree *DT) {
 static Value *expandBinOp(Instruction::BinaryOps Opcode, Value *V,
                           Value *OtherOp, Instruction::BinaryOps OpcodeToExpand,
                           const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   auto *B = dyn_cast<BinaryOperator>(V);
   if (!B || B->getOpcode() != OpcodeToExpand)
     return nullptr;
@@ -270,6 +297,9 @@ static Value *expandCommutativeBinOp(Instruction::BinaryOps Opcode,
                                      Instruction::BinaryOps OpcodeToExpand,
                                      const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -287,6 +317,9 @@ static Value *SimplifyAssociativeBinOp(Instruction::BinaryOps Opcode,
                                        Value *LHS, Value *RHS,
                                        const SimplifyQuery &Q,
                                        unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(Instruction::isAssociative(Opcode) && "Not an associative operation!");
 
   // Recursion is always used, so bail out at once if we already hit the limit.
@@ -386,6 +419,9 @@ static Value *SimplifyAssociativeBinOp(Instruction::BinaryOps Opcode,
 static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -464,6 +500,9 @@ static Value *ThreadBinOpOverSelect(Instruction::BinaryOps Opcode, Value *LHS,
 static Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q,
                                   unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -510,6 +549,9 @@ static Value *ThreadCmpOverSelect(CmpInst::Predicate Pred, Value *LHS,
 static Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,
                                  Value *RHS, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -552,6 +594,9 @@ static Value *ThreadBinOpOverPHI(Instruction::BinaryOps Opcode, Value *LHS,
 /// otherwise returns null.
 static Value *ThreadCmpOverPHI(CmpInst::Predicate Pred, Value *LHS, Value *RHS,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return nullptr;
@@ -611,6 +656,9 @@ static Value *SimplifyAddInst(Value *Op0, Value *Op1, bool IsNSW, bool IsNUW,
   if (Constant *C = foldOrCommuteConstant(Instruction::Add, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X + undef -> undef
   if (Q.isUndefValue(Op1))
     return Op1;
@@ -708,6 +756,9 @@ static Constant *stripAndComputeConstantOffsets(const DataLayout &DL, Value *&V,
 /// If the difference is not a constant, returns zero.
 static Constant *computePointerDifference(const DataLayout &DL, Value *LHS,
                                           Value *RHS) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Constant *LHSOffset = stripAndComputeConstantOffsets(DL, LHS);
   Constant *RHSOffset = stripAndComputeConstantOffsets(DL, RHS);
 
@@ -730,6 +781,9 @@ static Value *SimplifySubInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
   if (Constant *C = foldOrCommuteConstant(Instruction::Sub, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X - undef -> undef
   // undef - X -> undef
   if (Q.isUndefValue(Op0) || Q.isUndefValue(Op1))
@@ -865,6 +919,9 @@ static Value *SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::Mul, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X * undef -> 0
   // X * 0 -> 0
   if (Q.isUndefValue(Op1) || match(Op1, m_Zero()))
@@ -922,6 +979,9 @@ Value *llvm::SimplifyMulInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// This applies to all 4 opcodes (sdiv/udiv/srem/urem).
 static Value *simplifyDivRem(Value *Op0, Value *Op1, bool IsDiv,
                              const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *Ty = Op0->getType();
 
   // X / undef -> poison
@@ -990,6 +1050,9 @@ static bool isICmpTrue(ICmpInst::Predicate Pred, Value *LHS, Value *RHS,
 /// to simplify X % Y to X.
 static bool isDivZero(Value *X, Value *Y, const SimplifyQuery &Q,
                       unsigned MaxRecurse, bool IsSigned) {
+  if (DisablePeepholes)
+    return false;
+
   // Recursion is always used, so bail out at once if we already hit the limit.
   if (!MaxRecurse--)
     return false;
@@ -1044,6 +1107,9 @@ static Value *simplifyDiv(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Op0, Op1, true, Q))
     return V;
 
@@ -1102,6 +1168,9 @@ static Value *simplifyRem(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = simplifyDivRem(Op0, Op1, false, Q))
     return V;
 
@@ -1143,6 +1212,9 @@ static Value *simplifyRem(Instruction::BinaryOps Opcode, Value *Op0, Value *Op1,
 /// If not, this returns null.
 static Value *SimplifySDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If two operands are negated and no signed overflow, return -1.
   if (isKnownNegation(Op0, Op1, /*NeedNSW=*/true))
     return Constant::getAllOnesValue(Op0->getType());
@@ -1169,6 +1241,9 @@ Value *llvm::SimplifyUDivInst(Value *Op0, Value *Op1, const SimplifyQuery &Q) {
 /// If not, this returns null.
 static Value *SimplifySRemInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
                                unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the divisor is 0, the result is undefined, so assume the divisor is -1.
   // srem Op0, (sext i1 X) --> srem Op0, -1 --> 0
   Value *X;
@@ -1233,6 +1308,9 @@ static Value *SimplifyShift(Instruction::BinaryOps Opcode, Value *Op0,
   if (Constant *C = foldOrCommuteConstant(Opcode, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // 0 shift by X -> 0
   if (match(Op0, m_Zero()))
     return Constant::getNullValue(Op0->getType());
@@ -1281,6 +1359,9 @@ static Value *SimplifyShift(Instruction::BinaryOps Opcode, Value *Op0,
 static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
                                  Value *Op1, bool isExact, const SimplifyQuery &Q,
                                  unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyShift(Opcode, Op0, Op1, Q, MaxRecurse))
     return V;
 
@@ -1307,6 +1388,9 @@ static Value *SimplifyRightShift(Instruction::BinaryOps Opcode, Value *Op0,
 /// If not, this returns null.
 static Value *SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyShift(Instruction::Shl, Op0, Op1, Q, MaxRecurse))
     return V;
 
@@ -1339,6 +1423,9 @@ Value *llvm::SimplifyShlInst(Value *Op0, Value *Op1, bool isNSW, bool isNUW,
 /// If not, this returns null.
 static Value *SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::LShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
       return V;
@@ -1377,6 +1464,9 @@ Value *llvm::SimplifyLShrInst(Value *Op0, Value *Op1, bool isExact,
 /// If not, this returns null.
 static Value *SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
                                const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *V = SimplifyRightShift(Instruction::AShr, Op0, Op1, isExact, Q,
                                     MaxRecurse))
     return V;
@@ -1409,6 +1499,9 @@ Value *llvm::SimplifyAShrInst(Value *Op0, Value *Op1, bool isExact,
 static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
                                          ICmpInst *UnsignedICmp, bool IsAnd,
                                          const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X, *Y;
 
   ICmpInst::Predicate EqPred;
@@ -1517,6 +1610,9 @@ static Value *simplifyUnsignedRangeCheck(ICmpInst *ZeroICmp,
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1542,6 +1638,9 @@ static Value *simplifyAndOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
 /// Commuted variants are assumed to be handled by calling this function again
 /// with the parameters swapped.
 static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred0, Pred1;
   Value *A ,*B;
   if (!match(Op0, m_ICmp(Pred0, m_Value(A), m_Value(B))) ||
@@ -1570,6 +1669,9 @@ static Value *simplifyOrOfICmpsWithSameOperands(ICmpInst *Op0, ICmpInst *Op1) {
 /// the other.
 static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                 bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look for this pattern: {and/or} (icmp X, C0), (icmp X, C1)).
   if (Cmp0->getOperand(0) != Cmp1->getOperand(0))
     return nullptr;
@@ -1607,6 +1709,9 @@ static Value *simplifyAndOrOfICmpsWithConstants(ICmpInst *Cmp0, ICmpInst *Cmp1,
 
 static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                            bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate P0 = Cmp0->getPredicate(), P1 = Cmp1->getPredicate();
   if (!match(Cmp0->getOperand(1), m_Zero()) ||
       !match(Cmp1->getOperand(1), m_Zero()) || P0 != P1)
@@ -1644,6 +1749,9 @@ static Value *simplifyAndOrOfICmpsWithZero(ICmpInst *Cmp0, ICmpInst *Cmp1,
 
 static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                         const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) & (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1692,6 +1800,9 @@ static Value *simplifyAndOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
 /// Try to eliminate compares with signed or unsigned min/max constants.
 static Value *simplifyAndOrOfICmpsWithLimitConst(ICmpInst *Cmp0, ICmpInst *Cmp1,
                                                  bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Canonicalize an equality compare as Cmp0.
   if (Cmp1->isEquality())
     std::swap(Cmp0, Cmp1);
@@ -1751,6 +1862,9 @@ static Value *simplifyAndOrOfICmpsWithLimitConst(ICmpInst *Cmp0, ICmpInst *Cmp1,
 
 static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                  const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/true, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/true, Q))
@@ -1780,6 +1894,9 @@ static Value *simplifyAndOfICmps(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
                                        const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // (icmp (add V, C0), C1) | (icmp V, C0)
   ICmpInst::Predicate Pred0, Pred1;
   const APInt *C0, *C1;
@@ -1827,6 +1944,9 @@ static Value *simplifyOrOfICmpsWithAdd(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
                                 const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Value *X = simplifyUnsignedRangeCheck(Op0, Op1, /*IsAnd=*/false, Q))
     return X;
   if (Value *X = simplifyUnsignedRangeCheck(Op1, Op0, /*IsAnd=*/false, Q))
@@ -1856,6 +1976,9 @@ static Value *simplifyOrOfICmps(ICmpInst *Op0, ICmpInst *Op1,
 
 static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
                                    FCmpInst *LHS, FCmpInst *RHS, bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);
   Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);
   if (LHS0->getType() != RHS0->getType())
@@ -1894,6 +2017,9 @@ static Value *simplifyAndOrOfFCmps(const TargetLibraryInfo *TLI,
 
 static Value *simplifyAndOrOfCmps(const SimplifyQuery &Q,
                                   Value *Op0, Value *Op1, bool IsAnd) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Look through casts of the 'and' operands to find compares.
   auto *Cast0 = dyn_cast<CastInst>(Op0);
   auto *Cast1 = dyn_cast<CastInst>(Op1);
@@ -1959,6 +2085,9 @@ static bool omitCheckForZeroBeforeMulWithOverflowInternal(Value *Op1,
 ///   %??? = and i1 %Op0, %Op1
 /// We can just return  %Op1
 static Value *omitCheckForZeroBeforeMulWithOverflow(Value *Op0, Value *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *X;
   if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||
@@ -1983,6 +2112,9 @@ static Value *omitCheckForZeroBeforeMulWithOverflow(Value *Op0, Value *Op1) {
 /// We can just return  %NotOp1
 static Value *omitCheckForZeroBeforeInvertedMulWithOverflow(Value *Op0,
                                                             Value *NotOp1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *X;
   if (!match(Op0, m_ICmp(Pred, m_Value(X), m_Zero())) ||
@@ -2003,6 +2135,9 @@ static Value *omitCheckForZeroBeforeInvertedMulWithOverflow(Value *Op0,
 /// source value and inverted constant (identity: C - X -> ~(X + ~C)).
 static Value *simplifyLogicOfAddSub(Value *Op0, Value *Op1,
                                     Instruction::BinaryOps Opcode) {
+  if (DisablePeepholes)
+    return nullptr;
+
   assert(Op0->getType() == Op1->getType() && "Mismatched binop types");
   assert(BinaryOperator::isBitwiseLogicOp(Opcode) && "Expected logic op");
   Value *X;
@@ -2030,6 +2165,9 @@ static Value *SimplifyAndInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::And, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X & undef -> 0
   if (Q.isUndefValue(Op1))
     return Constant::getNullValue(Op0->getType());
@@ -2198,6 +2336,9 @@ static Value *SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // X | undef -> -1
   // X | -1 = -1
   // Do not return Op1 because it may contain undef elements if it's a vector.
@@ -2374,6 +2515,9 @@ static Value *SimplifyXorInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,
   if (Constant *C = foldOrCommuteConstant(Instruction::Xor, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // A ^ undef -> undef
   if (Q.isUndefValue(Op1))
     return Op1;
@@ -2425,6 +2569,9 @@ static Type *GetCompareTy(Value *Op) {
 /// Helper function for analyzing max/min idioms.
 static Value *ExtractEquivalentCondition(Value *V, CmpInst::Predicate Pred,
                                          Value *LHS, Value *RHS) {
+  if (DisablePeepholes)
+    return nullptr;
+
   SelectInst *SI = dyn_cast<SelectInst>(V);
   if (!SI)
     return nullptr;
@@ -2473,6 +2620,9 @@ computePointerICmp(const DataLayout &DL, const TargetLibraryInfo *TLI,
                    const DominatorTree *DT, CmpInst::Predicate Pred,
                    AssumptionCache *AC, const Instruction *CxtI,
                    const InstrInfoQuery &IIQ, Value *LHS, Value *RHS) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // First, skip past any trivial no-ops.
   LHS = LHS->stripPointerCasts();
   RHS = RHS->stripPointerCasts();
@@ -2657,6 +2807,9 @@ computePointerICmp(const DataLayout &DL, const TargetLibraryInfo *TLI,
 /// Fold an icmp when its operands have i1 scalar type.
 static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
                                   Value *RHS, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Type *OpTy = LHS->getType();   // The operand type.
   if (!OpTy->isIntOrIntVectorTy(1))
@@ -2731,6 +2884,9 @@ static Value *simplifyICmpOfBools(CmpInst::Predicate Pred, Value *LHS,
 /// Try hard to fold icmp with zero RHS because this is a common case.
 static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
                                    Value *RHS, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!match(RHS, m_Zero()))
     return nullptr;
 
@@ -2793,6 +2949,9 @@ static Value *simplifyICmpWithZero(CmpInst::Predicate Pred, Value *LHS,
 
 static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
                                        Value *RHS, const InstrInfoQuery &IIQ) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *X;
@@ -2842,6 +3001,9 @@ static Value *simplifyICmpWithConstant(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithBinOpOnLHS(
     CmpInst::Predicate Pred, BinaryOperator *LBO, Value *RHS,
     const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(RHS); // The return type.
 
   Value *Y = nullptr;
@@ -2986,6 +3148,9 @@ static bool trySimplifyICmpWithAdds(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
                                     Value *RHS, const SimplifyQuery &Q,
                                     unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   BinaryOperator *LBO = dyn_cast<BinaryOperator>(LHS);
   BinaryOperator *RBO = dyn_cast<BinaryOperator>(RHS);
   if (MaxRecurse && (LBO || RBO)) {
@@ -3170,6 +3335,9 @@ static Value *simplifyICmpWithBinOp(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
                                      Value *RHS, const SimplifyQuery &Q,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
   Value *A, *B;
   CmpInst::Predicate P = CmpInst::BAD_ICMP_PREDICATE;
@@ -3355,6 +3523,9 @@ static Value *simplifyICmpWithMinMax(CmpInst::Predicate Pred, Value *LHS,
 static Value *simplifyICmpWithDominatingAssume(CmpInst::Predicate Predicate,
                                                Value *LHS, Value *RHS,
                                                const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Gracefully handle instructions that have not been inserted yet.
   if (!Q.AC || !Q.CxtI || !Q.CxtI->getParent())
     return nullptr;
@@ -3393,6 +3564,9 @@ static Value *SimplifyICmpInst(unsigned Predicate, Value *LHS, Value *RHS,
   }
   assert(!isa<UndefValue>(LHS) && "Unexpected icmp undef,%X");
 
+  if (DisablePeepholes)
+    return nullptr;
+
   Type *ITy = GetCompareTy(LHS); // The return type.
 
   // For EQ and NE, we can always pick a value for the undef to make the
@@ -3704,11 +3878,17 @@ static Value *SimplifyFCmpInst(unsigned Predicate, Value *LHS, Value *RHS,
     if (Constant *CRHS = dyn_cast<Constant>(RHS))
       return ConstantFoldCompareInstOperands(Pred, CLHS, CRHS, Q.DL, Q.TLI);
 
+    if (DisablePeepholes)
+      return nullptr;
+
     // If we have a constant, make sure it is on the RHS.
     std::swap(LHS, RHS);
     Pred = CmpInst::getSwappedPredicate(Pred);
   }
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Fold trivial predicates.
   Type *RetTy = GetCompareTy(LHS);
   if (Pred == FCmpInst::FCMP_FALSE)
@@ -3900,6 +4080,9 @@ static Value *SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,
                                      const SimplifyQuery &Q,
                                      bool AllowRefinement,
                                      unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Trivial replacement.
   if (V == Op)
     return RepOp;
@@ -4019,6 +4202,9 @@ Value *llvm::SimplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,
 /// integer comparison where one operand of the compare is a constant.
 static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
                                     const APInt *Y, bool TrueWhenUnset) {
+  if (DisablePeepholes)
+    return nullptr;
+
   const APInt *C;
 
   // (X & Y) == 0 ? X & ~Y : X  --> X
@@ -4055,6 +4241,9 @@ static Value *simplifySelectBitTest(Value *TrueVal, Value *FalseVal, Value *X,
 static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
                                            ICmpInst::Predicate Pred,
                                            Value *TrueVal, Value *FalseVal) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   APInt Mask;
   if (!decomposeBitTestICmp(CmpLHS, CmpRHS, Pred, X, Mask))
@@ -4069,6 +4258,9 @@ static Value *simplifySelectWithFakeICmpEq(Value *CmpLHS, Value *CmpRHS,
 static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
                                          Value *FalseVal, const SimplifyQuery &Q,
                                          unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   ICmpInst::Predicate Pred;
   Value *CmpLHS, *CmpRHS;
   if (!match(CondVal, m_ICmp(Pred, m_Value(CmpLHS), m_Value(CmpRHS))))
@@ -4154,6 +4346,9 @@ static Value *simplifySelectWithICmpCond(Value *CondVal, Value *TrueVal,
 /// floating-point comparison.
 static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
                                      const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   FCmpInst::Predicate Pred;
   if (!match(Cond, m_FCmp(Pred, m_Specific(T), m_Specific(F))) &&
       !match(Cond, m_FCmp(Pred, m_Specific(F), m_Specific(T))))
@@ -4185,6 +4380,9 @@ static Value *simplifySelectWithFCmp(Value *Cond, Value *T, Value *F,
 /// If not, this returns null.
 static Value *SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
                                  const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CondC = dyn_cast<Constant>(Cond)) {
     if (auto *TrueC = dyn_cast<Constant>(TrueVal))
       if (auto *FalseC = dyn_cast<Constant>(FalseVal))
@@ -4286,6 +4484,9 @@ Value *llvm::SimplifySelectInst(Value *Cond, Value *TrueVal, Value *FalseVal,
 /// If not, this returns null.
 static Value *SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
                               const SimplifyQuery &Q, unsigned) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // The type of the GEP pointer operand.
   unsigned AS =
       cast<PointerType>(Ops[0]->getType()->getScalarType())->getAddressSpace();
@@ -4419,6 +4620,9 @@ Value *llvm::SimplifyGEPInst(Type *SrcTy, ArrayRef<Value *> Ops,
 static Value *SimplifyInsertValueInst(Value *Agg, Value *Val,
                                       ArrayRef<unsigned> Idxs, const SimplifyQuery &Q,
                                       unsigned) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *CAgg = dyn_cast<Constant>(Agg))
     if (Constant *CVal = dyn_cast<Constant>(Val))
       return ConstantFoldInsertValueInstruction(CAgg, CVal, Idxs);
@@ -4458,6 +4662,9 @@ Value *llvm::SimplifyInsertElementInst(Value *Vec, Value *Val, Value *Idx,
   if (VecC && ValC && IdxC)
     return ConstantExpr::getInsertElement(VecC, ValC, IdxC);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // For fixed-length vector, fold into poison if index is out of bounds.
   if (auto *CI = dyn_cast<ConstantInt>(Idx)) {
     if (isa<FixedVectorType>(Vec->getType()) &&
@@ -4491,6 +4698,9 @@ static Value *SimplifyExtractValueInst(Value *Agg, ArrayRef<unsigned> Idxs,
   if (auto *CAgg = dyn_cast<Constant>(Agg))
     return ConstantFoldExtractValueInstruction(CAgg, Idxs);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // extractvalue x, (insertvalue y, elt, n), n -> elt
   unsigned NumIdxs = Idxs.size();
   for (auto *IVI = dyn_cast<InsertValueInst>(Agg); IVI != nullptr;
@@ -4523,6 +4733,9 @@ static Value *SimplifyExtractElementInst(Value *Vec, Value *Idx,
     if (auto *CIdx = dyn_cast<Constant>(Idx))
       return ConstantExpr::getExtractElement(CVec, CIdx);
 
+    if (DisablePeepholes)
+      return nullptr;
+
     // The index is not relevant if our vector is a splat.
     if (auto *Splat = CVec->getSplatValue())
       return Splat;
@@ -4531,6 +4744,9 @@ static Value *SimplifyExtractElementInst(Value *Vec, Value *Idx,
       return UndefValue::get(VecVTy->getElementType());
   }
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // If extracting a specified index from the vector, see if we can recursively
   // find a previously computed scalar that was inserted into the vector.
   if (auto *IdxC = dyn_cast<ConstantInt>(Idx)) {
@@ -4557,6 +4773,8 @@ Value *llvm::SimplifyExtractElementInst(Value *Vec, Value *Idx,
 
 /// See if we can fold the given phi. If not, returns null.
 static Value *SimplifyPHINode(PHINode *PN, const SimplifyQuery &Q) {
+  // JDR: can't disable this w/o breaking the compiler
+
   // WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE
   //          here, because the PHI we may succeed simplifying to was not
   //          def-reachable from the original PHI!
@@ -4597,6 +4815,9 @@ static Value *SimplifyCastInst(unsigned CastOpc, Value *Op,
   if (auto *C = dyn_cast<Constant>(Op))
     return ConstantFoldCastOperand(CastOpc, C, Ty, Q.DL);
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (auto *CI = dyn_cast<CastInst>(Op)) {
     auto *Src = CI->getOperand(0);
     Type *SrcTy = Src->getType();
@@ -4637,6 +4858,9 @@ Value *llvm::SimplifyCastInst(unsigned CastOpc, Value *Op, Type *Ty,
 static Value *foldIdentityShuffles(int DestElt, Value *Op0, Value *Op1,
                                    int MaskVal, Value *RootVec,
                                    unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (!MaxRecurse--)
     return nullptr;
 
@@ -4686,6 +4910,9 @@ static Value *SimplifyShuffleVectorInst(Value *Op0, Value *Op1,
                                         ArrayRef<int> Mask, Type *RetTy,
                                         const SimplifyQuery &Q,
                                         unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (all_of(Mask, [](int Elem) { return Elem == UndefMaskElem; }))
     return UndefValue::get(RetTy);
 
@@ -4818,6 +5045,9 @@ static Value *simplifyFNegInst(Value *Op, FastMathFlags FMF,
   if (Constant *C = foldConstant(Instruction::FNeg, Op, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X;
   // fneg (fneg X) ==> X
   if (match(Op, m_FNeg(m_Value(X))))
@@ -4832,6 +5062,9 @@ Value *llvm::SimplifyFNegInst(Value *Op, FastMathFlags FMF,
 }
 
 static Constant *propagateNaN(Constant *In) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // If the input is a vector with undef elements, just return a default NaN.
   if (!In->isNaN())
     return ConstantFP::getNaN(In->getType());
@@ -4847,6 +5080,9 @@ static Constant *propagateNaN(Constant *In) {
 static Constant *simplifyFPOp(ArrayRef<Value *> Ops,
                               FastMathFlags FMF,
                               const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   for (Value *V : Ops) {
     bool IsNan = match(V, m_NaN());
     bool IsInf = match(V, m_Inf());
@@ -4873,6 +5109,9 @@ static Value *SimplifyFAddInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FAdd, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))
     return C;
 
@@ -4920,6 +5159,9 @@ static Value *SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FSub, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))
     return C;
 
@@ -4962,6 +5204,9 @@ static Value *SimplifyFSubInst(Value *Op0, Value *Op1, FastMathFlags FMF,
 
 static Value *SimplifyFMAFMul(Value *Op0, Value *Op1, FastMathFlags FMF,
                               const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))
     return C;
 
@@ -4999,6 +5244,9 @@ static Value *SimplifyFMulInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FMul, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Now apply simplifications that do not require rounding.
   return SimplifyFMAFMul(Op0, Op1, FMF, Q, MaxRecurse);
 }
@@ -5029,6 +5277,9 @@ static Value *SimplifyFDivInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FDiv, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))
     return C;
 
@@ -5074,6 +5325,9 @@ static Value *SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,
   if (Constant *C = foldOrCommuteConstant(Instruction::FRem, Op0, Op1, Q))
     return C;
 
+  if (DisablePeepholes)
+    return nullptr;
+
   if (Constant *C = simplifyFPOp({Op0, Op1}, FMF, Q))
     return C;
 
@@ -5103,6 +5357,9 @@ Value *llvm::SimplifyFRemInst(Value *Op0, Value *Op1, FastMathFlags FMF,
 /// If not, this returns null.
 static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
                            unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FastMathFlags(), Q, MaxRecurse);
@@ -5117,6 +5374,9 @@ static Value *simplifyUnOp(unsigned Opcode, Value *Op, const SimplifyQuery &Q,
 static Value *simplifyFPUnOp(unsigned Opcode, Value *Op,
                              const FastMathFlags &FMF,
                              const SimplifyQuery &Q, unsigned MaxRecurse) {
+  if (DisablePeepholes)
+    return nullptr;
+
   switch (Opcode) {
   case Instruction::FNeg:
     return simplifyFNegInst(Op, FMF, Q, MaxRecurse);
@@ -5243,6 +5503,9 @@ static bool IsIdempotent(Intrinsic::ID ID) {
 
 static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
                                    const DataLayout &DL) {
+  if (DisablePeepholes)
+    return nullptr;
+
   GlobalValue *PtrSym;
   APInt PtrOffset;
   if (!IsConstantOffsetFromGlobal(Ptr, PtrSym, PtrOffset, DL))
@@ -5299,6 +5562,9 @@ static Value *SimplifyRelativeLoad(Constant *Ptr, Constant *Offset,
 
 static Value *simplifyUnaryIntrinsic(Function *F, Value *Op0,
                                      const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Idempotent functions return the same result when called repeatedly.
   Intrinsic::ID IID = F->getIntrinsicID();
   if (IsIdempotent(IID))
@@ -5414,6 +5680,9 @@ static ICmpInst::Predicate getMaxMinPredicate(Intrinsic::ID IID) {
 /// operand that is another min/max intrinsic with shared operand(s). The caller
 /// is expected to swap the operand arguments to handle commutation.
 static Value *foldMinMaxSharedOp(Intrinsic::ID IID, Value *Op0, Value *Op1) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Value *X, *Y;
   if (!match(Op0, m_MaxOrMin(m_Value(X), m_Value(Y))))
     return nullptr;
@@ -5437,6 +5706,9 @@ static Value *foldMinMaxSharedOp(Intrinsic::ID IID, Value *Op0, Value *Op1) {
 
 static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
                                       const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   Intrinsic::ID IID = F->getIntrinsicID();
   Type *ReturnType = F->getReturnType();
   unsigned BitWidth = ReturnType->getScalarSizeInBits();
@@ -5670,6 +5942,9 @@ static Value *simplifyBinaryIntrinsic(Function *F, Value *Op0, Value *Op1,
 
 static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 
+  if (DisablePeepholes)
+    return nullptr;
+
   // Intrinsics with no operands have some kind of side effect. Don't simplify.
   unsigned NumOperands = Call->getNumArgOperands();
   if (!NumOperands)
@@ -5732,6 +6007,9 @@ static Value *simplifyIntrinsic(CallBase *Call, const SimplifyQuery &Q) {
 }
 
 static Value *tryConstantFoldCall(CallBase *Call, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+  
   auto *F = dyn_cast<Function>(Call->getCalledOperand());
   if (!F || !canConstantFoldCallTo(Call, F))
     return nullptr;
@@ -5777,6 +6055,9 @@ Value *llvm::SimplifyCall(CallBase *Call, const SimplifyQuery &Q) {
 
 /// Given operands for a Freeze, see if we can fold the result.
 static Value *SimplifyFreezeInst(Value *Op0, const SimplifyQuery &Q) {
+  if (DisablePeepholes)
+    return nullptr;
+
   // Use a utility function defined in ValueTracking.
   if (llvm::isGuaranteedNotToBeUndefOrPoison(Op0, Q.AC, Q.CxtI, Q.DT))
     return Op0;
diff --git a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
index a7ae10d156d57..198912678df01 100644
--- a/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
+++ b/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp
@@ -35,6 +35,8 @@
 using namespace llvm;
 using namespace PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "aggressive-instcombine"
 
 STATISTIC(NumAnyOrAllBitsSet, "Number of any/all-bits-set patterns folded");
@@ -415,6 +417,9 @@ void AggressiveInstCombinerLegacyPass::getAnalysisUsage(
 }
 
 bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);
   auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
   return runImpl(F, TLI, DT);
@@ -422,6 +427,9 @@ bool AggressiveInstCombinerLegacyPass::runOnFunction(Function &F) {
 
 PreservedAnalyses AggressiveInstCombinePass::run(Function &F,
                                                  FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   if (!runImpl(F, TLI, DT)) {
diff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
index f26c194d31b9c..6824bed001e26 100644
--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
@@ -42,6 +42,8 @@
 #include <cassert>
 #include <utility>
 
+extern bool DisableWrongOptimizations;
+
 using namespace llvm;
 using namespace PatternMatch;
 
@@ -2587,6 +2589,7 @@ Instruction *InstCombinerImpl::visitSelectInst(SelectInst &SI) {
 
   CmpInst::Predicate Pred;
 
+  if (!DisableWrongOptimizations) {
   if (SelType->isIntOrIntVectorTy(1) &&
       TrueVal->getType() == CondVal->getType()) {
     if (match(TrueVal, m_One()) &&
@@ -2661,6 +2664,7 @@ Instruction *InstCombinerImpl::visitSelectInst(SelectInst &SI) {
       return new SExtInst(NotCond, SelType);
     }
   }
+  } // fi !DisableWrongOptimizations
 
   // See if we are selecting two values based on a comparison of the two values.
   if (FCmpInst *FCI = dyn_cast<FCmpInst>(CondVal)) {
diff --git a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
index 828fd49524ec1..509729d4021b1 100644
--- a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
@@ -112,6 +112,8 @@
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
+extern bool DisablePeepholes;
+
 #define DEBUG_TYPE "instcombine"
 
 STATISTIC(NumWorklistIterations,
@@ -4016,6 +4018,9 @@ InstCombinePass::InstCombinePass(unsigned MaxIterations)
 
 PreservedAnalyses InstCombinePass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto &AC = AM.getResult<AssumptionAnalysis>(F);
   auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
   auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);
@@ -4062,6 +4067,9 @@ void InstructionCombiningPass::getAnalysisUsage(AnalysisUsage &AU) const {
 }
 
 bool InstructionCombiningPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   if (skipFunction(F))
     return false;
 
diff --git a/llvm/lib/Transforms/Scalar/DCE.cpp b/llvm/lib/Transforms/Scalar/DCE.cpp
index d55adf7c2d126..6158aee2db2e3 100644
--- a/llvm/lib/Transforms/Scalar/DCE.cpp
+++ b/llvm/lib/Transforms/Scalar/DCE.cpp
@@ -18,7 +18,6 @@
 #include "llvm/Transforms/Scalar/DCE.h"
 #include "llvm/ADT/SetVector.h"
 #include "llvm/ADT/Statistic.h"
-#include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/InstIterator.h"
 #include "llvm/IR/Instruction.h"
 #include "llvm/InitializePasses.h"
@@ -119,29 +118,6 @@ static bool DCEInstruction(Instruction *I,
   return false;
 }
 
-static bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
-  bool MadeChange = false;
-  SmallSetVector<Instruction *, 16> WorkList;
-  // Iterate over the original function, only adding insts to the worklist
-  // if they actually need to be revisited. This avoids having to pre-init
-  // the worklist with the entire function's worth of instructions.
-  for (inst_iterator FI = inst_begin(F), FE = inst_end(F); FI != FE;) {
-    Instruction *I = &*FI;
-    ++FI;
-
-    // We're visiting this instruction now, so make sure it's not in the
-    // worklist from an earlier visit.
-    if (!WorkList.count(I))
-      MadeChange |= DCEInstruction(I, WorkList, TLI);
-  }
-
-  while (!WorkList.empty()) {
-    Instruction *I = WorkList.pop_back_val();
-    MadeChange |= DCEInstruction(I, WorkList, TLI);
-  }
-  return MadeChange;
-}
-
 PreservedAnalyses DCEPass::run(Function &F, FunctionAnalysisManager &AM) {
   if (!eliminateDeadCode(F, &AM.getResult<TargetLibraryAnalysis>(F)))
     return PreservedAnalyses::all();
@@ -181,3 +157,27 @@ INITIALIZE_PASS(DCELegacyPass, "dce", "Dead Code Elimination", false, false)
 FunctionPass *llvm::createDeadCodeEliminationPass() {
   return new DCELegacyPass();
 }
+
+bool eliminateDeadCode(Function &F, TargetLibraryInfo *TLI) {
+  bool MadeChange = false;
+  SmallSetVector<Instruction *, 16> WorkList;
+  // Iterate over the original function, only adding insts to the worklist
+  // if they actually need to be revisited. This avoids having to pre-init
+  // the worklist with the entire function's worth of instructions.
+  for (inst_iterator FI = inst_begin(F), FE = inst_end(F); FI != FE;) {
+    Instruction *I = &*FI;
+    ++FI;
+
+    // We're visiting this instruction now, so make sure it's not in the
+    // worklist from an earlier visit.
+    if (!WorkList.count(I))
+      MadeChange |= DCEInstruction(I, WorkList, TLI);
+  }
+
+  while (!WorkList.empty()) {
+    Instruction *I = WorkList.pop_back_val();
+    MadeChange |= DCEInstruction(I, WorkList, TLI);
+  }
+  return MadeChange;
+}
+
diff --git a/llvm/lib/Transforms/Scalar/NaryReassociate.cpp b/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
index 32bb62129e8fa..be2c8a2fbab6a 100644
--- a/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
+++ b/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
@@ -114,6 +114,8 @@ using namespace PatternMatch;
 
 #define DEBUG_TYPE "nary-reassociate"
 
+extern bool DisablePeepholes;
+
 namespace {
 
 class NaryReassociateLegacyPass : public FunctionPass {
@@ -165,6 +167,9 @@ FunctionPass *llvm::createNaryReassociatePass() {
 }
 
 bool NaryReassociateLegacyPass::runOnFunction(Function &F) {
+  if (DisablePeepholes)
+    return false;
+
   if (skipFunction(F))
     return false;
 
@@ -179,6 +184,9 @@ bool NaryReassociateLegacyPass::runOnFunction(Function &F) {
 
 PreservedAnalyses NaryReassociatePass::run(Function &F,
                                            FunctionAnalysisManager &AM) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   auto *AC = &AM.getResult<AssumptionAnalysis>(F);
   auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);
   auto *SE = &AM.getResult<ScalarEvolutionAnalysis>(F);
diff --git a/llvm/lib/Transforms/Scalar/Reassociate.cpp b/llvm/lib/Transforms/Scalar/Reassociate.cpp
index dffeb7cc227b4..0902b46cf93dd 100644
--- a/llvm/lib/Transforms/Scalar/Reassociate.cpp
+++ b/llvm/lib/Transforms/Scalar/Reassociate.cpp
@@ -86,6 +86,8 @@ static void PrintOps(Instruction *I, const SmallVectorImpl<ValueEntry> &Ops) {
 }
 #endif
 
+extern bool DisablePeepholes;
+
 /// Utility class representing a non-constant Xor-operand. We classify
 /// non-constant Xor-Operands into two categories:
 ///  C1) The operand is in the form "X & C", where C is a constant and C != ~0
@@ -2496,6 +2498,9 @@ ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {
 }
 
 PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {
+  if (DisablePeepholes)
+    return PreservedAnalyses::all();
+
   // Get the functions basic blocks in Reverse Post Order. This order is used by
   // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic
   // blocks (it has been seen that the analysis in this pass could hang when
@@ -2589,6 +2594,9 @@ namespace {
     }
 
     bool runOnFunction(Function &F) override {
+      if (DisablePeepholes)
+        return false;
+
       if (skipFunction(F))
         return false;
 
diff --git a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
index 9d3c8d0f3739a..e5be06b79f2fc 100644
--- a/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
+++ b/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
@@ -60,6 +60,8 @@
 #include <numeric>
 #include <utility>
 
+extern bool DisableWrongOptimizations;
+
 #define DEBUG_TYPE "simple-loop-unswitch"
 
 using namespace llvm;
@@ -2926,6 +2928,11 @@ static bool unswitchLoop(Loop &L, DominatorTree &DT, LoopInfo &LI,
 PreservedAnalyses SimpleLoopUnswitchPass::run(Loop &L, LoopAnalysisManager &AM,
                                               LoopStandardAnalysisResults &AR,
                                               LPMUpdater &U) {
+  if (DisableWrongOptimizations) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
+
   Function &F = *L.getHeader()->getParent();
   (void)F;
 
@@ -3003,6 +3010,9 @@ class SimpleLoopUnswitchLegacyPass : public LoopPass {
 } // end anonymous namespace
 
 bool SimpleLoopUnswitchLegacyPass::runOnLoop(Loop *L, LPPassManager &LPM) {
+  if (DisableWrongOptimizations)
+    return false;
+
   if (skipLoop(L))
     return false;
 
diff --git a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
index 38e7109ead57c..c0267914e1a80 100644
--- a/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
+++ b/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
@@ -49,6 +49,8 @@ using namespace llvm;
 
 #define DEBUG_TYPE "simplifycfg"
 
+extern bool DisablePeepholes;
+
 static cl::opt<unsigned> UserBonusInstThreshold(
     "bonus-inst-threshold", cl::Hidden, cl::init(1),
     cl::desc("Control the number of bonus instructions (default = 1)"));
@@ -304,6 +306,11 @@ SimplifyCFGPass::SimplifyCFGPass(const SimplifyCFGOptions &Opts)
 
 PreservedAnalyses SimplifyCFGPass::run(Function &F,
                                        FunctionAnalysisManager &AM) {
+  if (DisablePeepholes) {
+    PreservedAnalyses PA1;
+    return PA1;
+  }
+
   auto &TTI = AM.getResult<TargetIRAnalysis>(F);
   Options.AC = &AM.getResult<AssumptionAnalysis>(F);
   DominatorTree *DT = nullptr;
@@ -340,6 +347,9 @@ struct CFGSimplifyPass : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePeepholes)
+      return false;
+
     if (skipFunction(F) || (PredicateFtor && !PredicateFtor(F)))
       return false;
 
diff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
index 787f146bdddca..bb1d2586a5abb 100644
--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp
@@ -30,6 +30,8 @@
 #include "llvm/Transforms/Utils/Local.h"
 #include "llvm/Transforms/Vectorize.h"
 
+extern bool DisablePeepholes;
+
 using namespace llvm;
 using namespace llvm::PatternMatch;
 
@@ -813,6 +815,9 @@ class VectorCombineLegacyPass : public FunctionPass {
   }
 
   bool runOnFunction(Function &F) override {
+    if (DisablePeepholes)
+      return false;
+
     if (skipFunction(F))
       return false;
     auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);
diff --git a/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll b/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll
index f57f94bf03cec..cbf87ed5ecaa7 100644
--- a/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll
+++ b/llvm/test/CodeGen/Hexagon/swp-epilog-numphis.ll
@@ -1,4 +1,3 @@
-; XFAIL: *
 ; Needs some fixed in the pipeliner.
 ; RUN: llc -march=hexagon < %s -pipeliner-experimental-cg=true | FileCheck %s
 
diff --git a/souper-scripts/README.txt b/souper-scripts/README.txt
new file mode 100644
index 0000000000000..11b14c0a097a7
--- /dev/null
+++ b/souper-scripts/README.txt
@@ -0,0 +1,21 @@
+This directory contains scripts used to qualify a hacked LLVM before
+it is used by Souper.
+
+The LLVM is hacked to disable some unsound optimizations (that
+increase the amount of undefined behavior) and also to disable
+peephole optimizations that Souper competes with, in order to answer
+the research question "can Souper replace InstCombine and some of its
+friends."
+
+The strategy is to build three LLVMs:
+1. all peepholes and unsound optimizations enabled by default
+2. only unsound disabled by default
+3. both peepholes and unsound disabled by default
+
+Then to make sure that each of these can build a working LLVM that
+passes all of its tests, and to make sure that each can build
+benchmarks, and those pass all their test.					# oteodoro:  removed TM name
+
+TODO
+- also test debug builds?
+

