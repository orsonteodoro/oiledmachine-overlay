<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pkgmetadata SYSTEM "https://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
  <maintainer type="person">
    <!-- ebuild fork on the oiledmachine overlay -->
    <email>orsonteodoro@hotmail.com</email>
    <name>Orson Teodoro</name>
  </maintainer>
  <maintainer type="project">
    <!-- ebuild originator -->
    <email>llvm@gentoo.org</email>
  </maintainer>
  <longdescription>
    The oiledmachine overlay modifies these ebuilds for hardened support to
    ensure that packages built with clang/llvm are properly protected with the
    equivalent security defaults as its counterpart (Hardened GCC 10.3.0).

    Default ON doesn't necessarily mean hardcoded always ON.  If the package
    does not specify the option, the default ON value will be the one used
    so the flags below will be implied in use.

    Default ON patch status:
    present -- _FORITIFY_SOURCE=2
    testing --  -fstack-clash-protection (x86/x86_64 only)
    SSP canary is verified but strength is unverified --  -fstack-protector-strong
    unverified --param=ssp-buffer-size=4
    present -- -Wl,relro -Wl,now
    present -- PIE

    Secondary patches:
    testing -- -shared and fsanitize-cfi-cross-dso

    Verification is done via the app-admin/checksec package.

    When all testing switches to works for the Default ON set, then it is ready
    for production. To ensure Full RELRO is applied default ON set LD="${CC}" or
    LD="ld.lld", The lld package on this overlay has been modified for
    Full RELRO default ON.  However, packages may override the defaults if they
    are problematic or accidently lower the security level unintentionally, so
    you need to recheck the build log to be certain.

    While the toolchain-funcs.eclass only recognize hardened gcc existance
    in the ssp checking functions, you may verify a hardenedized counterpart
    though `clang --version` if using these patches from this overlay which
    also report the default ON hardened options.

    When using -stdlib=libc++, add -static-libstdc++ in front of it for a
    proper CFI build.


    PGO notes

    General steps:

      1. Bootstrap the llvm toolchain using the system compiler
      2. Build an instrumented build.
      3. Train with real world examples such as emerging a sample of world,
         compile shaders, compile WASM (aka HTML5 games)
      4. Build an optimized build


    BOLT notes

    BOLT optimized builds require specific CPUs with LBR support in its current
    form.

    To optimize for BOLT, use the same steps as PGO and the ebuild
    will automatically optimize using events such as version bumps or
    compiler signature differences.

    General steps

    1. Instrument
    2. Train
    3. Optimize

    When performing BOLT+PGO, we recommend performing PGO to completion
    first then BOLT to completion.


    Draft sample script

#!/bin/bash
OVERLAY_DIR="/usr/local/oiledmachine-overlay"
PORTAGE_DIR="/usr/portage"
SLOT=15

trainer() {
	export CC="clang-${SLOT}"
	export CXX="clang++-${SLOT}"
	export LD="clang-${SLOT}"

	# Here you need to train the -O* levels but we train the parser.
	# The actual brains/algorithms of the compiler are in the llvm library.
	# The trainer program here is way better than what is promoted by upstream.
	pushd "${OVERLAY_DIR}/sys-devel/clang"
		export CFLAGS="-march=native -O2 -pipe"
		export CXXFLAGS="-march=native -O2 -pipe"
		export LDFLAGS="-march=native -O2 -pipe"
		ebuild $(realpath ./clang-${SLOT}*.ebuild | tail -n 1) clean unpack prepare compile

		export CFLAGS="-march=native -O3 -pipe"
		export CXXFLAGS="-march=native -O3 -pipe"
		export LDFLAGS="-march=native -O3 -pipe"
		ebuild $(realpath ./clang-${SLOT}*.ebuild | tail -n 1) clean unpack prepare compile

		export CFLAGS="-march=native -O3 -flto=thin -pipe"
		export CXXFLAGS="-march=native -O3 -flto=thin -pipe"
		export LDFLAGS="-march=native -O3 -fuse-ld=lld -flto=thin -pipe"
		ebuild $(realpath ./clang-${SLOT}*.ebuild | tail -n 1) clean unpack prepare compile

		export CFLAGS="-march=native -O3 -flto=thin -pipe"
		export CXXFLAGS="-march=native -O3 -flto=thin -pipe"
		export LDFLAGS="-march=native -O3 -fuse-ld=lld -flto=thin -pipe"
		ebuild $(realpath ./clang-${SLOT}*.ebuild | tail -n 1) clean unpack prepare compile

	popd

	pushd "${OVERLAY_DIR}/media-libs/mesa"
		ebuild $(realpath ./mesa-22*.ebuild | tail -n 1) clean unpack prepare compile
	popd

	# Duration in seconds
	timeout 30 blender project1.blend  -f 1,3,5,7,9,11 -E CYCLES

	# Run opencl programs with timeout 180
	timeout $((60*5)) bitcoin_miner
	timeout $((60*5)) distributed_computing_project

	timeout $((60*5)) benchmark_demo_with_shader_programs

	# Build with WASM
	pushd "${OVERLAY_DIR}/dev-games/gdevelop"
		ebuild $(realpath ./gdevelop-*.ebuild | tail -n 1) clean unpack prepare compile
	popd
}

main() {
	emerge -1vuDN "sys-devel/clang:${SLOT}[-epgo,-ebolt]"
	emerge -1vO "sys-devel/clang:${SLOT}[epgo,-ebolt]" # pgi
	trainer
	emerge -1vO "sys-devel/clang:${SLOT}[epgo,ebolt]" # pgo, bolt_inst
	trainer
	emerge --config "sys-devel/clang:${SLOT}[epgo,ebolt]" # bolt_opt
}

main

## DONE

    Deterministic reliable builds

    Due to the problematic design of the live ebuild system, it
    is recommened to use a commit snapshot on the same slot for all
    LLVM live packages.  To have deterministic builds, per-package
    environmental variable must be set by adding the following once a
    successful build of LLVM has been discovered:

Contents of /etc/portage/env/llvm-16-commit.conf:
EGIT_OVERRIDE_COMMIT_LLVM_LLVM_PROJECT="ADD_40_DIGIT_COMMIT_HERE"

Contents of /etc/portage/package.env:
sys-devel/llvm:16 llvm-16-commit.conf
sys-devel/clang:16 llvm-16-commit.conf
=sys-libs/compiler-rt-16* llvm-16-commit.conf
=sys-libs/compiler-rt-sanitizers-16* llvm-16-commit.conf
=sys-libs/libcxx-16* llvm-16-commit.conf
=sys-libs/libcxxabi-16* llvm-16-commit.conf
=sys-libs/libomp-16* llvm-16-commit.conf
=sys-devel/lld-16* llvm-16-commit.conf

  Then, emerge -1vuDN all of the above ebuilds.

  Replace 16 with the particular slots of the live ebuilds that you are
  interested.  When you need to update, just add and remove a # in front
  of EGIT_OVERRIDE_COMMIT_LLVM_LLVM_PROJECT to switch on and off when
  updating the 40 digit hash code again.  For the best success only pick
  the commits with a green checkmark in the commit history:
  https://github.com/llvm/llvm-project/commits/main

  References:
[1] https://research.facebook.com/publications/bolt-a-practical-binary-optimizer-for-data-centers-and-beyond/
[2] https://llvm.org/docs/HowToBuildWithPGO.html
  </longdescription>
  <use>
    <flag name="default-compiler-rt">
      Use compiler-rt instead of libgcc as the default rtlib for clang
    </flag>
    <flag name="default-fortify-source-2">
      Sets _FORITIFY_SOURCE=2 as default when building all packages with clang.
      It requires -O1 or higher for all built packages.
    </flag>
    <flag name="default-fortify-source-3">
      Sets _FORITIFY_SOURCE=3 as default.
      It requires -O1 or higher for all built packages.
    </flag>
    <flag name="default-full-relro">
      Sets Full RELRO as default ON when building all packages with clang.
    </flag>
    <flag name="default-libcxx">
      Use libc++ instead of libstdc++ as the default stdlib for clang
    </flag>
    <flag name="default-lld">
      Use lld as the default linker for clang
    </flag>
    <flag name="default-partial-relro">
      Sets Partial RELRO as default ON when building all packages with clang.
    </flag>
    <flag name="default-ssp-buffer-size">
      Sets the default SSP buffer size to 4 bytes to increase protection
      coverage.
    </flag>
    <flag name="default-stack-clash-protection">
      Sets Stack Clash Protection (SCP) as default ON when building all
      packages with clang.
    </flag>
    <flag name="ebolt">
      Optimize code layout for better cache and branch prediction.  This may
      improve performance by 15%.  This uses event based bolt where one
      step is performed per emerge.  To progress to the next step you
      re-emerge the ebuild with the BOLT training perf profile.
    </flag>
    <flag name="epgo">
      Use event based Profile Guided Optimization to optimize the ebuild.
      One PGO step per emerge is performed.  When a patch version bump
      happens, it does only the PGO step.  It may result in 20% build
      reduction with the optimized build.
    </flag>
    <flag name="extra">
      Build extra tools (clangd, clang-tidy and a few more)
    </flag>
    <flag name="hardened">
      Match the hardened default on settings from hardened GCC.  It also
      changes the --version that may use it as detection for full hardened
      support.

      For this ebuild, it is for backwards compatibility.  You may individually
      pick the default_* instead.  So if you use a more advanced SSP algorithm,
      you can use that instead.
    </flag>
    <flag name="ieee-long-double">
      Use accelerated 128-bit IEEE long double ABI (ppc64le only)
    </flag>
    <flag name="pie">
      Build all packages with PIE ON when building with clang.
    </flag>
    <flag name="pgo">
      Build with Profile Guided Optimization which may reduce compile times of
      other packages by 20%, with the PGOed llvm package.
    </flag>
    <flag name="ssp">
      Sets (Stack Smashing Protection) SSP, specifically
      -fstack-protector-strong, as default ON when building all packages with
      clang.
    </flag>
    <flag name="static-analyzer">
      Install the Clang static analyzer
    </flag>
    <flag name="rN">
      (INTERNAL USE ONLY: oiledmachine-overlay) bumped revisions to reuse ccache
      [for faster rebuilds on very large packages] while applying ebuild fixes.
    </flag>
  </use>
</pkgmetadata>
