Subject:  Limit lto1-wpa to NCORES / 2 - 1 processes
Patch Author:  Orson Teodoro <orsonteodoro@hotmail.com>
Patch Status:  Testing
Date: Sun Oct 17 05:25:58 PM PDT 2021 (Unix time: 1634516758)

This is to prevent a performance drop across all running lto1-wpa processes when
all processes are swapping which should not happen and to reduce Out of Memory
(OOM) without swap.

This is also useful for limiting memory use across parallel package builds.

Use -DWPA_CPU_OVERRIDE=N or -DWPA_TOTAL_RAM=N where N is >= 1 in CPPFLAGS for
overrides of the autodetect value.

The number of processes spawned shouldn't exceed the number RAM / 2 - 1 if 2 GiB
per process using cc1plus as the example, but 2 may be replaced with N for N GiB
per process.  The -1 is taken care of so WPA_TOTAL_RAM represents the actual
GiB.

--- a/gcc/lto/lto-lang.c.orig	2021-04-08 04:56:28.441745172 -0700
+++ b/gcc/lto/lto-lang.c	2021-11-04 18:07:46.251759949 -0700
@@ -18,6 +18,10 @@ You should have received a copy of the G
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <semaphore.h>
+
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -60,6 +64,8 @@ static tree ignore_attribute (tree *, tr
 static tree handle_format_attribute (tree *, tree, tree, int, bool *);
 static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);
 static tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);
+static void lto_wpa_sem_wait(void);
+static void lto_wpa_sem_post(void);
 
 /* Helper to define attribute exclusions.  */
 #define ATTR_EXCL(name, function, type, variable)	\
@@ -872,8 +878,12 @@ lto_post_options (const char **pfilename
       flag_whole_program = 0;
     }
 
-  if (flag_wpa)
+  if (flag_wpa) {
     flag_generate_lto = 1;
+    lang_hooks.lto_wpa.lto_wpa_sem_wait = lto_wpa_sem_wait;
+    lang_hooks.lto_wpa.lto_wpa_sem_post = lto_wpa_sem_post;
+    lang_hooks.lto_wpa.lto_wpa_sem_clear_all_locks = clear_all_wpa_locks;
+  }
 
   /* Initialize the codegen flags according to the output type.  */
   switch (flag_lto_linker_output)
@@ -1286,6 +1296,65 @@ lto_build_c_type_nodes (void)
   pid_type_node = integer_type_node;
 }
 
+void sem_wpa_init ()
+{
+  if (sem_wpa_opened && (sem_wpa == NULL || sem_wpa == SEM_FAILED))
+    {
+      /* It's possible to init more than once */
+      fprintf (stderr, "sem_wpa already inited skipping.\n");
+      fflush (stderr);
+      return;
+    }
+
+  /* Ideally lto1-wpa scaling should be done dynamically based on available
+     memory, but limit to  NCPUS / 2 - 1  to keep the algorithm simple to prevent
+     trashing that will degrade performance.  It assumes the lto1-wpa saturate
+     2 GiB per core.
+
+     This semaphore will place a lto1-wpa limit across multiple instances
+     because lto_parallelism does not fix the problem.
+  */
+#if defined(WPA_CPU_OVERRIDE)
+  /* This must be >= 1 CPU. */
+  nthreads_var = WPA_CPU_OVERRIDE;
+#elif defined(WPA_TOTAL_RAM)
+  /* This must be >= 1 GiB. */
+  nthreads_var = WPA_TOTAL_RAM;
+#else
+  init_num_threads ();
+#endif
+
+  /* Linking cc1plus takes 2 GiB per lto1-wpa process.
+     Scale 2 by the number of GiB per core.  */
+  nthreads_var >>= 1;
+
+  /* 1 GiB is reserved as a safety buffer against swapping.
+     This means for a 4 core processor, you are left with 1
+     lto1-wpa process that can balloon to 3 GiB.  If 2 processes
+     were allowed and no saftey buffer, you could have had 6
+     GiB total on a 1 GiB per core machine. */
+  nthreads_var -= 1;
+  if (nthreads_var < 1)
+    nthreads_var = 1;
+
+  sem_t *t_sem;
+  t_sem = sem_open(sem_wpa_name, O_CREAT | O_RDWR,
+    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP
+#ifndef GCC_DISALLOW_LTO_WPA_SEM_OTHERS
+    | S_IROTH | S_IWOTH /* On this distro, the others group is allowed to run gcc by default. */
+#endif
+    , nthreads_var);
+  if (t_sem == SEM_FAILED)
+    fatal_error (input_location, "sem_wpa alloc failed");
+  else
+    {
+      fprintf (stderr, "sem_open () success\n");
+      fflush (stderr);
+      sem_wpa = t_sem;
+      sem_wpa_opened = true;
+    }
+}
+
 /* Perform LTO-specific initialization.  */
 
 static bool
@@ -1380,9 +1449,34 @@ lto_init (void)
       }
 #undef NAME_TYPE
 
+  if (flag_wpa)
+    sem_wpa_init ();
+
   return true;
 }
 
+/* Remove lto_wpa sem files */
+
+static void
+lto_finish (void)
+{
+  if (flag_wpa)
+    {
+      if (sem_wpa == NULL || sem_wpa == SEM_FAILED)
+        {
+	  fprintf (stderr, "sem_wpa already freed skipping\n");
+	  fflush (stderr);
+	  return;
+        }
+      fprintf (stderr, "Closing and removing lto_wpa sem files\n");
+      fflush (stderr);
+      sem_close (sem_wpa);
+      sem_wpa = NULL;
+      sem_unlink (sem_wpa_name);
+      sem_wpa_opened = false;
+    }
+}
+
 /* Register c++-specific dumps.  */
 
 void
@@ -1439,6 +1533,8 @@ static void lto_init_ts (void)
 #define LANG_HOOKS_BUILTIN_FUNCTION lto_builtin_function
 #undef LANG_HOOKS_INIT
 #define LANG_HOOKS_INIT lto_init
+#undef LANG_HOOKS_FINISH
+#define LANG_HOOKS_FINISH lto_finish
 #undef LANG_HOOKS_PARSE_FILE
 #define LANG_HOOKS_PARSE_FILE lto_main
 #undef LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS
@@ -1482,5 +1578,42 @@ lto_tree_node_structure (union lang_tree
   return TS_LTO_GENERIC;
 }
 
+static void
+lto_wpa_sem_wait(void) {
+  if (flag_wpa)
+  {
+    /* Done here because of multithreading problem */
+    int ret = sem_wait (sem_wpa);
+    if (ret == EINTR) {
+      fprintf (stderr, "sem_wait (sem_wpa) failed:  EINTR\n");
+      fflush (stderr);
+      clear_all_wpa_locks ();
+      exit (1);
+    } else if (ret == EINVAL) {
+      fprintf (stderr, "sem_wait (sem_wpa) failed:  EINVAL\n");
+      fflush (stderr);
+      clear_all_wpa_locks ();
+      exit (1);
+    }
+    int v;
+    sem_getvalue (sem_wpa, &v);
+    fprintf (stderr, "Entering the sem_wpa context.  Lock count:  %d\n", v);
+    fflush (stderr);
+  }
+}
+
+static void
+lto_wpa_sem_post(void) {
+  if (flag_wpa)
+  {
+    /* Done here because of multithreading problem */
+    int v;
+    sem_post (sem_wpa);
+    sem_getvalue (sem_wpa, &v);
+    fprintf (stderr, "Leaving the sem_wpa context.  Lock count:  %d\n", v);
+    fflush (stderr);
+  }
+}
+
 #include "gtype-lto.h"
 #include "gt-lto-lto-lang.h"
--- a/gcc/lto/Make-lang.in.orig	2021-11-04 18:07:46.251759949 -0700
+++ b/gcc/lto/Make-lang.in	2021-11-04 18:08:24.336757474 -0700
@@ -85,7 +85,7 @@ lto.stagefeedback:
 lto-warn = $(STRICT_WARN)
 
 $(LTO_EXE): $(LTO_OBJS) $(BACKEND) $(LIBDEPS)
-	+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
+	+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -pthread -o $@ \
 		$(LTO_OBJS) $(BACKEND) $(BACKENDLIBS) $(LIBS)
 
 $(LTO_DUMP_EXE): $(LTO_DUMP_OBJS) $(BACKEND) $(LIBDEPS)
--- a/gcc/toplev.c.orig	2021-04-08 04:56:29.677760094 -0700
+++ b/gcc/toplev.c	2021-11-04 18:07:46.253759949 -0700
@@ -22,6 +22,8 @@ along with GCC; see the file COPYING3.
    in the proper order, and counts the time used by each.
    Error messages and low-level interface to malloc also handled here.  */
 
+#include <semaphore.h>
+
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -101,6 +103,7 @@ along with GCC; see the file COPYING3.
 #endif
 
 static void general_init (const char *, bool);
+static void general_init_post_parse_options (void);
 static void do_compile ();
 static void process_options (void);
 static void backend_init (void);
@@ -316,6 +319,11 @@ static void
 crash_signal (int signo)
 {
   signal (signo, SIG_DFL);
+  fprintf (stderr, "called crash_signal (). flag_wpa: %d\n", flag_wpa);
+  fflush (stderr);
+
+  if (flag_wpa)
+    lang_hooks.lto_wpa.lto_wpa_sem_clear_all_locks ();
 
   /* If we crashed while processing an ASM statement, then be a little more
      graceful.  It's most likely the user's fault.  */
@@ -454,9 +462,15 @@ compile_file (void)
   timevar_start (TV_PHASE_PARSING);
   timevar_push (TV_PARSE_GLOBAL);
 
+  if (flag_wpa)
+    lang_hooks.lto_wpa.lto_wpa_sem_wait ();
+
   /* Parse entire file and generate initial debug information.  */
   lang_hooks.parse_file ();
 
+  if (flag_wpa)
+    lang_hooks.lto_wpa.lto_wpa_sem_post ();
+
   timevar_pop (TV_PARSE_GLOBAL);
   timevar_stop (TV_PHASE_PARSING);
 
@@ -1255,6 +1269,14 @@ general_init (const char *argv0, bool in
   debuginfo_early_init ();
 }
 
+static void
+general_init_post_parse_options (void)
+{
+#ifdef SIGINT
+  signal (SIGINT, crash_signal);
+#endif
+}
+
 /* Return true if the current target supports -fsection-anchors.  */
 
 static bool
@@ -1383,6 +1405,8 @@ process_options (void)
      so we can correctly initialize debug output.  */
   no_backend = lang_hooks.post_options (&main_input_filename);
 
+  general_init_post_parse_options ();
+
   /* Some machines may reject certain combinations of options.  */
   location_t saved_location = input_location;
   input_location = UNKNOWN_LOCATION;
--- a/gcc/lto/lto-common.c.orig	2021-04-08 04:56:28.441745172 -0700
+++ b/gcc/lto/lto-common.c	2021-11-04 18:07:46.255759948 -0700
@@ -18,6 +18,8 @@ You should have received a copy of the G
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#include <semaphore.h>
+
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -61,6 +63,10 @@ along with GCC; see the file COPYING3.
 /* True when no new types are going to be streamd from the global stream.  */
 
 static bool type_streaming_finished = false;
+unsigned long nthreads_var;
+sem_t *sem_wpa = NULL; /* corresponds to used cores */
+char *sem_wpa_name = "/gcc-lto-wpa";
+bool sem_wpa_opened;
 
 GTY(()) tree first_personality_decl;
 
@@ -3102,4 +3108,172 @@ lto_fe_init (void)
 #endif
 }
 
+/* cpuset_popcount and init_num_threads
+   are from gcc/lto-wrapper.c:
+
+   Copyright (C) 2009-2021 Free Software Foundation, Inc.
+
+   Factored out of collect2 by Rafael Espindola <espindola@google.com>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Number of CPUs that can be used for parallel LTRANS phase.  */
+
+#ifdef HAVE_PTHREAD_AFFINITY_NP
+unsigned long cpuset_size;
+static unsigned long get_cpuset_size;
+cpu_set_t *cpusetp;
+
+unsigned long
+static cpuset_popcount (unsigned long cpusetsize, cpu_set_t *cpusetp)
+{
+#ifdef CPU_COUNT_S
+  /* glibc 2.7 and above provide a macro for this.  */
+  return CPU_COUNT_S (cpusetsize, cpusetp);
+#else
+#ifdef CPU_COUNT
+  if (cpusetsize == sizeof (cpu_set_t))
+    /* glibc 2.6 and above provide a macro for this.  */
+    return CPU_COUNT (cpusetp);
+#endif
+  size_t i;
+  unsigned long ret = 0;
+  STATIC_ASSERT (sizeof (cpusetp->__bits[0]) == sizeof (unsigned long int));
+  for (i = 0; i < cpusetsize / sizeof (cpusetp->__bits[0]); i++)
+    {
+      unsigned long int mask = cpusetp->__bits[i];
+      if (mask == 0)
+	continue;
+      ret += __builtin_popcountl (mask);
+    }
+  return ret;
+#endif
+}
+#endif
+
+/* At startup, determine the default number of threads.  It would seem
+   this should be related to the number of cpus online.  */
+
+void
+init_num_threads (void)
+{
+#ifdef HAVE_PTHREAD_AFFINITY_NP
+#if defined (_SC_NPROCESSORS_CONF) && defined (CPU_ALLOC_SIZE)
+  cpuset_size = sysconf (_SC_NPROCESSORS_CONF);
+  cpuset_size = CPU_ALLOC_SIZE (cpuset_size);
+#else
+  cpuset_size = sizeof (cpu_set_t);
+#endif
+
+  cpusetp = (cpu_set_t *) xmalloc (gomp_cpuset_size);
+  do
+    {
+      int ret = pthread_getaffinity_np (pthread_self (), gomp_cpuset_size,
+					cpusetp);
+      if (ret == 0)
+	{
+	  /* Count only the CPUs this process can use.  */
+	  nthreads_var = cpuset_popcount (cpuset_size, cpusetp);
+	  if (nthreads_var == 0)
+	    break;
+	  get_cpuset_size = cpuset_size;
+#ifdef CPU_ALLOC_SIZE
+	  unsigned long i;
+	  for (i = cpuset_size * 8; i; i--)
+	    if (CPU_ISSET_S (i - 1, cpuset_size, cpusetp))
+	      break;
+	  cpuset_size = CPU_ALLOC_SIZE (i);
+#endif
+	  return;
+	}
+      if (ret != EINVAL)
+	break;
+#ifdef CPU_ALLOC_SIZE
+      if (cpuset_size < sizeof (cpu_set_t))
+	cpuset_size = sizeof (cpu_set_t);
+      else
+	cpuset_size = cpuset_size * 2;
+      if (cpuset_size < 8 * sizeof (cpu_set_t))
+	cpusetp
+	  = (cpu_set_t *) realloc (cpusetp, cpuset_size);
+      else
+	{
+	  /* Avoid fatal if too large memory allocation would be
+	     requested, e.g. kernel returning EINVAL all the time.  */
+	  void *p = realloc (cpusetp, cpuset_size);
+	  if (p == NULL)
+	    break;
+	  cpusetp = (cpu_set_t *) p;
+	}
+#else
+      break;
+#endif
+    }
+  while (1);
+  cpuset_size = 0;
+  nthreads_var = 1;
+  free (cpusetp);
+  cpusetp = NULL;
+#endif
+#ifdef _SC_NPROCESSORS_ONLN
+  nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);
+#endif
+}
+
+void clear_all_wpa_locks (void) {
+  volatile static bool clear_wpa_locks;
+  int nlocks, e;
+
+  fprintf (stderr, "clear_all_wpa_locks called\n");
+  fflush (stderr);
+
+  if (sem_wpa == NULL || sem_wpa == SEM_FAILED)
+    {
+       fprintf (stderr, "Already freed sem_wpa skipping\n");
+       fflush (stderr);
+       return;
+    }
+
+  while (__atomic_test_and_set (&clear_wpa_locks, __ATOMIC_SEQ_CST)) ;
+  fprintf (stderr, "In clear_wpa_locks context\n");
+  fflush (stderr);
+  while (1) {
+    e = sem_getvalue (sem_wpa, &nlocks);
+    if (e < 0)
+	break;
+    else if (nlocks != nthreads_var)
+      {
+        sem_post (sem_wpa);
+        sem_getvalue (sem_wpa, &nlocks);
+        fprintf (stderr, "sem_post (sem_wpa) called.  nlocks: %d, NLOCKS_MAX: %d\n", nlocks, nthreads_var);
+        fflush (stderr);
+      }
+    else
+      break;
+  }
+  fprintf (stderr, "Closing and removing sem_wpa lockfile\n");
+  fflush (stderr);
+  sem_close (sem_wpa);
+  sem_wpa = NULL;
+  sem_unlink (sem_wpa_name);
+  sem_wpa_opened = false;
+  __atomic_clear (&clear_wpa_locks, __ATOMIC_SEQ_CST);
+  fprintf (stderr, "Left clear_wpa_locks context\n");
+  fflush (stderr);
+}
+
 #include "gt-lto-lto-common.h"
--- a/gcc/lto/lto-common.h.orig	2021-04-08 04:56:28.441745172 -0700
+++ b/gcc/lto/lto-common.h	2021-11-04 18:07:46.255759948 -0700
@@ -20,7 +20,11 @@ along with GCC; see the file COPYING3.
 #ifndef LTO_COMMON_H
 #define LTO_COMMON_H
 
+#include <semaphore.h>
+
 void lto_fe_init (void);
+void clear_all_wpa_locks (void);
+void init_num_threads (void);
 void read_cgraph_and_symbols (unsigned, const char **);
 void print_lto_report_1 (void);
 
@@ -28,6 +32,10 @@ extern tree lto_eh_personality_decl;
 extern GTY(()) vec<tree, va_gc> *tree_with_vars;
 extern const unsigned char *lto_mode_identity_table;
 extern tree first_personality_decl;
+extern unsigned long nthreads_var;
+extern sem_t *sem_wpa; /* corresponds to used cores */
+extern char *sem_wpa_name;
+extern bool sem_wpa_opened;
 
 #endif
 
--- a/gcc/langhooks.h.orig	2021-04-08 04:56:28.433745074 -0700
+++ b/gcc/langhooks.h	2021-11-04 18:07:46.255759948 -0700
@@ -314,6 +314,15 @@ struct lang_hooks_for_lto
   void (*end_section) (void);
 };
 
+/* WPA hooks for controlled memory allocation. */
+
+struct lang_hooks_for_lto_wpa
+{
+  void (*lto_wpa_sem_wait) (void);
+  void (*lto_wpa_sem_post) (void);
+  void (*lto_wpa_sem_clear_all_locks) (void);
+};
+
 /* Language-specific hooks.  See langhooks-def.h for defaults.  */
 
 struct lang_hooks
@@ -487,6 +496,7 @@ struct lang_hooks
   struct lang_hooks_for_types types;
   
   struct lang_hooks_for_lto lto;
+  struct lang_hooks_for_lto_wpa lto_wpa;
 
   /* Returns a TREE_VEC of the generic parameters of an instantiation of
      a generic type or decl, e.g. C++ template instantiation.  If
--- a/gcc/langhooks-def.h.orig	2021-04-08 04:56:28.433745074 -0700
+++ b/gcc/langhooks-def.h	2021-11-04 18:07:46.256759948 -0700
@@ -302,6 +302,16 @@ extern void lhd_end_section (void);
   LANG_HOOKS_END_SECTION \
 }
 
+#define LANG_HOOKS_LTO_WPA_SEM_WAIT lhd_do_nothing
+#define LANG_HOOKS_LTO_WPA_SEM_POST lhd_do_nothing
+#define LANG_HOOKS_LTO_WPA_SEM_CLEAR_ALL_LOCKS lhd_do_nothing
+
+#define LANG_HOOKS_LTO_WPA { \
+  LANG_HOOKS_LTO_WPA_SEM_WAIT, \
+  LANG_HOOKS_LTO_WPA_SEM_POST, \
+  LANG_HOOKS_LTO_WPA_SEM_CLEAR_ALL_LOCKS \
+}
+
 /* The whole thing.  The structure is defined in langhooks.h.  */
 #define LANG_HOOKS_INITIALIZER { \
   LANG_HOOKS_NAME, \
@@ -343,6 +353,7 @@ extern void lhd_end_section (void);
   LANG_HOOKS_DECLS, \
   LANG_HOOKS_FOR_TYPES_INITIALIZER, \
   LANG_HOOKS_LTO, \
+  LANG_HOOKS_LTO_WPA, \
   LANG_HOOKS_GET_INNERMOST_GENERIC_PARMS, \
   LANG_HOOKS_GET_INNERMOST_GENERIC_ARGS, \
   LANG_HOOKS_FUNCTION_PARAMETER_PACK_P, \
--- a/gcc/gcc.c.orig	2021-04-08 04:56:28.365744252 -0700
+++ b/gcc/gcc.c	2021-11-04 18:07:46.259759948 -0700
@@ -44,6 +44,7 @@ compilation is specified by a string cal
 #include "filenames.h"
 #include "spellcheck.h"
 
+#include <semaphore.h>
 
 
 /* Manage the manipulation of env vars.
@@ -7236,8 +7237,33 @@ set_input (const char *filename)
 /* On fatal signals, delete all the temporary files.  */
 
 static void
+close_wpa_sem(void)
+{
+  static char *sem_wpa_name="/gcc-lto-wpa";
+  volatile static bool clear_wpa_locks;
+
+  fprintf (stderr, "Entered close_wpa_sem ()\n");
+  fflush (stderr);
+
+  while (__atomic_test_and_set (&clear_wpa_locks, __ATOMIC_SEQ_CST)) ;
+
+  while (!access("/dev/shm/sem.gcc-lto-wpa", F_OK)) {
+    fprintf (stderr, "Trying to remove the sem_wpa lockfile\n");
+    fflush (stderr);
+    sem_unlink (sem_wpa_name);
+  }
+
+  __atomic_clear (&clear_wpa_locks, __ATOMIC_SEQ_CST);
+}
+
+static void
 fatal_signal (int signum)
 {
+  fprintf (stderr, "Entered fatal_signal ()\n");
+  fflush (stderr);
+
+  close_wpa_sem ();
+
   signal (signum, SIG_DFL);
   delete_failure_queue ();
   delete_temp_files ();
