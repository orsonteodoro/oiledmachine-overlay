<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
  <maintainer type="person">
    <!-- ebuild only in the oiledmachine-overlay -->
    <email>orsonteodoro@hotmail.com</email>
    <name>Orson Teodoro</name>
  </maintainer>
  <longdescription>
    Souper is an LLVM IR optimizer pass that can reduce a binary by around 4.4%
    but with a 2% runtime performance slowdown tradeoff.[1]  [The savings may
    become substantial when storing GiBs or TiBs of compiled code.]

    It automatically generates random code sequences of optimized code
    sequences.  Because of this random code generation, two additional CFLAGS
    can be used as input to additional functions when computing the cost.

    Ricer notes:

    Two profile options can improve optimization over time but require the
    external-cache USE flag.


    Extra CFLAGS to pass directly to clang/clang++:

     * -mllvm -souper-static-profile -- can be used to add performance profiling
          counters for size
     * -g -mllvm -souper-dynamic-profile -- can be used to add performance
          profiling counters for execution speed

    Use of these counters may improve optimization over time after recompiling.
    See the academic paper on how this really works.

    If you do not want to use the wrapper, see the contents of the sclang
    wrapper to see how each of these extra args are invoked.

    The above settings correspond to sclang front-end ENVIRONMENT VARIABLES as
    well:

      *  SOUPER_STATIC_PROFILE=1
      *  SOUPER_DYNAMIC_PROFILE=1


    Using souper with frontend wrappers via CC/CXX:

    The wrapper scripts simplify passing args to clang/clang++ without getting
    too technical when to use -Xclang or -mllvm.

    Set CC/CXX for the wrapper for highest built llvm-N USE flag:

      CC=sclang
      CXX=sclang++

    Alternatively, you can set to a specific slot as follows: 
   
      CC=sclang-N	# where N=[11,12,13,14] corresponds to clang-N
      CXX=sclang++-N	# where N=[11,12,13,14] corresponds to clang++-N

    For a full list of supported wrapper commands see `sclang --help`.


    Using souper via CFLAGS:

    Do it in the new school way:

      COMMON_FLAGS="${COMMON_FLAGS} -Xclang -load -Xclang /usr/lib/souper/14/lib64/libsouperPass.so"

    or in old the school way:

      CFLAGS="${CFLAGS} -Xclang -load -Xclang /usr/lib/souper/14/lib64/libsouperPass.so"
      CXXFLAGS="${CXXFLAGS} -Xclang -load -Xclang /usr/lib/souper/14/lib64/libsouperPass.so"

    It's required to use a bashrc script to delete/replace these settings if
    this is applied systemwide with a per package switcher.  If it is a GCC
    only package, these flags should be deleted.

    As an alternative, you can apply it individually with package.env
    configuration (.conf) to easily adjust these especially for packages that
    require older versions of Clang / LLVM.

    References:
    [1] https://research.google/pubs/pub46467/
  </longdescription>
  <upstream>
    <bugs-to>https://github.com/google/souper/issues</bugs-to>
    <doc lang="en">https://github.com/google/souper#using-souper</doc>
    <remote-id type="github">google/souper</remote-id>
  </upstream>
  <use>
    <flag name="debug">
      Allow use of assertions for correctness checking.
    </flag>
    <flag name="dump">
      Allow use of dump functions to increase verbosity of helpful debug
      information.  Only useful for developers or testers.
    </flag>
    <flag name="support-tools">
      Install extra tools designed for compiler developers
    </flag>
    <flag name="external-cache">
      An external query cache to reduce time cost of looking up the most
      frequent encountered code sequences mapped to the to cheapest code
      sequence while skipping steps to obtain it.

      Note the use of an external cache can increase the cost of RAM in the
      order of 100s of MB but the time savings is amortized (meaning high
      initial cost but decreased over time).  Without redis the time cost
      could be 6.28-13x times larger in the initial compilation
      relative to warm cache runs.

      It is recommended to hardmask newer versions of Redis in package.mask.
    </flag>
    <flag name="rN">FOR INTERNAL USE ONLY.  Revision bumps to preserve
      ccache paths for fast rebuilds.
    </flag>
  </use>
</pkgmetadata>
