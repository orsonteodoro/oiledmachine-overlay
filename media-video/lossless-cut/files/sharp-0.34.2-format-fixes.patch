--- a/node_modules/icon-gen/node_modules/sharp/lib/sharp.js.orig	2025-07-07 13:30:57.571506596 -0700
+++ b/node_modules/icon-gen/node_modules/sharp/lib/sharp.js	2025-07-07 13:51:01.179138725 -0700
@@ -1,10 +1,11 @@
 'use strict';
 
 const platformAndArch = require('./platform')();
+const buildType = (process.env.NODE_ENV === 'debug' || process.env.NODE_ENV === 'Debug' || process.env.NODE_ENV === 'DEBUG' || process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'Development' || process.env.NODE_ENV === 'DEVELOPMENT') ? 'Debug' : 'Release';
 
 /* istanbul ignore next */
 try {
-  module.exports = require(`../build/Release/sharp-${platformAndArch}.node`);
+  module.exports = require(`../build/${buildType}/sharp-${platformAndArch}.node`);
 } catch (err) {
   // Bail early if bindings aren't available
   const help = ['', 'Something went wrong installing the "sharp" module', '', err.message, '', 'Possible solutions:'];
--- a/node_modules/sharp/lib/utility.js.orig	2025-08-02 17:19:12.857298413 -0700
+++ b/node_modules/sharp/lib/utility.js	2025-08-02 18:04:21.933769375 -0700
@@ -21,10 +21,19 @@ const libvipsVersion = sharp.libvipsVers
  * @returns {Object}
  */
 const format = sharp.format();
-format.heif.output.alias = ['avif', 'heic'];
-format.jpeg.output.alias = ['jpe', 'jpg'];
-format.tiff.output.alias = ['tif'];
-format.jp2k.output.alias = ['j2c', 'j2k', 'jp2', 'jpx'];
+// Add aliases only for formats with valid output support
+if (format.heif && format.heif.output && format.heif.output.file) {
+  format.heif.output.alias = ['avif', 'heic'];
+}
+if (format.jpeg && format.jpeg.output && format.jpeg.output.file) {
+  format.jpeg.output.alias = ['jpe', 'jpg'];
+}
+if (format.tiff && format.tiff.output && format.tiff.output.file) {
+  format.tiff.output.alias = ['tif'];
+}
+if (format.jp2k && format.jp2k.output && format.jp2k.output.file) {
+  format.jp2k.output.alias = ['j2c', 'j2k', 'jp2', 'jpx'];
+}
 
 /**
  * An Object containing the available interpolators and their proper values
--- a/node_modules/sharp/src/sharp.cc.orig	2025-07-07 16:00:39.704313382 -0700
+++ b/node_modules/sharp/src/sharp.cc	2025-07-07 16:05:25.389829696 -0700
@@ -11,11 +11,21 @@
 #include "pipeline.h"
 #include "utilities.h"
 #include "stats.h"
+#include "utilities.h"
+#include "common.h"
 
 Napi::Object init(Napi::Env env, Napi::Object exports) {
+  sharp::Log(env, "debug", "Entering sharp.init()");
   static std::once_flag sharp_vips_init_once;
-  std::call_once(sharp_vips_init_once, []() {
-    vips_init("sharp");
+  std::call_once(sharp_vips_init_once, [&env]() {
+    sharp::Log(env, "debug", "Calling vips_init(\"sharp\")");
+    if (vips_init("sharp")) {
+      std::string error = "vips_init failed: " + std::string(vips_error_buffer());
+      sharp::Log(env, "error", error);
+      Napi::Error::New(env, error).ThrowAsJavaScriptException();
+    } else {
+      sharp::Log(env, "debug", "vips_init succeeded");
+    }
   });
 
   g_log_set_handler("VIPS", static_cast<GLogLevelFlags>(G_LOG_LEVEL_WARNING),
--- a/node_modules/sharp/src/common.h.orig	2025-07-06 23:19:57.694812505 -0700
+++ b/node_modules/sharp/src/common.h	2025-07-07 04:57:41.958646861 -0700
@@ -140,6 +140,15 @@ namespace sharp {
       vips_enum_from_nick(nullptr, type, AttrAsStr(obj, attr).data()));
   }
 
+  // Helper function for logging
+  inline void Log(Napi::Env env, const std::string& level, const std::string& message) {
+    if (sharp::HasAttr(env.Global(), "console")) {
+      Napi::Object console = env.Global().Get("console").As<Napi::Object>();
+      Napi::Function log = console.Get(level).As<Napi::Function>();
+      log.Call(console, { Napi::String::New(env, message) });
+    }
+  }
+
   // Create an InputDescriptor instance from a Napi::Object describing an input image
   InputDescriptor* CreateInputDescriptor(Napi::Object input);
 
--- a/node_modules/sharp/src/utilities.cc.orig	2025-08-02 17:19:12.713300771 -0700
+++ b/node_modules/sharp/src/utilities.cc	2025-08-02 17:53:36.200747086 -0700
@@ -123,6 +123,15 @@ Napi::Value format(const Napi::CallbackI
   }) {
     // Input
     const VipsObjectClass *oc = vips_class_find("VipsOperation", (f + "load").c_str());
+    if (!oc) {
+      // Skip unsupported formats
+      Napi::Object container = Napi::Object::New(env);
+      container.Set("id", f);
+      container.Set("input", Napi::Object::New(env));
+      container.Set("output", Napi::Object::New(env));
+      format.Set(f, container);
+      continue;
+    }
     Napi::Boolean hasInputFile = Napi::Boolean::New(env, oc);
     Napi::Boolean hasInputBuffer =
       Napi::Boolean::New(env, vips_type_find("VipsOperation", (f + "load_buffer").c_str()));
@@ -132,7 +141,7 @@ Napi::Value format(const Napi::CallbackI
     input.Set("stream", hasInputBuffer);
     if (hasInputFile) {
       const VipsForeignClass *fc = VIPS_FOREIGN_CLASS(oc);
-      if (fc->suffs) {
+      if (fc && fc->suffs && fc->suffs[0]) {
         Napi::Array fileSuffix = Napi::Array::New(env);
         const char **suffix = fc->suffs;
         for (int i = 0; *suffix; i++, suffix++) {
