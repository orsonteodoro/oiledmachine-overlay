Forward port for 0.1.105
Original patch:  https://github.com/AppImageCommunity/libappimage/tree/master/src/patches

diff -urp squashfuse-0.1.105_appimage.orig/Makefile.am squashfuse-0.1.105_appimage/Makefile.am
--- squashfuse-0.1.105_appimage.orig/Makefile.am	2023-01-14 17:01:51.764747235 -0800
+++ squashfuse-0.1.105_appimage/Makefile.am	2023-01-14 17:02:44.762843224 -0800
@@ -1,6 +1,7 @@
 COMPRESSION_LIBS = $(ZLIB_LIBS) $(XZ_LIBS) $(LZO_LIBS) $(LZ4_LIBS) $(ZSTD_LIBS)
 
 ACLOCAL_AMFLAGS = -I m4 --install
+AM_CFLAGS = -fno-strict-aliasing -DENABLE_DLOPEN
 
 # Suppress AppleDouble
 if MAKE_EXPORT
@@ -26,10 +27,10 @@ pkgconfig_DATA 	= squashfuse.pc
 noinst_LTLIBRARIES += libsquashfuse_convenience.la
 libsquashfuse_convenience_la_SOURCES = swap.c cache.c table.c dir.c file.c fs.c \
 	decompress.c xattr.c hash.c stack.c traverse.c util.c \
-	nonstd-pread.c nonstd-stat.c \
+	nonstd-pread.c nonstd-stat.c squashfuse_dlopen.c \
 	squashfs_fs.h common.h nonstd-internal.h nonstd.h swap.h cache.h table.h \
 	dir.h file.h decompress.h xattr.h squashfuse.h hash.h stack.h traverse.h \
-	util.h fs.h
+	util.h fs.h squashfuse_dlopen.h
 libsquashfuse_convenience_la_CPPFLAGS = $(ZLIB_CPPFLAGS) $(XZ_CPPFLAGS) $(LZO_CPPFLAGS) \
 	$(LZ4_CPPFLAGS) $(ZSTD_CPPFLAGS) $(FUSE_CPPFLAGS)
 libsquashfuse_convenience_la_LIBADD = $(COMPRESSION_LIBS) $(FUSE_LIBS)
@@ -39,7 +40,7 @@ lib_LTLIBRARIES += libsquashfuse.la
 libsquashfuse_la_SOURCES =
 libsquashfuse_la_CPPFLAGS = $(ZLIB_CPPFLAGS) $(XZ_CPPFLAGS) $(LZO_CPPFLAGS) \
 	$(LZ4_CPPFLAGS) $(ZSTD_CPPFLAGS) $(FUSE_CPPFLAGS)
-libsquashfuse_la_LIBADD = libsquashfuse_convenience.la
+libsquashfuse_la_LIBADD = libsquashfuse_convenience.la -ldl
 
 if SQ_WANT_FUSE
 # Helper for FUSE clients: libfuseprivate
@@ -91,7 +92,7 @@ squashfuse_ls_LDADD = libsquashfuse.la $
 noinst_PROGRAMS += squashfuse_extract
 squashfuse_extract_CPPFLAGS = $(FUSE_CPPFLAGS)
 squashfuse_extract_SOURCES = extract.c stat.h stat.c nonstd-makedev.c nonstd-symlink.c
-squashfuse_extract_LDADD = libsquashfuse.la $(COMPRESSION_LIBS) \
+squashfuse_extract_LDADD = -ldl libsquashfuse.la $(COMPRESSION_LIBS) \
   $(FUSE_LIBS)
 endif
 
Only in squashfuse-0.1.105_appimage: Makefile.am.orig
diff -urp squashfuse-0.1.105_appimage.orig/fuseprivate.c squashfuse-0.1.105_appimage/fuseprivate.c
--- squashfuse-0.1.105_appimage.orig/fuseprivate.c	2022-06-14 17:34:42.000000000 -0700
+++ squashfuse-0.1.105_appimage/fuseprivate.c	2023-01-14 17:02:44.762843224 -0800
@@ -60,18 +60,21 @@ int sqfs_listxattr(sqfs *fs, sqfs_inode
 }
 
 void sqfs_usage(char *progname, bool fuse_usage) {
+	LOAD_SYMBOL(void,fuse_cmdline_help,(void));
+	LOAD_SYMBOL(int,fuse_opt_add_arg,(struct fuse_args *args, const char *arg));
+	LOAD_SYMBOL(int,fuse_parse_cmdline,(struct fuse_args *args, char **mountpoint, int *multithreaded, int *foreground));
 	fprintf(stderr, "%s (c) 2012 Dave Vasilevsky\n\n", PACKAGE_STRING);
 	fprintf(stderr, "Usage: %s [options] ARCHIVE MOUNTPOINT\n",
 		progname ? progname : PACKAGE_NAME);
 	if (fuse_usage) {
 #if FUSE_USE_VERSION >= 30
-		fuse_cmdline_help();
+		DL(fuse_cmdline_help)();
 #else
 		struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
-		fuse_opt_add_arg(&args, ""); /* progname */
-		fuse_opt_add_arg(&args, "-ho");
+		DL(fuse_opt_add_arg)(&args, ""); /* progname */
+		DL(fuse_opt_add_arg)(&args, "-ho");
 		fprintf(stderr, "\n");
-		fuse_parse_cmdline(&args, NULL, NULL, NULL);
+		DL(fuse_parse_cmdline)(&args, NULL, NULL, NULL);
 #endif
 	}
 	exit(-2);
diff -urp squashfuse-0.1.105_appimage.orig/fuseprivate.h squashfuse-0.1.105_appimage/fuseprivate.h
--- squashfuse-0.1.105_appimage.orig/fuseprivate.h	2022-06-14 17:34:42.000000000 -0700
+++ squashfuse-0.1.105_appimage/fuseprivate.h	2023-01-14 17:02:44.762843224 -0800
@@ -27,11 +27,14 @@
 
 #include "squashfuse.h"
 
-#if FUSE_USE_VERSION >= 30
-#include <fuse3/fuse.h>
-#include <fuse3/fuse_lowlevel.h>
-#else
-#include <fuse.h>
+#include "squashfuse_dlopen.h"
+#ifndef ENABLE_DLOPEN
+#  if FUSE_USE_VERSION >= 30
+#  include <fuse3/fuse.h>
+#  include <fuse3/fuse_lowlevel.h>
+#  else
+#  include <fuse.h>
+#  endif
 #endif
 
 /* Common functions for FUSE high- and low-level clients */
diff -urp squashfuse-0.1.105_appimage.orig/hl.c squashfuse-0.1.105_appimage/hl.c
--- squashfuse-0.1.105_appimage.orig/hl.c	2022-06-14 17:34:42.000000000 -0700
+++ squashfuse-0.1.105_appimage/hl.c	2023-01-14 17:05:12.936703272 -0800
@@ -34,6 +34,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+int have_libloaded = 0;
 
 typedef struct sqfs_hl sqfs_hl;
 struct sqfs_hl {
@@ -43,9 +44,10 @@ struct sqfs_hl {
 
 static sqfs_err sqfs_hl_lookup(sqfs **fs, sqfs_inode *inode,
 		const char *path) {
+	LOAD_SYMBOL(struct fuse_context *,fuse_get_context,(void));
 	bool found;
 	
-	sqfs_hl *hl = fuse_get_context()->private_data;
+	sqfs_hl *hl = DL(fuse_get_context)()->private_data;
 	*fs = &hl->fs;
 	if (inode)
 		*inode = hl->root; /* copy */
@@ -72,7 +74,8 @@ static void *sqfs_hl_op_init(struct fuse
 			     ,struct fuse_config *cfg
 #endif
 			     ) {
-	return fuse_get_context()->private_data;
+	LOAD_SYMBOL(struct fuse_context *,fuse_get_context,(void));
+	return DL(fuse_get_context)()->private_data;
 }
 
 static int sqfs_hl_op_getattr(const char *path, struct stat *st
@@ -262,7 +265,8 @@ static int sqfs_hl_op_getxattr(const cha
 }
 
 static int sqfs_hl_op_statfs(const char *path, struct statvfs *st) {
-	sqfs_hl *hl = fuse_get_context()->private_data;
+	LOAD_SYMBOL(struct fuse_context *,fuse_get_context(void));
+	sqfs_hl *hl = DL(fuse_get_context)()->private_data;
 	return sqfs_statfs(&hl->fs, st);
 }
 
@@ -288,7 +292,16 @@ static sqfs_hl *sqfs_hl_open(const char
 	return NULL;
 }
 
+#ifdef ENABLE_DLOPEN
+#define fuse_main(argc, argv, op, user_data) \
+	DL(fuse_main_real)(argc, argv, op, sizeof(*(op)), user_data)
+#endif
+
 int main(int argc, char *argv[]) {
+	LOAD_SYMBOL(int,fuse_opt_parse,(struct fuse_args *args, void *data, const struct fuse_opt opts[], fuse_opt_proc_t proc));
+	LOAD_SYMBOL(int,fuse_opt_add_arg,(struct fuse_args *args, const char *arg));
+	LOAD_SYMBOL(int,fuse_main_real,(int argc, char *argv[], const struct fuse_operations *op, size_t op_size, void *user_data));  /* fuse_main */
+	LOAD_SYMBOL(void,fuse_opt_free_args,(struct fuse_args *args));
 	struct fuse_args args;
 	sqfs_opts opts;
 	sqfs_hl *hl;
@@ -324,7 +337,7 @@ int main(int argc, char *argv[]) {
 	opts.image = NULL;
 	opts.mountpoint = 0;
 	opts.offset = 0;
-	if (fuse_opt_parse(&args, &opts, fuse_opts, sqfs_opt_proc) == -1)
+	if (DL(fuse_opt_parse)(&args, &opts, fuse_opts, sqfs_opt_proc) == -1)
 		sqfs_usage(argv[0], true);
 	if (!opts.image)
 		sqfs_usage(argv[0], true);
@@ -333,8 +346,9 @@ int main(int argc, char *argv[]) {
 	if (!hl)
 		return -1;
 	
-	fuse_opt_add_arg(&args, "-s"); /* single threaded */
+	DL(fuse_opt_add_arg)(&args, "-s"); /* single threaded */
 	ret = fuse_main(args.argc, args.argv, &sqfs_hl_ops, hl);
-	fuse_opt_free_args(&args);
+	DL(fuse_opt_free_args)(&args);
+	CLOSE_LIBRARY;
 	return ret;
 }
diff -urp squashfuse-0.1.105_appimage.orig/ll.c squashfuse-0.1.105_appimage/ll.c
--- squashfuse-0.1.105_appimage.orig/ll.c	2022-06-14 17:34:42.000000000 -0700
+++ squashfuse-0.1.105_appimage/ll.c	2023-01-14 17:02:44.762843224 -0800
@@ -54,6 +54,8 @@ static struct fuse_session *fuse_instanc
 
 void sqfs_ll_op_getattr(fuse_req_t req, fuse_ino_t ino,
 		struct fuse_file_info *fi) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_attr,(fuse_req_t req, const struct stat *attr, double attr_timeout));
 	sqfs_ll_i lli;
 	struct stat st;
 	last_access = time(NULL);
@@ -61,15 +63,17 @@ void sqfs_ll_op_getattr(fuse_req_t req,
 		return;
 	
 	if (sqfs_stat(&lli.ll->fs, &lli.inode, &st)) {
-		fuse_reply_err(req, ENOENT);
+		DL(fuse_reply_err)(req, ENOENT);
 	} else {
 		st.st_ino = ino;
-		fuse_reply_attr(req, &st, SQFS_TIMEOUT);
+		DL(fuse_reply_attr)(req, &st, SQFS_TIMEOUT);
 	}
 }
 
 void sqfs_ll_op_opendir(fuse_req_t req, fuse_ino_t ino,
 		struct fuse_file_info *fi) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_open,(fuse_req_t req, const struct fuse_file_info *fi));
 	sqfs_ll_i *lli;
 	last_access = time(NULL);
 	
@@ -77,17 +81,17 @@ void sqfs_ll_op_opendir(fuse_req_t req,
 	
 	lli = malloc(sizeof(*lli));
 	if (!lli) {
-		fuse_reply_err(req, ENOMEM);
+		DL(fuse_reply_err)(req, ENOMEM);
 		return;
 	}
 	
 	if (sqfs_ll_iget(req, lli, ino) == SQFS_OK) {
 		if (!S_ISDIR(lli->inode.base.mode)) {
-			fuse_reply_err(req, ENOTDIR);
+			DL(fuse_reply_err)(req, ENOTDIR);
 		} else {
 			fi->fh = (intptr_t)lli;
 			++open_refcount;
-			fuse_reply_open(req, fi);
+			DL(fuse_reply_open)(req, fi);
 			return;
 		}
 	}
@@ -97,7 +101,8 @@ void sqfs_ll_op_opendir(fuse_req_t req,
 void sqfs_ll_op_create(fuse_req_t req, fuse_ino_t parent, const char *name,
 			      mode_t mode, struct fuse_file_info *fi) {
 	last_access = time(NULL);
-	fuse_reply_err(req, EROFS);
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	DL(fuse_reply_err)(req, EROFS);
 }
 
 void sqfs_ll_op_releasedir(fuse_req_t req, fuse_ino_t ino,
@@ -105,22 +110,28 @@ void sqfs_ll_op_releasedir(fuse_req_t re
 	last_access = time(NULL);
 	--open_refcount;
 	free((sqfs_ll_i*)(intptr_t)fi->fh);
-	fuse_reply_err(req, 0); /* yes, this is necessary */
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	DL(fuse_reply_err)(req, 0); /* yes, this is necessary */
 }
 
 size_t sqfs_ll_add_direntry(fuse_req_t req, char *buf, size_t bufsize,
 		const char *name, const struct stat *st, off_t off) {
 	#if HAVE_DECL_FUSE_ADD_DIRENTRY
-		return fuse_add_direntry(req, buf, bufsize, name, st, off);
+		LOAD_SYMBOL(size_t,fuse_add_direntry,(fuse_req_t req, char *buf, size_t bufsize, const char *name, const struct stat *stbuf, off_t off));
+		return DL(fuse_add_direntry)(req, buf, bufsize, name, st, off);
 	#else
-		size_t esize = fuse_dirent_size(strlen(name));
+		LOAD_SYMBOL(size_t,fuse_dirent_size(size_t namelen));
+		LOAD_SYMBOL(char *,fuse_add_dirent,(char *buf, const char *name, const struct stat *stbuf, off_t off));
+		size_t esize = DL(fuse_dirent_size)(strlen(name));
 		if (bufsize >= esize)
-			fuse_add_dirent(buf, name, st, off);
+			DL(fuse_add_dirent)(buf, name, st, off);
 		return esize;
 	#endif
 }
 void sqfs_ll_op_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
 		off_t off, struct fuse_file_info *fi) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_buf,(fuse_req_t req, const char *buf, size_t size));
 	sqfs_err sqerr;
 	sqfs_dir dir;
 	sqfs_name namebuf;
@@ -158,14 +169,16 @@ void sqfs_ll_op_readdir(fuse_req_t req,
 	}
 	
 	if (err)
-		fuse_reply_err(req, err);
+		DL(fuse_reply_err)(req, err);
 	else
-		fuse_reply_buf(req, buf, bufpos - buf);
+		DL(fuse_reply_buf)(req, buf, bufpos - buf);
 	free(buf);
 }
 
 void sqfs_ll_op_lookup(fuse_req_t req, fuse_ino_t parent,
 		const char *name) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_entry,(fuse_req_t req, const struct fuse_entry_param *e));
 	sqfs_ll_i lli;
 	sqfs_err sqerr;
 	sqfs_name namebuf;
@@ -178,7 +191,7 @@ void sqfs_ll_op_lookup(fuse_req_t req, f
 		return;
 	
 	if (!S_ISDIR(lli.inode.base.mode)) {
-		fuse_reply_err(req, ENOTDIR);
+		DL(fuse_reply_err)(req, ENOTDIR);
 		return;
 	}
 	
@@ -186,7 +199,7 @@ void sqfs_ll_op_lookup(fuse_req_t req, f
 	sqerr = sqfs_dir_lookup(&lli.ll->fs, &lli.inode, name, strlen(name), &entry,
 		&found);
 	if (sqerr) {
-		fuse_reply_err(req, EIO);
+		DL(fuse_reply_err)(req, EIO);
 		return;
 	}
 	if (!found) {
@@ -198,53 +211,56 @@ void sqfs_ll_op_lookup(fuse_req_t req, f
 		memset(&fentry, 0, sizeof(fentry));
 		fentry.attr_timeout = fentry.entry_timeout = SQFS_TIMEOUT;
 		fentry.ino = 0;
-		fuse_reply_entry(req, &fentry);
+		DL(fuse_reply_entry)(req, &fentry);
 		return;
 	}
 
 	if (sqfs_inode_get(&lli.ll->fs, &inode, sqfs_dentry_inode(&entry))) {
-		fuse_reply_err(req, ENOENT);
+		DL(fuse_reply_err)(req, ENOENT);
 	} else {
 		struct fuse_entry_param fentry;
 		memset(&fentry, 0, sizeof(fentry));
 		if (sqfs_stat(&lli.ll->fs, &inode, &fentry.attr)) {
-			fuse_reply_err(req, EIO);
+			DL(fuse_reply_err)(req, EIO);
 		} else {
 			fentry.attr_timeout = fentry.entry_timeout = SQFS_TIMEOUT;
 			fentry.ino = lli.ll->ino_register(lli.ll, &entry);
 			fentry.attr.st_ino = fentry.ino;
-			fuse_reply_entry(req, &fentry);
+			DL(fuse_reply_entry)(req, &fentry);
 		}
 	}
 }
 
 void sqfs_ll_op_open(fuse_req_t req, fuse_ino_t ino,
 		struct fuse_file_info *fi) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_open,(fuse_req_t req, const struct fuse_file_info *fi));
+	LOAD_SYMBOL(void *,fuse_req_userdata,(fuse_req_t req));
 	sqfs_inode *inode;
 	sqfs_ll *ll;
 	
 	last_access = time(NULL);
 	if (fi->flags & (O_WRONLY | O_RDWR)) {
-		fuse_reply_err(req, EROFS);
+		DL(fuse_reply_err)(req, EROFS);
 		return;
 	}
 	
 	inode = malloc(sizeof(sqfs_inode));
 	if (!inode) {
-		fuse_reply_err(req, ENOMEM);
+		DL(fuse_reply_err)(req, ENOMEM);
 		return;
 	}
 	
-	ll = fuse_req_userdata(req);
+	ll = DL(fuse_req_userdata)(req);
 	if (sqfs_ll_inode(ll, inode, ino)) {
-		fuse_reply_err(req, ENOENT);
+		DL(fuse_reply_err)(req, ENOENT);
 	} else if (!S_ISREG(inode->base.mode)) {
-		fuse_reply_err(req, EISDIR);
+		DL(fuse_reply_err)(req, EISDIR);
 	} else {
 		fi->fh = (intptr_t)inode;
 		fi->keep_cache = 1;
 		++open_refcount;
-		fuse_reply_open(req, fi);
+		DL(fuse_reply_open)(req, fi);
 		return;
 	}
 	free(inode);
@@ -252,23 +268,27 @@ void sqfs_ll_op_open(fuse_req_t req, fus
 
 void sqfs_ll_op_release(fuse_req_t req, fuse_ino_t ino,
 		struct fuse_file_info *fi) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
 	free((sqfs_inode*)(intptr_t)fi->fh);
 	fi->fh = 0;
 	last_access = time(NULL);
 	--open_refcount;
-	fuse_reply_err(req, 0);
+	DL(fuse_reply_err)(req, 0);
 }
 
 void sqfs_ll_op_read(fuse_req_t req, fuse_ino_t ino,
 		size_t size, off_t off, struct fuse_file_info *fi) {
-	sqfs_ll *ll = fuse_req_userdata(req);
+	LOAD_SYMBOL(void *,fuse_req_userdata,(fuse_req_t req));
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_buf,(fuse_req_t req, const char *buf, size_t size));
+	sqfs_ll *ll = DL(fuse_req_userdata)(req);
 	sqfs_inode *inode = (sqfs_inode*)(intptr_t)fi->fh;
 	sqfs_err err = SQFS_OK;
 	
 	off_t osize;
 	char *buf = malloc(size);
 	if (!buf) {
-		fuse_reply_err(req, ENOMEM);
+		DL(fuse_reply_err)(req, ENOMEM);
 		return;
 	}
 	
@@ -276,16 +296,18 @@ void sqfs_ll_op_read(fuse_req_t req, fus
 	osize = size;
 	err = sqfs_read_range(&ll->fs, inode, off, &osize, buf);
 	if (err) {
-		fuse_reply_err(req, EIO);
+		DL(fuse_reply_err)(req, EIO);
 	} else if (osize == 0) { /* EOF */
-		fuse_reply_buf(req, NULL, 0);
+		DL(fuse_reply_buf)(req, NULL, 0);
 	} else {
-		fuse_reply_buf(req, buf, osize);
+		DL(fuse_reply_buf)(req, buf, osize);
 	}
 	free(buf);
 }
 
 void sqfs_ll_op_readlink(fuse_req_t req, fuse_ino_t ino) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_readlink,(fuse_req_t req, const char *link));
 	char *dst;
 	size_t size;
 	sqfs_ll_i lli;
@@ -294,21 +316,24 @@ void sqfs_ll_op_readlink(fuse_req_t req,
 		return;
 	
 	if (!S_ISLNK(lli.inode.base.mode)) {
-		fuse_reply_err(req, EINVAL);
+		DL(fuse_reply_err)(req, EINVAL);
 	} else if (sqfs_readlink(&lli.ll->fs, &lli.inode, NULL, &size)) {
-		fuse_reply_err(req, EIO);
+		DL(fuse_reply_err)(req, EIO);
 	} else if (!(dst = malloc(size + 1))) {
-		fuse_reply_err(req, ENOMEM);
+		DL(fuse_reply_err)(req, ENOMEM);
 	} else if (sqfs_readlink(&lli.ll->fs, &lli.inode, dst, &size)) {
-		fuse_reply_err(req, EIO);
+		DL(fuse_reply_err)(req, EIO);
 		free(dst);
 	} else {
-		fuse_reply_readlink(req, dst);
+		DL(fuse_reply_readlink)(req, dst);
 		free(dst);
 	}
 }
 
 void sqfs_ll_op_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_xattr,(fuse_req_t req, size_t count));
+	LOAD_SYMBOL(int,fuse_reply_buf,(fuse_req_t req, const char *buf, size_t size));
 	sqfs_ll_i lli;
 	char *buf;
 	int ferr;
@@ -319,17 +344,17 @@ void sqfs_ll_op_listxattr(fuse_req_t req
 
 	buf = NULL;
 	if (size && !(buf = malloc(size))) {
-		fuse_reply_err(req, ENOMEM);
+		DL(fuse_reply_err)(req, ENOMEM);
 		return;
 	}
 	
 	ferr = sqfs_listxattr(&lli.ll->fs, &lli.inode, buf, &size);
 	if (ferr) {
-		fuse_reply_err(req, ferr);
+		DL(fuse_reply_err)(req, ferr);
 	} else if (buf) {
-		fuse_reply_buf(req, buf, size);
+		DL(fuse_reply_buf)(req, buf, size);
 	} else {
-		fuse_reply_xattr(req, size);
+		DL(fuse_reply_xattr)(req, size);
 	}
 	free(buf);
 }
@@ -340,13 +365,16 @@ void sqfs_ll_op_getxattr(fuse_req_t req,
 		, uint32_t position
 #endif
 		) {
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_xattr,(fuse_req_t req, size_t count));
+	LOAD_SYMBOL(int,fuse_reply_buf,(fuse_req_t req, const char *buf, size_t size));
 	sqfs_ll_i lli;
 	char *buf = NULL;
 	size_t real = size;
 
 #ifdef FUSE_XATTR_POSITION
 	if (position != 0) { /* We don't support resource forks */
-		fuse_reply_err(req, EINVAL);
+		DL(fuse_reply_err)(req, EINVAL);
 		return;
 	}
 #endif
@@ -356,27 +384,28 @@ void sqfs_ll_op_getxattr(fuse_req_t req,
 		return;
 	
 	if (!(buf = malloc(size)))
-		fuse_reply_err(req, ENOMEM);
+		DL(fuse_reply_err)(req, ENOMEM);
 	else if (sqfs_xattr_lookup(&lli.ll->fs, &lli.inode, name, buf, &real))
-		fuse_reply_err(req, EIO);
+		DL(fuse_reply_err)(req, EIO);
 	else if (real == 0)
-		fuse_reply_err(req, sqfs_enoattr());
+		DL(fuse_reply_err)(req, sqfs_enoattr());
 	else if (size == 0)
-		fuse_reply_xattr(req, real);
+		DL(fuse_reply_xattr)(req, real);
 	else if (size < real)
-		fuse_reply_err(req, ERANGE);
+		DL(fuse_reply_err)(req, ERANGE);
 	else
-		fuse_reply_buf(req, buf, real);
+		DL(fuse_reply_buf)(req, buf, real);
 	free(buf);
 }
 
 void sqfs_ll_op_forget(fuse_req_t req, fuse_ino_t ino,
 		unsigned long nlookup) {
+	LOAD_SYMBOL(void,fuse_reply_none,(fuse_req_t req));
 	sqfs_ll_i lli;
 	last_access = time(NULL);
 	sqfs_ll_iget(req, &lli, SQFS_FUSE_INODE_NONE);
 	lli.ll->ino_forget(lli.ll, ino, nlookup);
-	fuse_reply_none(req);
+	DL(fuse_reply_none)(req);
 }
 
 void stfs_ll_op_statfs(fuse_req_t req, fuse_ino_t ino) {
@@ -384,12 +413,15 @@ void stfs_ll_op_statfs(fuse_req_t req, f
 	struct statvfs st;
 	int err;
 
-	ll = fuse_req_userdata(req);
+	LOAD_SYMBOL(void *,fuse_req_userdata,(fuse_req_t req));
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
+	LOAD_SYMBOL(int,fuse_reply_statfs,(fuse_req_t req, const struct statvfs *stbuf));
+	ll = DL(fuse_req_userdata)(req);
 	err = sqfs_statfs(&ll->fs, &st);
 	if (err == 0) {
-		fuse_reply_statfs(req, &st);
+		DL(fuse_reply_statfs)(req, &st);
 	} else {
-		fuse_reply_err(req, err);
+		DL(fuse_reply_err)(req, err);
 	}
 }
 
@@ -403,12 +435,15 @@ sqfs_err sqfs_ll_mount(
         struct fuse_lowlevel_ops *ops,
         size_t ops_size,
         void *userdata) {
-	ch->session = fuse_session_new(args, ops, ops_size, userdata);
+	LOAD_SYMBOL(struct fuse_session *,fuse_session_new,(struct fuse_args *args, const struct fuse_lowlevel_ops *op, size_t op_size, void *userdata));
+	LOAD_SYMBOL(int,fuse_session_mount,(struct fuse_session *se, const char *mountpoint));
+	LOAD_SYMBOL(void,fuse_session_destroy,(struct fuse_session *se));
+	ch->session = DL(fuse_session_new)(args, ops, ops_size, userdata);
 	if (!ch->session) {
 		return SQFS_ERR;
 	}
-	if (fuse_session_mount(ch->session, mountpoint)) {
-		fuse_session_destroy(ch->session);
+	if (DL(fuse_session_mount)(ch->session, mountpoint)) {
+		DL(fuse_session_destroy)(ch->session);
 		ch->session = NULL;
 		return SQFS_ERR;
 	}
@@ -416,25 +451,30 @@ sqfs_err sqfs_ll_mount(
 }
 
 void sqfs_ll_unmount(sqfs_ll_chan *ch, const char *mountpoint) {
-	fuse_session_unmount(ch->session);
-	fuse_session_destroy(ch->session);
+	LOAD_SYMBOL(void,fuse_session_unmount,(struct fuse_session *se));
+	LOAD_SYMBOL(void,fuse_session_destroy,(struct fuse_session *se));
+	DL(fuse_session_unmount)(ch->session);
+	DL(fuse_session_destroy)(ch->session);
 	ch->session = NULL;
 }
 
 #else /* FUSE_USE_VERSION >= 30 */
-
 void sqfs_ll_unmount(sqfs_ll_chan *ch, const char *mountpoint) {
+	LOAD_SYMBOL(void,fuse_session_remove_chan,(struct fuse_chan *ch));
+	LOAD_SYMBOL(void,fuse_session_destroy,(struct fuse_session *se));
 	if (ch->session) {
 #if HAVE_DECL_FUSE_SESSION_REMOVE_CHAN
-		fuse_session_remove_chan(ch->ch);
+		DL(fuse_session_remove_chan)(ch->ch);
 #endif
-		fuse_session_destroy(ch->session);
+		DL(fuse_session_destroy)(ch->session);
 	}
 #ifdef HAVE_NEW_FUSE_UNMOUNT
-	fuse_unmount(mountpoint, ch->ch);
+	LOAD_SYMBOL(void,fuse_unmount,(const char *mountpoint, struct fuse_chan *ch));
+	DL(fuse_unmount)(mountpoint, ch->ch);
 #else
+	LOAD_SYMBOL(void,fuse_unmount,(struct fuse *f));
 	close(ch->fd);
-	fuse_unmount(mountpoint);
+	DL(fuse_unmount)(mountpoint);
 #endif
 }
 
@@ -445,29 +485,34 @@ sqfs_err sqfs_ll_mount(
 		struct fuse_lowlevel_ops *ops,
 		size_t ops_size,
 		void *userdata) {
+	LOAD_SYMBOL(int,fuse_mount,(struct fuse *f, const char *mountpoint));
+	LOAD_SYMBOL(void,fuse_session_add_chan,(struct fuse_session *se, struct fuse_chan *ch));
+	LOAD_SYMBOL(struct fuse_session *,fuse_lowlevel_new,(struct fuse_args *args,
+				       const struct fuse_lowlevel_ops *op,
+				       size_t op_size, void *userdata));
 #ifdef HAVE_NEW_FUSE_UNMOUNT
-	ch->ch = fuse_mount(mountpoint, args);
+	ch->ch = DL(fuse_mount)(mountpoint, args);
 	if (!ch->ch) {
 		return SQFS_ERR;
 	}
 #else
-	ch->fd = fuse_mount(mountpoint, args);
+	LOAD_SYMBOL(struct fuse_chan *,fuse_kern_chan_new,(int fd););
+	ch->fd = DL(fuse_mount)(mountpoint, args);
 	if (ch->fd == -1)
 		return SQFS_ERR;
-	ch->ch = fuse_kern_chan_new(ch->fd);
+	ch->ch = DL(fuse_kern_chan_new)(ch->fd);
 	if (!ch->ch) {
 		close(ch->fd);
 		return SQFS_ERR;
 	}
 #endif
-
-	ch->session = fuse_lowlevel_new(args,
+	ch->session = DL(fuse_lowlevel_new)(args,
 			ops, sizeof(*ops), userdata);
 	if (!ch->session) {
 		sqfs_ll_unmount(ch, mountpoint);
 		return SQFS_ERR;
 	}
-	fuse_session_add_chan(ch->session, ch->ch);
+	DL(fuse_session_add_chan)(ch->session, ch->ch);
 	return SQFS_OK;
 }
 
diff -urp squashfuse-0.1.105_appimage.orig/ll.h squashfuse-0.1.105_appimage/ll.h
--- squashfuse-0.1.105_appimage.orig/ll.h	2022-06-14 17:34:42.000000000 -0700
+++ squashfuse-0.1.105_appimage/ll.h	2023-01-14 17:02:44.766843383 -0800
@@ -27,10 +27,13 @@
 
 #include "squashfuse.h"
 
-#if FUSE_USE_VERSION >= 30
-#include <fuse3/fuse_lowlevel.h>
-#else
-#include <fuse_lowlevel.h>
+#include "squashfuse_dlopen.h"
+#ifndef ENABLE_DLOPEN
+#  if FUSE_USE_VERSION >= 30
+#  include <fuse3/fuse_lowlevel.h>
+#  else
+#  include <fuse_lowlevel.h>
+#  endif
 #endif
 
 typedef struct sqfs_ll sqfs_ll;
diff -urp squashfuse-0.1.105_appimage.orig/ll_inode.c squashfuse-0.1.105_appimage/ll_inode.c
--- squashfuse-0.1.105_appimage.orig/ll_inode.c	2022-06-14 17:34:42.000000000 -0700
+++ squashfuse-0.1.105_appimage/ll_inode.c	2023-01-14 17:02:44.766843383 -0800
@@ -348,12 +348,14 @@ sqfs_err sqfs_ll_inode(sqfs_ll *ll, sqfs
 
 
 sqfs_err sqfs_ll_iget(fuse_req_t req, sqfs_ll_i *lli, fuse_ino_t i) {
+	LOAD_SYMBOL(void *,fuse_req_userdata,(fuse_req_t req));
+	LOAD_SYMBOL(int,fuse_reply_err,(fuse_req_t req, int err));
 	sqfs_err err = SQFS_OK;
-	lli->ll = fuse_req_userdata(req);
+	lli->ll = DL(fuse_req_userdata)(req);
 	if (i != SQFS_FUSE_INODE_NONE) {
 		err = sqfs_ll_inode(lli->ll, &lli->inode, i);
 		if (err)
-			fuse_reply_err(req, ENOENT);
+			DL(fuse_reply_err)(req, ENOENT);
 	}
 	return err;
 }
diff -urp squashfuse-0.1.105_appimage.orig/ll_main.c squashfuse-0.1.105_appimage/ll_main.c
--- squashfuse-0.1.105_appimage.orig/ll_main.c	2023-01-14 17:01:51.768747393 -0800
+++ squashfuse-0.1.105_appimage/ll_main.c	2023-01-14 17:02:44.766843383 -0800
@@ -38,6 +38,17 @@
 #include <unistd.h>
 
 int fusefs_main(int argc, char *argv[], void (*mounted) (void)) {
+	LOAD_SYMBOL(int,fuse_opt_parse,(struct fuse_args *args, void *data, const struct fuse_opt opts[], fuse_opt_proc_t proc));
+	LOAD_SYMBOL(struct fuse_session *,fuse_lowlevel_new,(struct fuse_args *args, const struct fuse_lowlevel_ops *op, size_t op_size, void *userdata));
+	LOAD_SYMBOL(int,fuse_set_signal_handlers,(struct fuse_session *se));
+	LOAD_SYMBOL(void,fuse_session_add_chan,(struct fuse_session *se, struct fuse_chan *ch));
+	LOAD_SYMBOL(int,fuse_session_loop,(struct fuse_session *se));
+	LOAD_SYMBOL(void,fuse_remove_signal_handlers,(struct fuse_session *se));
+#if HAVE_DECL_FUSE_SESSION_REMOVE_CHAN
+	LOAD_SYMBOL(void,fuse_session_remove_chan,(struct fuse_chan *ch));
+#endif
+	LOAD_SYMBOL(void,fuse_session_destroy,(struct fuse_session *se));
+	LOAD_SYMBOL(void,fuse_opt_free_args,(struct fuse_args *args));
 	struct fuse_args args;
 	sqfs_opts opts;
 
@@ -85,13 +96,15 @@ int fusefs_main(int argc, char *argv[],
 	opts.mountpoint = 0;
 	opts.offset = 0;
 	opts.idle_timeout_secs = 0;
-	if (fuse_opt_parse(&args, &opts, fuse_opts, sqfs_opt_proc) == -1)
+	if (DL(fuse_opt_parse)(&args, &opts, fuse_opts, sqfs_opt_proc) == -1)
 		sqfs_usage(argv[0], true);
 
 #if FUSE_USE_VERSION >= 30
-	if (fuse_parse_cmdline(&args, &fuse_cmdline_opts) != 0)
+	LOAD_SYMBOL(int,fuse_parse_cmdline,(struct fuse_args *args, struct fuse_cmdline_opts *opts));
+	if (DL(fuse_parse_cmdline)(&args, &fuse_cmdline_opts) != 0)
 #else
-	if (fuse_parse_cmdline(&args,
+	LOAD_SYMBOL(int,fuse_parse_cmdline,(struct fuse_args *args, char **mountpoint, int *multithreaded, int *foreground));
+	if (DL(fuse_parse_cmdline)(&args,
                            &fuse_cmdline_opts.mountpoint,
                            &fuse_cmdline_opts.mt,
                            &fuse_cmdline_opts.foreground) == -1)
@@ -138,27 +151,28 @@ int fusefs_main(int argc, char *argv[],
                         sizeof(sqfs_ll_ops),
                         ll) == SQFS_OK) {
 			if (sqfs_ll_daemonize(fuse_cmdline_opts.foreground) != -1) {
-				if (fuse_set_signal_handlers(ch.session) != -1) {
+				if (DL(fuse_set_signal_handlers)(ch.session) != -1) {
 					if (opts.idle_timeout_secs) {
 						setup_idle_timeout(ch.session, opts.idle_timeout_secs);
 					}
 					if (mounted)
 						mounted ();
 					/* FIXME: multithreading */
-					err = fuse_session_loop(ch.session);
+					err = DL(fuse_session_loop)(ch.session);
 					teardown_idle_timeout();
-					fuse_remove_signal_handlers(ch.session);
+					DL(fuse_remove_signal_handlers)(ch.session);
 				}
 			}
 			sqfs_ll_destroy(ll);
 			sqfs_ll_unmount(&ch, fuse_cmdline_opts.mountpoint);
 		}
 	}
-	fuse_opt_free_args(&args);
+	DL(fuse_opt_free_args)(&args);
 	free(ll);
 	if (mounted)
 		rmdir (fuse_cmdline_opts.mountpoint);
 	free(fuse_cmdline_opts.mountpoint);
+	CLOSE_LIBRARY;
 	
 	return -err;
 }
diff -urp squashfuse-0.1.105_appimage.orig/nonstd-daemon.c squashfuse-0.1.105_appimage/nonstd-daemon.c
--- squashfuse-0.1.105_appimage.orig/nonstd-daemon.c	2022-06-14 17:34:42.000000000 -0700
+++ squashfuse-0.1.105_appimage/nonstd-daemon.c	2023-01-14 17:02:44.766843383 -0800
@@ -28,15 +28,19 @@
 #include "nonstd-internal.h"
 
 #include <unistd.h>
-#if FUSE_USE_VERSION >= 30
-#include <fuse3/fuse_lowlevel.h>
-#else
-#include <fuse_lowlevel.h>
+#include "squashfuse_dlopen.h"
+#ifndef ENABLE_DLOPEN
+#  if FUSE_USE_VERSION >= 30
+#  include <fuse3/fuse_lowlevel.h>
+#  else
+#  include <fuse_lowlevel.h>
+#  endif
 #endif
 
 int sqfs_ll_daemonize(int fg) {
 	#if HAVE_DECL_FUSE_DAEMONIZE
-		return fuse_daemonize(fg);
+		LOAD_SYMBOL(int,fuse_daemonize,(int foreground));
+		return DL(fuse_daemonize)(fg);
 	#else
 		return daemon(0,0);
 	#endif
