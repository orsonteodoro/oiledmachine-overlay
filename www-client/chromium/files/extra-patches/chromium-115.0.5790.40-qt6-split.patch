--- a/ui/qt/qt.gni.orig	2023-06-28 09:42:06.614272800 -0700
+++ b/ui/qt/qt.gni	2023-07-05 19:29:09.034457312 -0700
@@ -13,8 +13,19 @@ declare_args() {
 }
 
 declare_args() {
+  if(!use_sysroot && use_qt) {
+     moc_qt5_path = ""
+  }
+}
+
+declare_args() {
   use_qt6 = use_qt && use_sysroot
 }
 
-# use_qt6 => use_qt
-assert(!use_qt6 || use_qt)
+declare_args() {
+  if(!use_sysroot && use_qt6) {
+     moc_qt6_path = ""
+  }
+}
+
+assert(use_qt || use_qt6)
--- a/ui/linux/BUILD.gn.orig	2023-06-28 09:42:06.530264600 -0700
+++ b/ui/linux/BUILD.gn	2023-07-05 19:27:06.378454812 -0700
@@ -63,7 +63,7 @@ component("linux_ui_factory") {
     # This is the only component that can interact with gtk.
     deps += [ "//ui/gtk" ]
   }
-  if (use_qt) {
+  if (use_qt || use_qt6) {
     deps += [ "//ui/qt" ]
   }
 }
--- a/ui/base/BUILD.gn.orig	2023-06-28 09:42:06.090221200 -0700
+++ b/ui/base/BUILD.gn	2023-07-05 19:27:06.378454812 -0700
@@ -100,6 +100,7 @@ buildflag_header("buildflags") {
     "HAS_PLATFORM_ACCESSIBILITY_SUPPORT=$has_platform_accessibility_support",
     "USE_GTK=$use_gtk",
     "USE_QT=$use_qt",
+    "USE_QT6=$use_qt6",
   ]
 }
 
--- a/ui/linux/linux_ui_factory.cc.orig	2023-06-28 09:42:06.530264600 -0700
+++ b/ui/linux/linux_ui_factory.cc	2023-07-05 19:27:06.378454812 -0700
@@ -21,7 +21,7 @@
 #if BUILDFLAG(USE_GTK)
 #include "ui/gtk/gtk_ui_factory.h"
 #endif
-#if BUILDFLAG(USE_QT)
+#if BUILDFLAG(USE_QT) || BUILDFLAG(USE_QT6)
 #include "ui/qt/qt_ui.h"
 #endif
 
@@ -58,7 +58,7 @@ std::unique_ptr<LinuxUiAndTheme> CreateQ
   if (!base::FeatureList::IsEnabled(kAllowQt)) {
     return nullptr;
   }
-#if BUILDFLAG(USE_QT)
+#if BUILDFLAG(USE_QT) || BUILDFLAG(USE_QT6)
   auto qt_ui = qt::CreateQtUi(GetGtkUi());
   if (qt_ui->Initialize()) {
     return qt_ui;
--- a/ui/qt/BUILD.gn.orig	2023-06-28 09:42:06.614272800 -0700
+++ b/ui/qt/BUILD.gn	2023-07-05 19:47:46.274480090 -0700
@@ -7,7 +7,7 @@ import("//build/config/linux/pkg_config.
 import("//build/config/sysroot.gni")
 import("//ui/qt/qt.gni")
 
-assert(use_qt)
+assert(use_qt || use_qt6)
 assert(is_linux)
 assert(!is_castos)
 
@@ -40,12 +40,17 @@ source_set("qt_interface") {
   sources = [ "qt_interface.cc" ]
 }
 
-if (!use_sysroot) {
-  action("generate_moc") {
-    script = "moc_wrapper.py"
-    inputs = [ "//ui/qt/qt_shim.h" ]
-    outputs = [ "$root_gen_dir/qt_shim_moc.cc" ]
-    args = rebase_path(inputs + outputs, root_build_dir)
+template("qt_shim") {
+  if (!use_sysroot) {
+    action("generate_moc" + invoker.qt_version) {
+      script = "moc_wrapper.py"
+      inputs = [ "//ui/qt/qt_shim.h" ]
+      outputs = [ "$root_gen_dir/qt" + invoker.qt_version + "/qt_shim_moc.cc" ]
+      args = rebase_path(inputs + outputs, root_build_dir)
+      if (invoker.moc_qt_path != "") {
+        args += [ "--path", invoker.moc_qt_path ]
+      }
+    }
   }
 }
 
@@ -89,18 +94,26 @@ template("qt_shim") {
       # avoid a build-time dependency on `moc` when using the sysroot.
       sources += [ "qt" + invoker.qt_version + "_shim_moc.cc" ]
     } else {
-      sources += get_target_outputs(":generate_moc")
-      deps += [ ":generate_moc" ]
+      sources += get_target_outputs(":generate_moc" + invoker.qt_version)
+      deps += [ ":generate_moc" + invoker.qt_version ]
     }
   }
 }
-qt_shim("qt5_shim") {
-  qt_version = "5"
+if (use_qt) {
+  qt_shim("qt5_shim") {
+    qt_version = "5"
+  }
+  if (!use_sysroot) {
+    moc_qt_path = "$moc_qt5_path"
+  }
 }
 if (use_qt6) {
   qt_shim("qt6_shim") {
     qt_version = "6"
   }
+  if (!use_sysroot) {
+    moc_qt_path = "$moc_qt6_path"
+  }
 }
 
 component("qt") {
@@ -109,7 +122,10 @@ component("qt") {
   defines = [ "IS_QT_IMPL" ]
 
   # qt_shim is in data_deps since we want to load it manually.
-  data_deps = [ ":qt5_shim" ]
+  data_deps = []
+  if (use_qt) {
+    data_deps = [ ":qt5_shim" ]
+  }
   if (use_qt6) {
     data_deps += [ ":qt6_shim" ]
   }
--- a/ui/qt/moc_wrapper.py.orig	2023-06-28 09:42:06.614272800 -0700
+++ b/ui/qt/moc_wrapper.py	2023-07-05 19:49:03.986481674 -0700
@@ -3,8 +3,20 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import argparse
 import subprocess
-import sys
 
+parser = argparse.ArgumentParser()
+parser.add_argument(
+    'input', type=str, help='Input header file.')
+parser.add_argument(
+    'output', type=str, help='Output file.')
+parser.add_argument(
+    '--path', required=False, type=str, default=None,
+    help='Path to moc binary.')
+args = parser.parse_args()
 
-subprocess.check_call(["moc", sys.argv[1], "-o", sys.argv[2]])
+if args.path is None:
+    subprocess.check_call(["moc", args.input, "-o", args.output])
+else:
+    subprocess.check_call([args.path + "/moc", args.input, "-o", args.output])
