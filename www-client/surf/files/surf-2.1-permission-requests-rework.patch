Subject:       [WIP] Rework permissions per domain, with changes for MediaStream
Patch author:  Orson Teodoro
Patch status:  Unfinished patch / Work in Progress (WIP)
Date:          Fri Jul 16 07:28:15 PM PDT 2021 (Unix time: 1626488895)

Currently upstream allows geolocation across many domains, but should
consent per domain.  This patch will address this problem.

Changes for more extensive use of dmenu for accept or rejection of permissions.

diff -urp surf-2.1_p20210521.orig/config.def.h surf-2.1_p20210521/config.def.h
--- surf-2.1_p20210521.orig/config.def.h	2021-07-16 23:13:13.272007596 -0700
+++ surf-2.1_p20210521/config.def.h	2021-07-16 23:13:40.729112946 -0700
@@ -15,8 +15,7 @@ static char *cookiefile     = "~/.surf/c
  */
 static Parameter defconfig[ParameterLast] = {
 	/* parameter                    Arg value       priority */
-	[AccessMicrophone]    =       { { .i = 0 },     },
-	[AccessWebcam]        =       { { .i = 0 },     },
+	[AccessMediaStream]   =       { { .i = 0 },     },
 	[Certificate]         =       { { .i = 0 },     },
 	[CaretBrowsing]       =       { { .i = 0 },     },
 	[CookiePolicies]      =       { { .v = "@Aa" }, },
diff -urp surf-2.1_p20210521.orig/surf.c surf-2.1_p20210521/surf.c
--- surf-2.1_p20210521.orig/surf.c	2021-07-16 23:13:13.312009205 -0700
+++ surf-2.1_p20210521/surf.c	2021-07-16 23:20:41.058034282 -0700
@@ -37,7 +37,7 @@
 #define LENGTH(x)               (sizeof(x) / sizeof(x[0]))
 #define CLEANMASK(mask)         (mask & (MODKEY|GDK_SHIFT_MASK))
 
-enum { AtomFind, AtomGo, AtomUri, AtomLast };
+enum { AtomFind, AtomGo, AtomUri, AtomGeolocation, AtomMediaStream, AtomInputQuery, AtomLast };
 
 enum {
 	OnDoc   = WEBKIT_HIT_TEST_RESULT_CONTEXT_DOCUMENT,
@@ -51,8 +51,7 @@ enum {
 };
 
 typedef enum {
-	AccessMicrophone,
-	AccessWebcam,
+	AccessMediaStream,
 	CaretBrowsing,
 	Certificate,
 	CookiePolicies,
@@ -255,6 +254,10 @@ static Parameter *curconfig;
 static int modparams[ParameterLast];
 static int spair[2];
 char *argv0;
+static GHashTable *acceptedGeolocationDomains;
+static GHashTable *acceptedInputQueryDomains;
+static GHashTable *acceptedMediaStreamDomains;
+static GHashTable *permissionRequests;
 
 static ParamName loadtransient[] = {
 	Certificate,
@@ -271,8 +274,7 @@ static ParamName loadtransient[] = {
 };
 
 static ParamName loadcommitted[] = {
-//	AccessMicrophone,
-//	AccessWebcam,
+	AccessMediaStream,
 	CaretBrowsing,
 	DefaultCharset,
 	FontSize,
@@ -321,6 +323,12 @@ usage(void)
 }
 
 void
+cancelpermissionrequest(WebKitPermissionRequest *r)
+{
+	webkit_permission_request_deny(r);
+}
+
+void
 setup(void)
 {
 	GIOChannel *gchanin;
@@ -339,6 +347,9 @@ setup(void)
 	atoms[AtomFind] = XInternAtom(dpy, "_SURF_FIND", False);
 	atoms[AtomGo] = XInternAtom(dpy, "_SURF_GO", False);
 	atoms[AtomUri] = XInternAtom(dpy, "_SURF_URI", False);
+	atoms[AtomGeolocation] = XInternAtom(dpy, "_SURF_GEOL", False);
+	atoms[AtomMediaStream] = XInternAtom(dpy, "_SURF_MEST", False);
+	atoms[AtomInputQuery] = XInternAtom(dpy, "_SURF_INQU", False);
 
 	gtk_init(NULL, NULL);
 
@@ -414,6 +425,11 @@ setup(void)
 				uriparams[i].config[j] = defconfig[j];
 		}
 	}
+
+	acceptedGeolocationDomains = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+	acceptedInputQueryDomains = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+	acceptedMediaStreamDomains = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+	permissionRequests = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, cancelpermissionrequest);
 }
 
 void
@@ -672,6 +688,7 @@ gettogglestats(Client *c)
 	togglestats[7] = curconfig[FrameFlattening].val.i ? 'F' : 'f';
 	togglestats[8] = curconfig[Certificate].val.i ?     'X' : 'x';
 	togglestats[9] = curconfig[StrictTLS].val.i ?       'T' : 't';
+	togglestats[10] = curconfig[AccessMediaStream].val.i ?   'O' : 'o';
 }
 
 void
@@ -751,10 +768,9 @@ setparameter(Client *c, int refresh, Par
 	modparams[p] = curconfig[p].prio;
 
 	switch (p) {
-	case AccessMicrophone:
-		return; /* do nothing */
-	case AccessWebcam:
-		return; /* do nothing */
+	case AccessMediaStream:
+		webkit_settings_set_enable_media_stream(s, a->i);
+		break; /* do nothing */
 	case CaretBrowsing:
 		webkit_settings_set_enable_caret_browsing(s, a->i);
 		refresh = 0;
@@ -1030,6 +1046,7 @@ newwindow(Client *c, const Arg *a, int n
 	}
 	if (showxid)
 		cmd[i++] = "-w";
+	cmd[i++] = curconfig[AccessMediaStream].val.i ? "-O" : "-o" ;
 	cmd[i++] = curconfig[Certificate].val.i ? "-X" : "-x" ;
 	/* do not keep zoom level */
 	cmd[i++] = "--";
@@ -1081,6 +1098,11 @@ cleanup(void)
 	while (clients)
 		destroyclient(clients);
 
+	g_hash_table_destroy(acceptedGeolocationDomains);
+	g_hash_table_destroy(acceptedInputQueryDomains);
+	g_hash_table_destroy(acceptedMediaStreamDomains);
+	g_hash_table_destroy(permissionRequests);
+
 	close(spair[0]);
 	close(spair[1]);
 	g_free(cookiefile);
@@ -1117,6 +1139,7 @@ newview(Client *c, WebKitWebView *rv)
 		   "enable-html5-local-storage", curconfig[DiskCache].val.i,
 		   "enable-java", curconfig[Java].val.i,
 		   "enable-javascript", curconfig[JavaScript].val.i,
+		   "enable-media-stream", curconfig[AccessMediaStream].val.i,
 		   "enable-site-specific-quirks", curconfig[SiteQuirks].val.i,
 		   "enable-smooth-scrolling", curconfig[SmoothScrolling].val.i,
 		   "enable-webgl", curconfig[WebGL].val.i,
@@ -1305,6 +1328,123 @@ buttonreleased(GtkWidget *w, GdkEvent *e
 	return FALSE;
 }
 
+void
+addgeolocationdomain(Client *c, const Arg *a)
+{
+	gchar *nprop = "_SURF_GEOL";
+	const char *raw = a->v;
+	gchar **ar;
+	ar = g_strsplit(raw, "|", 2);
+	gchar *origin = ar[0];
+	gchar *uchoice = ar[1];
+
+	fprintf(stdout, "surf:  called addgeolocationdomain() callback");
+	WebKitPermissionRequest *r;
+
+	gchar *key;
+	key = g_strdup_printf("%s|%s", origin, nprop);
+	r = g_hash_table_lookup(permissionRequests, key);
+
+	if (!r) {
+		fprintf(stdout, "surf:  r is null in addgeolocationdomain");
+		exit(1);
+	}
+
+	if (!g_strcmp0(uchoice, "ACCEPT")) {
+		gchar *d = g_strdup(origin);
+		g_hash_table_add(acceptedGeolocationDomains, d);
+		webkit_permission_request_allow(r);
+	} else {
+		webkit_permission_request_deny(r);
+	}
+	g_strfreev(ar);
+
+	gpointer oldkey;
+	gpointer oldvalue;
+	g_hash_table_lookup_extended(permissionRequests, key, &oldkey, &oldvalue);
+	g_hash_table_steal(permissionRequests, key);
+	g_free(key);
+	g_free(oldkey);
+}
+
+void
+addmediastreamdomain(Client *c, const Arg *a)
+{
+	gchar *nprop = "_SURF_MEST";
+	const char *raw = a->v;
+	gchar **ar;
+	ar = g_strsplit(raw, "|", 2);
+	gchar *origin = ar[0];
+	gchar *uchoice = ar[1];
+
+	fprintf(stdout, "surf:  called addmediastreamdomain() callback");
+	WebKitPermissionRequest *r;
+
+	gchar *key;
+	key = g_strdup_printf("%s|%s", origin, nprop);
+	r = g_hash_table_lookup(permissionRequests, key);
+
+	if (!r) {
+		fprintf(stdout, "surf:  r is null in addmediastreamdomain");
+		exit(1);
+	}
+
+	if (!g_strcmp0(uchoice, "ACCEPT")) {
+		gchar *d = g_strdup(origin);
+		g_hash_table_add(acceptedMediaStreamDomains, d);
+		webkit_permission_request_allow(r);
+	} else {
+		webkit_permission_request_deny(r);
+	}
+
+	g_strfreev(ar);
+
+	gpointer oldkey;
+	gpointer oldvalue;
+	g_hash_table_lookup_extended(permissionRequests, key, &oldkey, &oldvalue);
+	g_hash_table_steal(permissionRequests, key);
+	g_free(key);
+	g_free(oldkey);
+}
+
+void
+addinputquerydomain(Client *c, const Arg *a)
+{
+	char *nprop = "_SURF_INQU";
+	const char *raw = a->v;
+	gchar **ar;
+	ar = g_strsplit(raw, "|", 2);
+	gchar *origin = ar[0];
+	gchar *uchoice = ar[1];
+
+	WebKitPermissionRequest *r;
+
+	gchar *key;
+	key = g_strdup_printf("%s|%s", origin, nprop);
+	r = g_hash_table_lookup(permissionRequests, key);
+
+	if (!r) {
+		fprintf(stdout, "surf:  r is null in addinputquerydomain");
+		exit(1);
+	}
+
+	if (!g_strcmp0(uchoice, "ACCEPT")) {
+		gchar *d = g_strdup(origin);
+		g_hash_table_add(acceptedInputQueryDomains, d);
+		webkit_permission_request_allow(r);
+	} else {
+		webkit_permission_request_deny(r);
+	}
+	g_strfreev(ar);
+
+	gpointer oldkey;
+	gpointer oldvalue;
+	g_hash_table_lookup_extended(permissionRequests, key, &oldkey, &oldvalue);
+	g_hash_table_steal(permissionRequests, key);
+	g_free(key);
+	g_free(oldkey);
+}
+
 GdkFilterReturn
 processx(GdkXEvent *e, GdkEvent *event, gpointer d)
 {
@@ -1324,6 +1464,21 @@ processx(GdkXEvent *e, GdkEvent *event,
 				loaduri(c, &a);
 
 				return GDK_FILTER_REMOVE;
+			} else if (ev->atom == atoms[AtomGeolocation]) {
+				a.v = getatom(c, AtomGeolocation);
+				addgeolocationdomain(c, &a);
+
+				return GDK_FILTER_REMOVE;
+			} else if (ev->atom == atoms[AtomMediaStream]) {
+				a.v = getatom(c, AtomMediaStream);
+				addmediastreamdomain(c, &a);
+
+				return GDK_FILTER_REMOVE;
+			} else if (ev->atom == atoms[AtomInputQuery]) {
+				a.v = getatom(c, AtomInputQuery);
+				addinputquerydomain(c, &a);
+
+				return GDK_FILTER_REMOVE;
 			}
 		}
 	}
@@ -1577,28 +1732,125 @@ mousetargetchanged(WebKitWebView *v, Web
 	updatetitle(c);
 }
 
+gchar *
+getorigin(WebKitWebView *v) {
+	WebKitSecurityOrigin *so = webkit_security_origin_new_for_uri(webkit_web_view_get_uri(v));
+	gchar *s = webkit_security_origin_to_string(so);
+	webkit_security_origin_unref(so);
+	return s;
+}
+
 gboolean
 permissionrequested(WebKitWebView *v, WebKitPermissionRequest *r, Client *c)
 {
 	ParamName param = ParameterLast;
+	gchar *message;
+	gchar *nprop;
+
+	gchar *domain = getorigin(v);
 
+	fprintf(stdout, "surf: permissionrequested() called");
 	if (WEBKIT_IS_GEOLOCATION_PERMISSION_REQUEST(r)) {
+		fprintf(stdout, "surf: geolocation request");
 		param = Geolocation;
+		message = "Allow geolocation";
+		nprop = "_SURF_GEOL";
+
+		if (g_hash_table_lookup(acceptedGeolocationDomains, domain)) {
+			g_free(domain);
+			return TRUE;
+		}
 	} else if (WEBKIT_IS_USER_MEDIA_PERMISSION_REQUEST(r)) {
-		if (webkit_user_media_permission_is_for_audio_device(
-		    WEBKIT_USER_MEDIA_PERMISSION_REQUEST(r)))
-			param = AccessMicrophone;
-		else if (webkit_user_media_permission_is_for_video_device(
-		         WEBKIT_USER_MEDIA_PERMISSION_REQUEST(r)))
-			param = AccessWebcam;
+		fprintf(stdout, "surf: media permission request");
+		gboolean microphone = webkit_user_media_permission_is_for_audio_device(
+		    WEBKIT_USER_MEDIA_PERMISSION_REQUEST(r));
+		gboolean camera = webkit_user_media_permission_is_for_video_device(
+		         WEBKIT_USER_MEDIA_PERMISSION_REQUEST(r));
+
+		if (g_hash_table_lookup(acceptedMediaStreamDomains, domain)) {
+			g_free(domain);
+			return TRUE;
+		}
+
+		if (microphone && camera) {
+			fprintf(stdout, "surf: microphone and webcam permissions requested");
+			param = AccessMediaStream;
+			message = "Allow microphone and camera";
+		} else if (microphone) {
+			fprintf(stdout, "surf: microphone permissions requested");
+			param = AccessMediaStream;
+			message = "Allow microphone";
+		} else if (camera) {
+			fprintf(stdout, "surf: webcam permissions requested");
+			param = AccessMediaStream;
+			message = "Allow webcam";
+		} else {
+			fprintf(stdout, "surf: unknown media permissions requested");
+			message = "Allow input device";
+		}
+		nprop = "_SURF_MEST";
+	} else if (WEBKIT_IS_DEVICE_INFO_PERMISSION_REQUEST(r)) {
+		fprintf(stdout, "surf: device enumeration request");
+		message = "Allow input device inspection";
+		nprop = "_SURF_INQU";
+
+		if (g_hash_table_lookup(acceptedInputQueryDomains, domain)) {
+			g_free(domain);
+			return TRUE;
+		}
 	} else {
+		fprintf(stdout, "surf: permission request unknown");
+		g_free(domain);
 		return FALSE;
 	}
 
-	if (curconfig[param].val.i)
-		webkit_permission_request_allow(r);
-	else
-		webkit_permission_request_deny(r);
+	gchar *tvprop, *fvprop;
+	tvprop = g_strdup_printf("%s|ACCEPT", domain);
+	fvprop = g_strdup_printf("%s|REJECT", domain);
+
+	/* Does not work, dmenu complains about not grabbing keyboard
+	Arg a = (Arg){
+		.v = (const char *[]) {
+			"/bin/bash", "-c",
+			"echo -e \"yes\nno\" "
+				"| dmenu -p \"$1 for $2?\" "
+				"| ( grep -q \"yes\" "
+					"&& xprop -id $3 -f $4 8s -set $5 \"$6\" ) "
+					"|| xprop -id $7 -f $8 8s -set $9 \"$10\" ",
+			"surf-permission-requested",
+			message, domain,
+			winid, nprop, nprop, tvprop,
+			winid, nprop, nprop, fvprop, NULL
+		}
+	};
+	spawn(c, &a);
+	*/
+
+	gchar *key;
+	key = g_strdup_printf("%s|%s", domain, nprop);
+	if (!g_hash_table_contains(permissionRequests, key)) {
+		g_hash_table_insert(permissionRequests, key, r);
+	} else {
+		g_free(key);
+	}
+
+	// does not work with spawn()
+	gchar *command;
+	command = g_strdup_printf(
+			"echo -e \"yes\nno\" "
+				"| dmenu -p \"%s for %s?\" "
+				"| ( grep -q \"yes\" "
+					"&& xprop -id %s -f %s 8s -set %s \"%s\" ) "
+					"|| xprop -id %s -f %s 8s -set %s \"%s\" ",
+			message, domain,
+			winid, nprop, nprop, tvprop,
+			winid, nprop, nprop, fvprop);
+	system(command);
+	g_free(command);
+
+	g_free(domain);
+	g_free(tvprop);
+	g_free(fvprop);
 
 	return TRUE;
 }
@@ -2071,6 +2323,14 @@ main(int argc, char *argv[])
 		defconfig[Inspector].val.i = 1;
 		defconfig[Inspector].prio = 2;
 		break;
+	case 'O':
+		defconfig[AccessMediaStream].val.i = 1;
+		defconfig[AccessMediaStream].prio = 2;
+		break;
+	case 'o':
+		defconfig[AccessMediaStream].val.i = 0;
+		defconfig[AccessMediaStream].prio = 2;
+		break;
 	case 'r':
 		scriptfile = EARGF(usage());
 		break;
