--- a/arch/x86/crypto/tresor_glue.c.orig	2024-02-08 23:34:54.312593627 -0800
+++ b/arch/x86/crypto/tresor_glue.c	2024-02-08 23:36:52.995230481 -0800
@@ -32,6 +32,7 @@
  * Copyright Â© 2012-2013 Jussi Kivilinna <jussi.kivilinna@iki.fi>
  */
 
+#include <asm/processor.h>
 #include <crypto/algapi.h>
 #include <crypto/b128ops.h>
 #include <crypto/internal/simd.h>
@@ -191,6 +192,12 @@ static int tresor_skcipher_setkey(struct
 
 static int ecb_encrypt(struct skcipher_request *req)
 {
+	unsigned int ecx = cpuid_ecx(0x00000001);
+	if (ecx & (1 << 25))
+		; // aes-ni: true
+	else
+		return -ENOTSUPP;
+
 	ECB_WALK_START(req, AES_BLOCK_SIZE, -1);
 	ECB_BLOCK(1, tresor_encrypt);
 	ECB_WALK_END();
@@ -198,6 +205,12 @@ static int ecb_encrypt(struct skcipher_r
 
 static int ecb_decrypt(struct skcipher_request *req)
 {
+	unsigned int ecx = cpuid_ecx(0x00000001);
+	if (ecx & (1 << 25))
+		; // aes-ni: true
+	else
+		return -ENOTSUPP;
+
 	ECB_WALK_START(req, AES_BLOCK_SIZE, -1);
 	ECB_BLOCK(1, tresor_decrypt);
 	ECB_WALK_END();
@@ -206,6 +219,12 @@ static int ecb_decrypt(struct skcipher_r
 
 static int cbc_encrypt(struct skcipher_request *req)
 {
+	unsigned int ecx = cpuid_ecx(0x00000001);
+	if (ecx & (1 << 25))
+		; // aes-ni: true
+	else
+		return -ENOTSUPP;
+
 	CBC_WALK_START(req, AES_BLOCK_SIZE, -1);
 	CBC_ENC_BLOCK(tresor_encrypt);
 	CBC_WALK_END();
@@ -213,6 +232,12 @@ static int cbc_encrypt(struct skcipher_r
 
 static int cbc_decrypt(struct skcipher_request *req)
 {
+	unsigned int ecx = cpuid_ecx(0x00000001);
+	if (ecx & (1 << 25))
+		; // aes-ni: true
+	else
+		return -ENOTSUPP;
+
 	CBC_WALK_START(req, AES_BLOCK_SIZE, -1);
 	CBC_DEC_BLOCK(1, tresor_decrypt);
 	CBC_WALK_END();
