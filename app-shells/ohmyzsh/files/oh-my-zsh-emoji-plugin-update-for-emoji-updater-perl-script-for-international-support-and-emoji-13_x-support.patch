--- a/plugins/emoji/update_emoji.pl.orig	2019-08-27 12:41:44.000000000 -0700
+++ b/plugins/emoji/update_emoji.pl	2019-08-30 15:09:05.421032706 -0700
@@ -16,19 +16,40 @@
 # to avoid possible complications with having to escape the strings when using them as
 # array subscripts. The definition file seems to use some combining characters like accents
 # that get stripped during this process.
+#
+# Ordering can be found at https://www.unicode.org/emoji/charts-12.0/emoji-ordering.html .
+#
+# International support:
+# See https://github.com/unicode-org/cldr/tree/master/common/annotations
+# See --help for more information.
+#
+# Dictionaries:
+# See https://github.com/unicode-org/cldr/blob/master/common/main
+#
 
 use strict;
 use warnings;
 use 5.010;
 use autodie;
+use utf8;
 
 use Path::Class;
 use File::Copy;
+use XML::LibXML;
+use Text::Unaccent;
+
+sub sanitizer {
+	my $s = join("_",@_);
+	$s = lc($s);
+	$s =~ s/\&//g;
+	$s =~ s/\s/_/g;
+	$s =~ s/_+/_/g;
+	return $s;
+}
 
 # Parse definitions out of the data file and convert
-sub process_emoji_data_file {
-	my ( $infile, $outfilename ) = @_;
-	my $file = file($infile);
+sub process_emoji_data_files {
+	my ( $lang_code, $cldr_dict, $cldr_annotations, $cldr_annotations_derived, $outfilename ) = @_;
 	my $outfile = file($outfilename);
 	my $outfilebase = $outfile->basename();
 	my $tempfilename = "$outfilename.tmp";
@@ -39,63 +60,213 @@ sub process_emoji_data_file {
 #
 # This file is auto-generated by update_emoji.pl. Do not edit it manually.
 #
+
+");
+
+	my $dom;
+
+
+	$dom = XML::LibXML->load_xml(location => $cldr_dict);
+	my %dict;
+	foreach my $character_label ($dom->findnodes('//characterLabel')) {
+		$dict{$character_label->getAttribute("type")} = $character_label->to_literal();
+	}
+
+	$dom = XML::LibXML->load_xml(location => $cldr_annotations);
+
+	my @divisions;
+	# language agnostic descriptions
+	my $_emoji = sanitizer($dict{"emoji"});
+	my $division_modifier = sanitizer($dict{"modifier"});
+	my $division_symbols = sanitizer($dict{"symbols"});
+	my $division_smiley = sanitizer($dict{"smiley"});
+	my $division_person = sanitizer($dict{"person"});
+	my $division_nature = sanitizer($dict{"nature"});
+	my $division_food = sanitizer($dict{"food_drink"});
+	my $division_place = sanitizer($dict{"place"});
+	my $division_activities = sanitizer($dict{"activities"});
+	my $division_objects = sanitizer($dict{"objects"});
+	my $division_flags = sanitizer($dict{"flags"});
+	my $division_other = sanitizer($dict{"other"});
+	@divisions = ($division_modifier, $division_symbols, $division_smiley, $division_person, 
+		$division_modifier, $division_nature, $division_food, $division_place, 
+		$division_activities, $division_objects, $division_symbols, $division_flags, $division_other);
+	my $current_division = 0;
+
+	$outfh->print("
 # This contains the definition for:
-#   \$emoji         - which maps character names to Unicode characters
-#   \$emoji_flags   - maps country names to Unicode flag characters using region indicators
+#   \$${_emoji}
+#   \$${_emoji}_${division_modifier}
+#   \$${_emoji}_${division_symbols}
+#   \$${_emoji}_${division_smiley}
+#   \$${_emoji}_${division_person}
+#   \$${_emoji}_${division_nature}
+#   \$${_emoji}_${division_food}
+#   \$${_emoji}_${division_place}
+#   \$${_emoji}_${division_activities}
+#   \$${_emoji}_${division_objects}
+#   \$${_emoji}_${division_flags}
+#   \$${_emoji}_${division_other}
 
 # Main emoji
-typeset -gAH emoji
-# National flags
-typeset -gAH emoji_flags
-# Combining modifiers
-typeset -gAH emoji_mod
+typeset -gAH $_emoji
+
+# See emoji-ordering.html
+typeset -gAH ${_emoji}_${division_modifier}
+typeset -gAH ${_emoji}_${division_symbols}
+typeset -gAH ${_emoji}_${division_smiley}
+typeset -gAH ${_emoji}_${division_person}
+typeset -gAH ${_emoji}_${division_nature}
+typeset -gAH ${_emoji}_${division_food}
+typeset -gAH ${_emoji}_${division_place}
+typeset -gAH ${_emoji}_${division_activities}
+typeset -gAH ${_emoji}_${division_objects}
+typeset -gAH ${_emoji}_${division_flags}
+typeset -gAH ${_emoji}_${division_other}
 
 ");
 
-	my $fh = $file->openr();
-	my $line_num = 0;
-	while ( my $line = $fh->getline() ) {
-		$line_num++;
-		$_ = $line;
-		# Skip all-comment lines (from the header) and blank lines
-		# (But don't strip comments on normal lines; we need to parse those for
-		# the emoji names.)
-		next if /^\s*#/ or /^\s*$/;
-
-		if (/^(\S.*?\S)\s*;\s*(\w+)\s*;\s*(\w+)\s*;\s*(\w+)\s*;\s*(\w.*?)\s*#\s*V(\S+)\s\(.*?\)\s*(\w.*\S)\s*$/) {
-			my ($code, $style, $level, $modifier_status, $sources, $version, $keycap_name)
-				= ($1, $2, $3, $4, $5, $6, $7);
-			#print "code=$code style=$style level=$level modifier_status=$modifier_status sources=$sources version=$version name=$keycap_name\n";
-			my @code_points = split /\s+/, $code;
-			my @sources = split /\s+/, $sources;
-
-			my $flag_country = "";
-			if ( $keycap_name =~ /^flag for (\S.*?)\s*$/) {
-				$flag_country = $1;
-			}
-
-			my $zsh_code = join '', map { "\\U$_" } @code_points;
-			# Convert keycap names to valid associative array names that do not require any
-			# quoting. Works fine for most stuff, but is clumsy for flags.
-			my $omz_name = lc($keycap_name);
-			$omz_name =~ s/[^A-Za-z0-9]/_/g;
-			my $zsh_flag_country = $flag_country;
-			$zsh_flag_country =~ s/[^\p{Letter}]/_/g;
-			if ($flag_country) {
-				$outfh->print("emoji_flags[$zsh_flag_country]=\$'$zsh_code'\n");
-			} else {
-				$outfh->print("emoji[$omz_name]=\$'$zsh_code'\n");
-			}
-			# Modifiers are included in both the main set and their separate map,
-			# because they have a standalone representation as a color swatch.
-			if ( $modifier_status eq "modifier" ) {
-				$outfh->print("emoji_mod[$omz_name]=\$'$zsh_code'\n");
-			}
-		} else {
-			die "Failed parsing line $line_num: '$_'";
+
+	foreach my $annotation ($dom->findnodes('//annotation')) {
+
+		next if not defined $annotation->getAttribute("type");
+
+		#print "\n";
+		#print "\n";
+		#print "annotation text: " . $annotation->to_literal() . "\n";
+		#print "annotation id: " . $annotation->getAttribute("cp") . "\n";
+		my $code_point = $annotation->getAttribute("cp");
+		$code_point =~ s/(.)/sprintf "\\U%04x", ord($1)/sge;
+		#print "annotation id hex:" . $code_point . "\n";
+
+		if ( $code_point eq "\\U26a7" ) { # transgender ; symbol
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f600" ) { # grinning face ; emotion
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f44b" ) { # waving hand ; people
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f9b0" ) { # redhead ; physical
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f435" ) { # face | monkey ; outside
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f347" ) { # grapes ; food
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f30d" ) { # globe showing Europe-Africa ; places
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f383" ) { # jack-o-lantern ; activities
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f453" ) { # eyeglasses ; objects
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f3e7" ) { # ATM sign ; symbols
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f3c1" ) { # chequered flag ; flags
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f6d6" ) { # roundhouse ; other
+			$current_division++;
+		}
+		my $division = $divisions[$current_division];
+		#printf "$division";
+
+		# Convert keycap names to valid associative array names that do not require any
+		# quoting. Works fine for most stuff, but is clumsy for flags.
+		my $omz_name = lc($annotation->to_literal());
+		$omz_name =~ s/flag: //g;
+
+		$omz_name =~ s/#/pound/g;
+		$omz_name =~ s/\*/star/g;
+
+		$omz_name =~ s/[“”:\.!’\(\)-]//g;
+		$omz_name =~ s/\&/and/g;
+		$omz_name =~ s/, /_/g;
+		$omz_name =~ s/[^\w]/_/g; # allow other ways of saying the emoji name in other languages
+
+		my $array_name = ${_emoji} . "_" . $division;
+		$outfh->print($array_name . "[$omz_name]=\$'$code_point'\n");
+
+		# allow to type non-accented for language learners or those without the keyboard mapping
+		my $omz_name_unaccented;
+		my $array_name_unaccented;
+		$omz_name_unaccented = unac_string('UTF-8', $omz_name);
+		$array_name_unaccented = unac_string('UTF-8', ${_emoji} . "_" . $division);
+		if ($omz_name ne $omz_name_unaccented or $array_name ne $array_name_unaccented) {
+			$outfh->print($array_name_unaccented . "[$omz_name_unaccented]=\$'$code_point'\n");
 		}
 	}
-	$fh->close();
+
+	if ( index($lang_code, "en") ne -1 ) {
+		$outfh->print(${_emoji} . "_" . $division_flags . "[palestine]=\$'\\U1f1f5\\U1f1f8'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[usa]=\$'\\U1f1fa\\U1f1f8'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[america]=\$'\\U1f1fa\\U1f1f8'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[united_states_of_america]=\$'\\U1f1fa\\U1f1f8'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[un]=\$'\\U1f1fa\\U1f1f3'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[uk]=\$'\\U1f1ec\\U1f1e7'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[jpn]=\$'\\U1f1ef\\U1f1f5'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[nz]=\$'\\U1f1f3\\U1f1ff'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[myanmar]=\$'\\U1f1f2\\U1f1f2'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[burma]=\$'\\U1f1f2\\U1f1f2'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[eu]=\$'\\U1f1ea\\U1f1fa'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[uae]=\$'\\U1f1e6\\U1f1ea'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[st_maarten]=\$'\\U1f1f8\\U1f1fd'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[saint_maarten]=\$'\\U1f1f8\\U1f1fd'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[st_martin]=\$'\\U1f1f8\\U1f1fd'\n");
+		$outfh->print(${_emoji} . "_" . $division_flags . "[saint_martin]=\$'\\U1f1f8\\U1f1fd'\n");
+	}
+
+	@divisions = ($division_person, $division_symbols, $division_flags, $division_symbols);
+	$current_division = 0;
+
+	# contains flag data
+	$dom = XML::LibXML->load_xml(location => $cldr_annotations_derived);
+	foreach my $annotation ($dom->findnodes('//annotation')) {
+
+		next if not defined $annotation->getAttribute("type");
+
+		#print "\n";
+		#print "\n";
+		#print "annotation text: " . $annotation->to_literal() . "\n";
+		#print "annotation id: " . $annotation->getAttribute("cp") . "\n";
+		my $code_point = $annotation->getAttribute("cp");
+		$code_point =~ s/(.)/sprintf "\\U%04x", ord($1)/sge;
+		#print "annotation id hex:" . $code_point . "\n";
+
+		if ( $code_point eq "\\U0023\\U20e3" ) { # keycap: # ; symbols
+			$current_division++;
+		} elsif ( $code_point eq "\\U1f1e6\\U1f1e8" ) { # flag: Ascension Island ; flags
+			$current_division++;
+		} elsif ( $code_point eq "\\U0030\\U20e3" ) { # keycap: 0 ; symbols
+			$current_division++;
+		}
+
+		my $division = $divisions[$current_division];
+		#printf "$division";
+
+		# Convert keycap names to valid associative array names that do not require any
+		# quoting. Works fine for most stuff, but is clumsy for flags.
+		my $omz_name = lc($annotation->to_literal());
+		$omz_name =~ s/flag: //g;
+
+		$omz_name =~ s/#/pound/g;
+		$omz_name =~ s/\*/star/g;
+
+		$omz_name =~ s/[“”:\.!’\(\)-]//g;
+		$omz_name =~ s/\&/and/g;
+		$omz_name =~ s/, /_/g;
+		$omz_name =~ s/[^\w]/_/g; # allow other ways of saying the emoji name in other languages
+
+		
+		my $array_name = ${_emoji} . "_" . $division;
+		$outfh->print($array_name . "[$omz_name]=\$'$code_point'\n");
+
+		# allow to type non-accented for language learners or those without the keyboard mapping
+		my $omz_name_unaccented;
+		my $array_name_unaccented;
+		$omz_name_unaccented = unac_string('UTF-8', $omz_name);
+		$array_name_unaccented = unac_string('UTF-8', ${_emoji} . "_" . $division);
+		if ($omz_name ne $omz_name_unaccented or $array_name ne $array_name_unaccented) {
+			$outfh->print($array_name_unaccented . "[$omz_name_unaccented]=\$'$code_point'\n");
+		}
+	}
+	
 	$outfh->print("\n");
 	$outfh->close();
 
@@ -103,11 +274,40 @@ typeset -gAH emoji_mod
 		or die "Failed moving temp file to $outfilename: $!";
 }
 
-my $datafile = "emoji-data.txt";
-my $zsh_def_file = "emoji-char-definitions.zsh";
-process_emoji_data_file($datafile, $zsh_def_file);
+foreach my $arg (@ARGV) {
+	if ( index($arg, "--help") ne -1 || index($arg, "-help") ne -1 || index($arg, "-h") ne -1 ) {
+		print("
+Usage: $0 lang_code
 
-print "Updated definition file $zsh_def_file\n";
+    lang_code                 - language code in ISO 639-1
 
+Supported languages can be found at:
 
+    https://github.com/unicode-org/cldr/blob/master/common/main
 
+");
+		exit 0;
+	}
+}
+
+# This must be in ISO 639-1 or whatever is in https://github.com/unicode-org/cldr/blob/master/common/main .
+my $lang_code = "en";
+if (defined $ARGV[0]) {
+	$lang_code = $ARGV[0];
+}
+
+my $cldr_dict = "$lang_code-main.xml";
+my $cldr_annotations = "$lang_code-annotations.xml";
+my $cldr_annotations_derived = "$lang_code-annotationsDerived.xml";
+
+system("wget https://raw.githubusercontent.com/unicode-org/cldr/master/common/main/$lang_code.xml -O $cldr_dict");
+system("wget https://raw.githubusercontent.com/unicode-org/cldr/master/common/annotations/$lang_code.xml -O $cldr_annotations");
+system("wget https://raw.githubusercontent.com/unicode-org/cldr/master/common/annotationsDerived/$lang_code.xml -O $cldr_annotations_derived");
+
+# The word emoji is written differently in other languages.
+# The dictionary will translate the categories and the word emoji in native language of user.
+
+my $zsh_def_file = "emoji-char-definitions.zsh";
+process_emoji_data_files($lang_code, $cldr_dict, $cldr_annotations, $cldr_annotations_derived, $zsh_def_file);
+
+print "Updated definition file $zsh_def_file\n";
