diff '--color=auto' -urp abseil-cpp-20220623.2.orig/absl/container/internal/raw_hash_set.h abseil-cpp-20220623.2/absl/container/internal/raw_hash_set.h
--- abseil-cpp-20220623.2.orig/absl/container/internal/raw_hash_set.h	2024-02-12 11:50:36.000000000 -0800
+++ abseil-cpp-20220623.2/absl/container/internal/raw_hash_set.h	2025-10-19 08:04:42.148766383 -0700
@@ -745,6 +745,12 @@ inline size_t NormalizeCapacity(size_t n
   return n ? ~size_t{} >> countl_zero(n) : 1;
 }
 
+template <size_t kSlotSize>
+size_t MaxValidCapacity() {
+  return NormalizeCapacity((std::numeric_limits<size_t>::max)() / 4 /
+                           kSlotSize);
+}
+
 // General notes on capacity/growth methods below:
 // - We use 7/8th as maximum load factor. For 16-wide groups, that gives an
 //   average of two empty slots per group.
@@ -1148,6 +1154,8 @@ class raw_hash_set {
       : ctrl_(EmptyGroup()),
         settings_(0, HashtablezInfoHandle(), hash, eq, alloc) {
     if (bucket_count) {
+      ABSL_RAW_CHECK(bucket_count <= MaxValidCapacity<sizeof(slot_type)>(),
+                     "Hash table size overflow");
       capacity_ = NormalizeCapacity(bucket_count);
       initialize_slots();
     }
@@ -1341,7 +1349,9 @@ class raw_hash_set {
   bool empty() const { return !size(); }
   size_t size() const { return size_; }
   size_t capacity() const { return capacity_; }
-  size_t max_size() const { return (std::numeric_limits<size_t>::max)(); }
+  size_t max_size() const {
+    return CapacityToGrowth(MaxValidCapacity<sizeof(slot_type)>());
+  }
 
   ABSL_ATTRIBUTE_REINITIALIZES void clear() {
     // Iterating over this container is O(bucket_count()). When bucket_count()
@@ -1678,6 +1688,8 @@ class raw_hash_set {
     auto m = NormalizeCapacity(n | GrowthToLowerboundCapacity(size()));
     // n == 0 unconditionally rehashes as per the standard.
     if (n == 0 || m > capacity_) {
+      ABSL_RAW_CHECK(m <= MaxValidCapacity<sizeof(slot_type)>(),
+                     "Hash table size overflow");
       resize(m);
 
       // This is after resize, to ensure that we have completed the allocation
@@ -1688,6 +1700,7 @@ class raw_hash_set {
 
   void reserve(size_t n) {
     if (n > size() + growth_left()) {
+      ABSL_RAW_CHECK(n <= max_size(), "Hash table size overflow");
       size_t m = GrowthToLowerboundCapacity(n);
       resize(NormalizeCapacity(m));
 
diff '--color=auto' -urp abseil-cpp-20220623.2.orig/absl/container/internal/raw_hash_set_test.cc abseil-cpp-20220623.2/absl/container/internal/raw_hash_set_test.cc
--- abseil-cpp-20220623.2.orig/absl/container/internal/raw_hash_set_test.cc	2024-02-12 11:50:36.000000000 -0800
+++ abseil-cpp-20220623.2/absl/container/internal/raw_hash_set_test.cc	2025-10-19 07:57:49.960541721 -0700
@@ -2181,6 +2181,14 @@ TEST(Table, AlignOne) {
   }
 }
 
+TEST(Table, MaxSizeOverflow) {
+  size_t overflow = (std::numeric_limits<size_t>::max)();
+  EXPECT_DEATH_IF_SUPPORTED(IntTable t(overflow), "Hash table size overflow");
+  IntTable t;
+  EXPECT_DEATH_IF_SUPPORTED(t.reserve(overflow), "Hash table size overflow");
+  EXPECT_DEATH_IF_SUPPORTED(t.rehash(overflow), "Hash table size overflow");
+}
+
 }  // namespace
 }  // namespace container_internal
 ABSL_NAMESPACE_END
