diff '--color=auto' -urp abseil-cpp-20200225.3.orig/absl/container/internal/raw_hash_set.h abseil-cpp-20200225.3/absl/container/internal/raw_hash_set.h
--- abseil-cpp-20200225.3.orig/absl/container/internal/raw_hash_set.h	2020-10-09 11:48:48.000000000 -0700
+++ abseil-cpp-20200225.3/absl/container/internal/raw_hash_set.h	2025-10-19 08:11:52.641505180 -0700
@@ -474,6 +474,12 @@ inline size_t NormalizeCapacity(size_t n
   return n ? ~size_t{} >> LeadingZeros(n) : 1;
 }
 
+template <size_t kSlotSize>
+size_t MaxValidCapacity() {
+  return NormalizeCapacity((std::numeric_limits<size_t>::max)() / 4 /
+                           kSlotSize);
+}
+
 // We use 7/8th as maximum load factor.
 // For 16-wide groups, that gives an average of two empty slots per group.
 inline size_t CapacityToGrowth(size_t capacity) {
@@ -726,6 +732,8 @@ class raw_hash_set {
                         const allocator_type& alloc = allocator_type())
       : ctrl_(EmptyGroup()), settings_(0, hash, eq, alloc) {
     if (bucket_count) {
+      ABSL_RAW_CHECK(bucket_count <= MaxValidCapacity<sizeof(slot_type)>(),
+                     "Hash table size overflow");
       capacity_ = NormalizeCapacity(bucket_count);
       reset_growth_left();
       initialize_slots();
@@ -919,7 +927,9 @@ class raw_hash_set {
   bool empty() const { return !size(); }
   size_t size() const { return size_; }
   size_t capacity() const { return capacity_; }
-  size_t max_size() const { return (std::numeric_limits<size_t>::max)(); }
+  size_t max_size() const {
+    return CapacityToGrowth(MaxValidCapacity<sizeof(slot_type)>());
+  }
 
   ABSL_ATTRIBUTE_REINITIALIZES void clear() {
     // Iterating over this container is O(bucket_count()). When bucket_count()
@@ -1253,11 +1263,16 @@ class raw_hash_set {
     auto m = NormalizeCapacity(n | GrowthToLowerboundCapacity(size()));
     // n == 0 unconditionally rehashes as per the standard.
     if (n == 0 || m > capacity_) {
+      ABSL_RAW_CHECK(m <= MaxValidCapacity<sizeof(slot_type)>(),
+                     "Hash table size overflow");
       resize(m);
     }
   }
 
-  void reserve(size_t n) { rehash(GrowthToLowerboundCapacity(n)); }
+  void reserve(size_t n) {
+    ABSL_RAW_CHECK(n <= max_size(), "Hash table size overflow");
+    rehash(GrowthToLowerboundCapacity(n));
+  }
 
   // Extension API: support for heterogeneous keys.
   //
Only in abseil-cpp-20200225.3/absl/container/internal: raw_hash_set.h.orig
Only in abseil-cpp-20200225.3/absl/container/internal: raw_hash_set.h.rej
diff '--color=auto' -urp abseil-cpp-20200225.3.orig/absl/container/internal/raw_hash_set_test.cc abseil-cpp-20200225.3/absl/container/internal/raw_hash_set_test.cc
--- abseil-cpp-20200225.3.orig/absl/container/internal/raw_hash_set_test.cc	2020-10-09 11:48:48.000000000 -0700
+++ abseil-cpp-20200225.3/absl/container/internal/raw_hash_set_test.cc	2025-10-19 08:09:36.806478137 -0700
@@ -1865,6 +1865,14 @@ TEST(Sanitizer, PoisoningOnErase) {
 }
 #endif  // ADDRESS_SANITIZER
 
+TEST(Table, MaxSizeOverflow) {
+  size_t overflow = (std::numeric_limits<size_t>::max)();
+  EXPECT_DEATH_IF_SUPPORTED(IntTable t(overflow), "Hash table size overflow");
+  IntTable t;
+  EXPECT_DEATH_IF_SUPPORTED(t.reserve(overflow), "Hash table size overflow");
+  EXPECT_DEATH_IF_SUPPORTED(t.rehash(overflow), "Hash table size overflow");
+}
+
 }  // namespace
 }  // namespace container_internal
 ABSL_NAMESPACE_END
Only in abseil-cpp-20200225.3/absl/container/internal: raw_hash_set_test.cc.orig
